import { Trace, Page, Frame, Device, ContentView, ProxyViewContainer, GridLayout, Application, profile, Color, profilingUptime, TextView, knownFolders, File, path, View, LayoutBase, AbsoluteLayout, ActivityIndicator, BottomNavigation, Button, DatePicker, DockLayout, HtmlView, Image, Label, ListPicker, ListView, Placeholder, Progress, Repeater, ScrollView, SearchBar, SegmentedBar, SegmentedBarItem, Slider, StackLayout, FlexboxLayout, Switch, TabView, TabStrip, TabStripItem, TabContentItem, Tabs, TextField, TimePicker, WebView, WrapLayout, FormattedString, Span, ObservableArray, TabViewItem, ActionItem, NavigationButton, ActionBar, isAndroid, isIOS, platformNames, unsetValue, getViewById, animationTimingFunctionConverter, KeyframeAnimation, parseKeyframeDeclarations, CSSHelper, eachDescendant, CssAnimationProperty } from '@nativescript/core';
import '@nativescript/zone-js';
import { ɵsetRootDomAdapter, DOCUMENT, LocationStrategy, CommonModule, ViewportScroller, ɵNullViewportScroller, PlatformLocation } from '@angular/common';
import 'nativescript-intl';
import { __decorate } from 'tslib';
import { InjectionToken, EventEmitter, Sanitizer, PlatformRef, createPlatformFactory, platformCore, Injectable, ɵɵdefineInjectable, ɵɵinject, Component, ComponentFactoryResolver, ChangeDetectorRef, ViewContainerRef, Injector, ɵisListLikeIterable, Directive, ElementRef, IterableDiffers, ViewChild, Output, ContentChild, TemplateRef, Input, Inject, Host, ChangeDetectionStrategy, forwardRef, Optional, NgModule, NO_ERRORS_SCHEMA, Renderer2, NgZone, ViewEncapsulation, ErrorHandler, SystemJsNgModuleLoader, ɵINJECTOR_SCOPE, RendererFactory2, ApplicationModule, SkipSelf, HostListener, ContentChildren, Attribute, Compiler, SystemJsNgModuleLoaderConfig } from '@angular/core';
import { ResourceLoader } from '@angular/compiler';
import { DefaultUrlSerializer, Router, ActivatedRoute, PRIMARY_OUTLET, NavigationEnd, ChildrenOutletContexts, RouterModule, RouteReuseStrategy } from '@angular/router';
import { AnimationBuilder } from '@angular/animations';
import { ɵAnimationEngine, AnimationDriver, ɵAnimationStyleNormalizer, ɵWebAnimationsStyleNormalizer } from '@angular/animations/browser';
import { ɵAnimationRendererFactory, ɵBrowserAnimationBuilder } from '@angular/platform-browser/animations';
import { HttpXhrBackend, XhrFactory, HttpResponse, HttpErrorResponse, HttpBackend, HttpClientModule } from '@angular/common/http';
import { Observable, BehaviorSubject } from 'rxjs';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';

var NativeScriptDebug;
(function (NativeScriptDebug) {
    NativeScriptDebug.animationsTraceCategory = 'ns-animations';
    NativeScriptDebug.rendererTraceCategory = 'ns-renderer';
    NativeScriptDebug.viewUtilCategory = 'ns-view-util';
    NativeScriptDebug.routerTraceCategory = 'ns-router';
    NativeScriptDebug.routeReuseStrategyTraceCategory = 'ns-route-reuse-strategy';
    NativeScriptDebug.listViewTraceCategory = 'ns-list-view';
    NativeScriptDebug.bootstrapCategory = 'bootstrap';
    // TODO: migrate all usage to this - avoids extraneous method executions
    NativeScriptDebug.enabled = Trace.isEnabled();
    function isLogEnabled() {
        return Trace.isEnabled();
    }
    NativeScriptDebug.isLogEnabled = isLogEnabled;
    function animationsLog(message) {
        Trace.write(message, NativeScriptDebug.animationsTraceCategory);
    }
    NativeScriptDebug.animationsLog = animationsLog;
    function rendererLog(msg) {
        Trace.write(msg, NativeScriptDebug.rendererTraceCategory);
    }
    NativeScriptDebug.rendererLog = rendererLog;
    function rendererError(message) {
        Trace.write(message, NativeScriptDebug.rendererTraceCategory, Trace.messageType.error);
    }
    NativeScriptDebug.rendererError = rendererError;
    function viewUtilLog(msg) {
        Trace.write(msg, NativeScriptDebug.viewUtilCategory);
    }
    NativeScriptDebug.viewUtilLog = viewUtilLog;
    function routerLog(message) {
        Trace.write(message, NativeScriptDebug.routerTraceCategory);
    }
    NativeScriptDebug.routerLog = routerLog;
    function routerError(message) {
        Trace.write(message, NativeScriptDebug.routerTraceCategory, Trace.messageType.error);
    }
    NativeScriptDebug.routerError = routerError;
    function routeReuseStrategyLog(message) {
        Trace.write(message, NativeScriptDebug.routeReuseStrategyTraceCategory);
    }
    NativeScriptDebug.routeReuseStrategyLog = routeReuseStrategyLog;
    function styleError(message) {
        Trace.write(message, Trace.categories.Style, Trace.messageType.error);
    }
    NativeScriptDebug.styleError = styleError;
    function listViewLog(message) {
        Trace.write(message, NativeScriptDebug.listViewTraceCategory);
    }
    NativeScriptDebug.listViewLog = listViewLog;
    function listViewError(message) {
        Trace.write(message, NativeScriptDebug.listViewTraceCategory, Trace.messageType.error);
    }
    NativeScriptDebug.listViewError = listViewError;
    function bootstrapLog(message) {
        Trace.write(message, NativeScriptDebug.bootstrapCategory);
    }
    NativeScriptDebug.bootstrapLog = bootstrapLog;
    function bootstrapLogError(message) {
        Trace.write(message, NativeScriptDebug.bootstrapCategory, Trace.messageType.error);
    }
    NativeScriptDebug.bootstrapLogError = bootstrapLogError;
})(NativeScriptDebug || (NativeScriptDebug = {}));

class NativeScriptDomAdapter {
    constructor() {
        this.resourceLoaderType = null;
    }
    static makeCurrent() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog('Setting root DOM adapter...');
        }
        ɵsetRootDomAdapter(new NativeScriptDomAdapter());
    }
    hasProperty(_element, _name) {
        // TODO: actually check if the property exists.
        return true;
    }
    log(arg) {
        console.log(arg);
    }
    logError(arg) {
        console.log(arg);
    }
    logGroup(arg) {
        console.log(arg);
    }
    logGroupEnd() { }
    get attrToPropMap() {
        throw new Error('Not implemented!');
    }
    set attrToPropMap(_value) {
        throw new Error('Not implemented!');
    }
    setProperty(_el, _name, _value) {
        throw new Error('Not implemented!');
    }
    getProperty(_el, _name) {
        throw new Error('Not implemented!');
    }
    invoke(_el, _methodName, _args) {
        throw new Error('Not implemented!');
    }
    contains(_nodeA, _nodeB) {
        throw new Error('Not implemented!');
    }
    parse(_templateHtml) {
        throw new Error('Not implemented!');
    }
    query(_selector) {
        throw new Error('Not implemented!');
    }
    querySelector(_el /** TODO #9100 */, _selector) {
        throw new Error('Not implemented!');
    }
    querySelectorAll(_el /** TODO #9100 */, _selector) {
        throw new Error('Not implemented!');
    }
    on(_el /** TODO #9100 */, _evt /** TODO #9100 */, _listener /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    onAndCancel(_el /** TODO #9100 */, _evt /** TODO #9100 */, _listener /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    dispatchEvent(_el /** TODO #9100 */, _evt /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    createMouseEvent(_eventType /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    createEvent(_eventType) {
        throw new Error('Not implemented!');
    }
    preventDefault(_evt /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    isPrevented(_evt /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    getInnerHTML(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    getTemplateContent(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    getOuterHTML(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    nodeName(_node /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    nodeValue(_node /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    type(_node /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    content(_node /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    firstChild(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    nextSibling(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    parentElement(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    childNodes(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    childNodesAsList(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    clearNodes(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    appendChild(_el /** TODO #9100 */, _node /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    removeChild(_el /** TODO #9100 */, _node /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    replaceChild(_el /** TODO #9100 */, _newNode /** TODO #9100 */, _oldNode /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    remove(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    insertBefore(_el /** TODO #9100 */, _node /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    insertAllBefore(_el /** TODO #9100 */, _nodes /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    insertAfter(_el /** TODO #9100 */, _node /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    setInnerHTML(_el /** TODO #9100 */, _value /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    getText(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    setText(_el /** TODO #9100 */, _value) {
        throw new Error('Not implemented!');
    }
    getValue(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    setValue(_el /** TODO #9100 */, _value) {
        throw new Error('Not implemented!');
    }
    getChecked(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    setChecked(_el /** TODO #9100 */, _value) {
        throw new Error('Not implemented!');
    }
    createComment(_text) {
        throw new Error('Not implemented!');
    }
    createTemplate(_html /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    createElement(_tagName /** TODO #9100 */, _doc /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    createElementNS(_ns, _tagName, _doc /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    createTextNode(_text, _doc /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    createScriptTag(_attrName, _attrValue, _doc /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    createStyleElement(_css, _doc /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    createShadowRoot(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    getShadowRoot(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    getHost(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    getDistributedNodes(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    clone /*<T extends Node>*/(_node /*T*/) {
        throw new Error('Not implemented!');
    }
    getElementsByClassName(_element /** TODO #9100 */, _name) {
        throw new Error('Not implemented!');
    }
    getElementsByTagName(_element /** TODO #9100 */, _name) {
        throw new Error('Not implemented!');
    }
    classList(_element /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    addClass(_element /** TODO #9100 */, _className) {
        throw new Error('Not implemented!');
    }
    removeClass(_element /** TODO #9100 */, _className) {
        throw new Error('Not implemented!');
    }
    hasClass(_element /** TODO #9100 */, _className) {
        throw new Error('Not implemented!');
    }
    setStyle(_element /** TODO #9100 */, _styleName, _styleValue) {
        throw new Error('Not implemented!');
    }
    removeStyle(_element /** TODO #9100 */, _styleName) {
        throw new Error('Not implemented!');
    }
    getStyle(_element /** TODO #9100 */, _styleName) {
        throw new Error('Not implemented!');
    }
    hasStyle(_element /** TODO #9100 */, _styleName, _styleValue) {
        throw new Error('Not implemented!');
    }
    tagName(_element /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    attributeMap(_element /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    hasAttribute(_element /** TODO #9100 */, _attribute) {
        throw new Error('Not implemented!');
    }
    hasAttributeNS(_element /** TODO #9100 */, _ns, _attribute) {
        throw new Error('Not implemented!');
    }
    getAttribute(_element /** TODO #9100 */, _attribute) {
        throw new Error('Not implemented!');
    }
    getAttributeNS(_element /** TODO #9100 */, _ns, _attribute) {
        throw new Error('Not implemented!');
    }
    setAttribute(_element /** TODO #9100 */, _name, _value) {
        throw new Error('Not implemented!');
    }
    setAttributeNS(_element /** TODO #9100 */, _ns, _name, _value) {
        throw new Error('Not implemented!');
    }
    removeAttribute(_element /** TODO #9100 */, _attribute) {
        throw new Error('Not implemented!');
    }
    removeAttributeNS(_element /** TODO #9100 */, _ns, _attribute) {
        throw new Error('Not implemented!');
    }
    templateAwareRoot(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    createHtmlDocument() {
        throw new Error('Not implemented!');
    }
    defaultDoc() {
        throw new Error('Not implemented!');
    }
    getDefaultDocument() {
        throw new Error('Not implemented!');
    }
    getBoundingClientRect(_el /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    getTitle() {
        throw new Error('Not implemented!');
    }
    setTitle(_doc, _newTitle) {
        throw new Error('Not implemented!');
    }
    elementMatches(_n /** TODO #9100 */, _selector) {
        throw new Error('Not implemented!');
    }
    isTemplateElement(_el) {
        throw new Error('Not implemented!');
    }
    isTextNode(_node /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    isCommentNode(_node /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    isElementNode(_node /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    hasShadowRoot(_node /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    isShadowRoot(_node /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    importIntoDoc /*<T extends Node>*/(_node /*T*/) {
        throw new Error('Not implemented!');
    }
    adoptNode /*<T extends Node>*/(_node /*T*/) {
        throw new Error('Not implemented!');
    }
    getHref(_element /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    getEventKey(_event /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    resolveAndSetHref(_element /** TODO #9100 */, _baseUrl, _href) {
        throw new Error('Not implemented!');
    }
    supportsDOMEvents() {
        throw new Error('Not implemented!');
    }
    supportsNativeShadowDOM() {
        throw new Error('Not implemented!');
    }
    getGlobalEventTarget(_doc, _target) {
        throw new Error('Not implemented!');
    }
    getHistory() {
        throw new Error('Not implemented!');
    }
    getLocation() {
        throw new Error('Not implemented!');
    }
    getBaseHref() {
        throw new Error('Not implemented!');
    }
    resetBaseElement() {
        throw new Error('Not implemented!');
    }
    getUserAgent() {
        return 'Fake user agent';
    }
    setData(_element /** TODO #9100 */, _name, _value) {
        throw new Error('Not implemented!');
    }
    getComputedStyle(_element /** TODO #9100 */) {
        throw new Error('Not implemented!');
    }
    getData(_element /** TODO #9100 */, _name) {
        throw new Error('Not implemented!');
    }
    setGlobalVar(_name, _value) {
        throw new Error('Not implemented!');
    }
    supportsWebAnimation() {
        throw new Error('Not implemented!');
    }
    performanceNow() {
        throw new Error('Not implemented!');
    }
    getAnimationPrefix() {
        throw new Error('Not implemented!');
    }
    getTransitionEnd() {
        throw new Error('Not implemented!');
    }
    supportsAnimation() {
        throw new Error('Not implemented!');
    }
    supportsCookies() {
        return false;
    }
    getCookie(_name) {
        throw new Error('Not implemented!');
    }
    setCookie(_name, _value) {
        throw new Error('Not implemented!');
    }
}
NativeScriptDomAdapter.makeCurrent();

if (!console.group) {
    console.group = () => { };
}
if (!console.groupEnd) {
    console.groupEnd = () => { };
}

const APP_ROOT_VIEW = new InjectionToken('NativeScriptAppRootView');
const DeviceToken = new InjectionToken('NativeScriptPlatformDeviceToken');
const PAGE_FACTORY = new InjectionToken('NativeScriptPageFactory');
const defaultPageFactory = function (_opts) {
    return new Page();
};
const defaultPageFactoryProvider = { provide: PAGE_FACTORY, useValue: defaultPageFactory };
let _rootPageRef;
function setRootPage(page) {
    _rootPageRef = new WeakRef(page);
}
function getRootPage() {
    return _rootPageRef && _rootPageRef.get();
}
// Use an exported function to make the AoT compiler happy.
function getDefaultPage() {
    const rootPage = getRootPage();
    if (rootPage instanceof Page) {
        return rootPage;
    }
    // if (rootPage) {
    // 	return rootPage;
    // }
    const frame = Frame.topmost();
    if (frame && frame.currentPage) {
        return frame.currentPage;
    }
    return null;
}
const defaultPageProvider = { provide: Page, useFactory: getDefaultPage };
// Use an exported function to make the AoT compiler happy.
function getDefaultFrame() {
    return Frame.topmost();
}
const defaultFrameProvider = { provide: Frame, useFactory: getDefaultFrame };
// Use an exported function to make the AoT compiler happy.
function getDefaultDevice() {
    return Device;
}
const defaultDeviceProvider = { provide: DeviceToken, useFactory: getDefaultDevice };

class AppHostView extends ContentView {
    constructor(backgroundColor) {
        super();
        this.backgroundColor = backgroundColor;
    }
    get ngAppRoot() {
        return this._ngAppRoot;
    }
    set ngAppRoot(value) {
        this._ngAppRoot = value;
    }
    get content() {
        return this._content;
    }
    set content(value) {
        if (this._content) {
            this._content.parentNode = undefined;
        }
        this._content = value;
        if (value) {
            this._content.parentNode = this;
        }
        this.ngAppRoot = value;
        if (this._content instanceof ProxyViewContainer) {
            const grid = new GridLayout();
            grid.backgroundColor = this.backgroundColor;
            grid.addChild(this._content);
            this.ngAppRoot = grid;
        }
    }
}
class AppHostAsyncView extends GridLayout {
    constructor(backgroundColor) {
        super();
        this.backgroundColor = backgroundColor;
    }
    get ngAppRoot() {
        return this;
    }
    set ngAppRoot(value) {
        // ignored
    }
}

const onBeforeLivesync = new EventEmitter();
const onAfterLivesync = new EventEmitter();
let lastBootstrappedModule;
class NativeScriptSanitizer extends Sanitizer {
    sanitize(_context, value) {
        return value;
    }
}
class NativeScriptDocument {
    constructor() {
        // Required by the AnimationDriver
        this.body = {
            isOverride: true,
        };
    }
    createElement(tag) {
        throw new Error('NativeScriptDocument is not DOM Document. There is no createElement() method.');
    }
}
const COMMON_PROVIDERS = [defaultPageFactoryProvider, { provide: Sanitizer, useClass: NativeScriptSanitizer, deps: [] }, { provide: DOCUMENT, useClass: NativeScriptDocument, deps: [] }];
class NativeScriptPlatformRef extends PlatformRef {
    constructor(platform, appOptions = {}) {
        super();
        this.platform = platform;
        this.appOptions = appOptions;
    }
    bootstrapModuleFactory(moduleFactory) {
        this._bootstrapper = () => {
            let bootstrapFactory = moduleFactory;
            if (this.appOptions.hmrOptions) {
                bootstrapFactory = this.appOptions.hmrOptions.moduleTypeFactory();
            }
            return this.platform.bootstrapModuleFactory(bootstrapFactory);
        };
        this.bootstrapApp();
        return null; // Make the compiler happy
    }
    bootstrapModule(moduleType, compilerOptions = []) {
        this._bootstrapper = () => {
            let bootstrapType = moduleType;
            if (this.appOptions.hmrOptions) {
                bootstrapType = this.appOptions.hmrOptions.moduleTypeFactory();
            }
            return this.platform.bootstrapModule(bootstrapType, compilerOptions);
        };
        this.bootstrapApp();
        return null; // Make the compiler happy
    }
    bootstrapApp() {
        global.__onLiveSyncCore = () => {
            if (this.appOptions.hmrOptions) {
                const rootView = Application.getRootView();
                if (rootView) {
                    rootView._closeAllModalViewsInternal();
                }
                this.appOptions.hmrOptions.livesyncCallback(() => this._livesync());
            }
            else {
                this._livesync();
            }
        };
        if (this.appOptions && typeof this.appOptions.cssFile === 'string') {
            Application.setCssFileName(this.appOptions.cssFile);
        }
        this.bootstrapNativeScriptApp();
    }
    onDestroy(callback) {
        this.platform.onDestroy(callback);
    }
    get injector() {
        return this.platform.injector;
    }
    destroy() {
        this.platform.destroy();
    }
    get destroyed() {
        return this.platform.destroyed;
    }
    bootstrapNativeScriptApp() {
        let rootContent;
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.bootstrapLog('NativeScriptPlatform bootstrap started.');
        }
        const launchCallback = profile('@nativescript/angular/platform-common.launchCallback', (args) => {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.bootstrapLog('Application launch event fired');
            }
            // Create a temp page for root of the renderer
            let tempAppHostView;
            let tempAppHostAsyncView;
            if (this.appOptions && (this.appOptions.async || this.appOptions.launchView)) {
                tempAppHostAsyncView = new AppHostAsyncView(new Color(this.appOptions && this.appOptions.backgroundColor ? this.appOptions.backgroundColor : '#fff'));
                if (this.appOptions.launchView) {
                    this.appOptions.launchView.style.zIndex = 1000;
                    tempAppHostAsyncView.addChild(this.appOptions.launchView);
                }
                rootContent = tempAppHostAsyncView.ngAppRoot;
                setRootPage(tempAppHostAsyncView);
            }
            else {
                tempAppHostView = new AppHostView(new Color(this.appOptions && this.appOptions.backgroundColor ? this.appOptions.backgroundColor : '#fff'));
                setRootPage(tempAppHostView);
            }
            let bootstrapPromiseCompleted = false;
            const bootstrap = () => {
                this._bootstrapper().then((moduleRef) => {
                    bootstrapPromiseCompleted = true;
                    if (NativeScriptDebug.isLogEnabled()) {
                        NativeScriptDebug.bootstrapLog(`Angular bootstrap bootstrap done. uptime: ${profilingUptime()}`);
                    }
                    if (this.appOptions.launchView && this.appOptions.launchView.cleanup) {
                        this.appOptions.launchView.cleanup().then(() => {
                            // cleanup any custom launch views
                            tempAppHostAsyncView.removeChild(this.appOptions.launchView);
                            this.appOptions.launchView = null;
                        });
                    }
                    else if (tempAppHostView) {
                        rootContent = tempAppHostView.content;
                    }
                    lastBootstrappedModule = new WeakRef(moduleRef);
                }, (err) => {
                    bootstrapPromiseCompleted = true;
                    const errorMessage = err.message + '\n\n' + err.stack;
                    if (NativeScriptDebug.isLogEnabled()) {
                        NativeScriptDebug.bootstrapLogError('ERROR BOOTSTRAPPING ANGULAR');
                    }
                    if (NativeScriptDebug.isLogEnabled()) {
                        NativeScriptDebug.bootstrapLogError(errorMessage);
                    }
                    rootContent = this.createErrorUI(errorMessage);
                });
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.bootstrapLog('bootstrapAction called, draining micro tasks queue. Root: ' + rootContent);
                }
                global.Zone.drainMicroTaskQueue();
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.bootstrapLog('bootstrapAction called, draining micro tasks queue finished! Root: ' + rootContent);
                }
            };
            if (this.appOptions && this.appOptions.launchView && this.appOptions.launchView.startAnimation) {
                // start animations on next tick (after initial boot)
                setTimeout(() => {
                    // ensure launch animation is executed after launchView added to view stack
                    this.appOptions.launchView.startAnimation();
                });
            }
            bootstrap();
            // if (!bootstrapPromiseCompleted) {
            // 	const errorMessage = "Bootstrap promise didn't resolve";
            // 	if (NativeScriptDebug.isLogEnabled()) {
            // 		NativeScriptDebug.bootstrapLogError(errorMessage);
            // 	}
            // 	rootContent = this.createErrorUI(errorMessage);
            // }
            args.root = rootContent;
        });
        const exitCallback = profile('@nativescript/angular/platform-common.exitCallback', (args) => {
            const androidActivity = args.android;
            if (androidActivity && !androidActivity.isFinishing()) {
                // Exit event was triggered as a part of a restart of the app.
                return;
            }
            const lastModuleRef = lastBootstrappedModule ? lastBootstrappedModule.get() : null;
            if (lastModuleRef) {
                // Make sure the module is only destroyed once
                lastBootstrappedModule = null;
                lastModuleRef.destroy();
            }
            rootContent = null;
        });
        Application.on(Application.launchEvent, launchCallback);
        Application.on(Application.exitEvent, exitCallback);
        Application.run();
    }
    _livesync() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.bootstrapLog('Angular livesync started.');
        }
        const lastModuleRef = lastBootstrappedModule ? lastBootstrappedModule.get() : null;
        onBeforeLivesync.next(lastModuleRef);
        if (lastModuleRef) {
            lastModuleRef.destroy();
        }
        this._bootstrapper().then((moduleRef) => {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.bootstrapLog('Angular livesync done.');
            }
            onAfterLivesync.next({ moduleRef });
            lastBootstrappedModule = new WeakRef(moduleRef);
            Application.resetRootView({
                create: () => getRootPage(),
            });
        }, (error) => {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.bootstrapLogError('ERROR LIVESYNC BOOTSTRAPPING ANGULAR');
            }
            const errorMessage = error.message + '\n\n' + error.stack;
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.bootstrapLogError(errorMessage);
            }
            Application.resetRootView({
                create: () => this.createErrorUI(errorMessage),
            });
            onAfterLivesync.next({ error });
        });
    }
    createErrorUI(message) {
        const errorTextBox = new TextView();
        errorTextBox.text = message;
        errorTextBox.color = new Color('red');
        return errorTextBox;
    }
    createFrameAndPage(isLivesync) {
        const frame = new Frame();
        const pageFactory = this.platform.injector.get(PAGE_FACTORY);
        const page = pageFactory({ isBootstrap: true, isLivesync });
        frame.navigate({
            create: () => {
                return page;
            },
        });
        return { page, frame };
    }
}
__decorate([
    profile
], NativeScriptPlatformRef.prototype, "bootstrapModuleFactory", null);
__decorate([
    profile
], NativeScriptPlatformRef.prototype, "bootstrapModule", null);
__decorate([
    profile
], NativeScriptPlatformRef.prototype, "bootstrapApp", null);
__decorate([
    profile
], NativeScriptPlatformRef.prototype, "bootstrapNativeScriptApp", null);
__decorate([
    profile
], NativeScriptPlatformRef.prototype, "_livesync", null);

// "Static" platform
const _platformNativeScript = createPlatformFactory(platformCore, 'nativeScript', [...COMMON_PROVIDERS]);
function platformNativeScriptDynamic(options, extraProviders) {
    // Return raw platform to advanced users only if explicitly requested
    if (options && options.bootInExistingPage === true) {
        return _platformNativeScript(extraProviders);
    }
    else {
        return new NativeScriptPlatformRef(_platformNativeScript(extraProviders), options);
    }
}

// Allows greater flexibility with `file-system` and Angular
// Also provides a way for `file-system` to be mocked for testing
class NSFileSystem {
    currentApp() {
        return knownFolders.currentApp();
    }
    fileFromPath(path) {
        return File.fromPath(path);
    }
    fileExists(path) {
        return File.exists(path);
    }
}
NSFileSystem.decorators = [
    { type: Injectable }
];

const sourceExtensionsMap = {
    '.scss': '.css',
    '.sass': '.css',
    '.less': '.css',
};
class FileSystemResourceLoader extends ResourceLoader {
    constructor(fs) {
        super();
        this.fs = fs;
    }
    get(url) {
        const resolvedPath = this.resolve(url);
        const templateFile = this.fs.fileFromPath(resolvedPath);
        return templateFile.readTextSync();
    }
    resolve(url) {
        const normalizedSourceUrl = this.resolveRelativeUrls(url);
        const normalizedCompiledFileUrl = normalizedSourceUrl.replace(/\.\w+$/, (ext) => sourceExtensionsMap[ext] || ext);
        if (normalizedCompiledFileUrl !== normalizedSourceUrl && this.fs.fileExists(normalizedCompiledFileUrl)) {
            return normalizedCompiledFileUrl;
        }
        if (this.fs.fileExists(normalizedSourceUrl)) {
            return normalizedSourceUrl;
        }
        if (normalizedCompiledFileUrl === normalizedSourceUrl) {
            throw new Error(`Could not resolve ${url}. Looked for: ${normalizedSourceUrl}.`);
        }
        else {
            throw new Error(`Could not resolve ${url}.` + `Looked for: ${normalizedCompiledFileUrl}, ${normalizedSourceUrl}.`);
        }
    }
    resolveRelativeUrls(url) {
        // Angular assembles absolute URLs and prefixes them with //
        if (url.indexOf('/') !== 0) {
            // Resolve relative URLs based on the app root.
            return path.join(this.fs.currentApp().path, url);
        }
        else {
            return url;
        }
    }
}
FileSystemResourceLoader.decorators = [
    { type: Injectable }
];
FileSystemResourceLoader.ctorParameters = () => [
    { type: NSFileSystem }
];

function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
function isBlank(obj) {
    return obj === undefined || obj === null;
}

class FrameService {
    // TODO: Add any methods that are needed to handle frame/page navigation
    getFrame() {
        let topmostFrame = Frame.topmost();
        return topmostFrame;
    }
}
FrameService.ɵprov = ɵɵdefineInjectable({ factory: function FrameService_Factory() { return new FrameService(); }, token: FrameService, providedIn: "root" });
FrameService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];

class Outlet {
    constructor(outletKey, path, pathByOutlets, modalNavigationDepth) {
        // More than one frame available when using NSEmptyOutletComponent component
        // in module that lazy loads children (loadChildren) and has outlet name.
        this.frames = [];
        this.states = [];
        // Used in reuse-strategy by its children to determine if they should be detached too.
        this.shouldDetach = true;
        this.outletKeys = [outletKey];
        this.isPageNavigationBack = false;
        this.showingModal = false;
        this.modalNavigationDepth = modalNavigationDepth || 0;
        this.pathByOutlets = pathByOutlets;
        this.path = path;
    }
    containsFrame(frame) {
        return this.frames.indexOf(frame) > -1;
    }
    peekState() {
        if (this.states.length > 0) {
            return this.states[this.states.length - 1];
        }
        return null;
    }
    containsTopState(stateUrl) {
        const lastState = this.peekState();
        return lastState && lastState.segmentGroup.toString() === stateUrl;
    }
    // Search for frame that can go back.
    // Nested 'primary' outlets could result in Outlet with multiple navigatable frames.
    getFrameToBack() {
        let frame = this.frames[this.frames.length - 1];
        if (!this.isNSEmptyOutlet) {
            for (let index = this.frames.length - 1; index >= 0; index--) {
                const currentFrame = this.frames[index];
                if (currentFrame.canGoBack()) {
                    frame = currentFrame;
                    break;
                }
            }
        }
        return frame;
    }
}
const defaultNavOptions = {
    clearHistory: false,
    animated: true,
};

class NSLocationStrategy extends LocationStrategy {
    constructor(frameService) {
        super();
        this.frameService = frameService;
        this.outlets = [];
        this.popStateCallbacks = new Array();
        this._modalNavigationDepth = 0;
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.constructor()');
        }
    }
    path() {
        if (!this.currentUrlTree) {
            return '/';
        }
        const state = this.currentOutlet && this.currentOutlet.peekState();
        if (!state) {
            return '/';
        }
        let tree = this.currentUrlTree;
        let changedOutlet = this.getSegmentGroupByOutlet(this.currentOutlet);
        // Handle case where the user declares a component at path "/".
        // The url serializer doesn't parse this url as having a primary outlet.
        if (state.isRootSegmentGroup) {
            tree.root = state.segmentGroup;
        }
        else if (changedOutlet) {
            this.updateSegmentGroup(tree.root, changedOutlet, state.segmentGroup);
        }
        const urlSerializer = new DefaultUrlSerializer();
        tree.queryParams = state.queryParams;
        const url = urlSerializer.serialize(tree);
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.path(): ' + url);
        }
        return url;
    }
    prepareExternalUrl(internal) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.prepareExternalUrl() internal: ' + internal);
        }
        return internal;
    }
    pushState(state, title, url, queryParams) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.pushState state: ' + `${state}, title: ${title}, url: ${url}, queryParams: ${queryParams}`);
        }
        this.pushStateInternal(state, title, url, queryParams);
    }
    pushStateInternal(state, title, url, queryParams) {
        const urlSerializer = new DefaultUrlSerializer();
        this.currentUrlTree = urlSerializer.parse(url);
        const urlTreeRoot = this.currentUrlTree.root;
        // Handle case where the user declares a component at path "/".
        // The url serializer doesn't parse this url as having a primary outlet.
        if (!Object.keys(urlTreeRoot.children).length) {
            const segmentGroup = this.currentUrlTree && this.currentUrlTree.root;
            const outletKey = this.getOutletKey(this.getSegmentGroupFullPath(segmentGroup), 'primary');
            const outlet = this.findOutlet(outletKey);
            if (outlet && this.updateStates(outlet, segmentGroup, this.currentUrlTree.queryParams)) {
                this.currentOutlet = outlet; // If states updated
            }
            else if (!outlet) {
                // tslint:disable-next-line:max-line-length
                const rootOutlet = this.createOutlet('primary', null, segmentGroup, null, null, this.currentUrlTree.queryParams);
                this.currentOutlet = rootOutlet;
            }
            this.currentOutlet.peekState().isRootSegmentGroup = true;
            return;
        }
        const queue = [];
        let currentTree = urlTreeRoot;
        while (currentTree) {
            Object.keys(currentTree.children).forEach((outletName) => {
                const currentSegmentGroup = currentTree.children[outletName];
                currentSegmentGroup.outlet = outletName;
                currentSegmentGroup.root = urlTreeRoot;
                const outletPath = this.getSegmentGroupFullPath(currentTree);
                let outletKey = this.getOutletKey(outletPath, outletName);
                let outlet = this.findOutlet(outletKey);
                const parentOutletName = currentTree.outlet || '';
                const parentOutletPath = this.getSegmentGroupFullPath(currentTree.parent);
                const parentOutletKey = this.getOutletKey(parentOutletPath, parentOutletName);
                const parentOutlet = this.findOutlet(parentOutletKey);
                const containsLastState = outlet && outlet.containsTopState(currentSegmentGroup.toString());
                if (!outlet) {
                    // tslint:disable-next-line:max-line-length
                    outlet = this.createOutlet(outletKey, outletPath, currentSegmentGroup, parentOutlet, this._modalNavigationDepth, this.currentUrlTree.queryParams);
                    this.currentOutlet = outlet;
                }
                else if (this._modalNavigationDepth > 0 && outlet.showingModal && !containsLastState) {
                    // Navigation inside modal view.
                    this.upsertModalOutlet(outlet, currentSegmentGroup, this.currentUrlTree.queryParams);
                }
                else {
                    outlet.parent = parentOutlet;
                    if (this.updateStates(outlet, currentSegmentGroup, this.currentUrlTree.queryParams)) {
                        this.currentOutlet = outlet; // If states updated
                    }
                }
                queue.push(currentSegmentGroup);
            });
            currentTree = queue.shift();
        }
    }
    replaceState(state, title, url, queryParams) {
        const states = this.currentOutlet && this.currentOutlet.states;
        if (states && states.length > 0) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy.replaceState changing existing state: ' + `${state}, title: ${title}, url: ${url}, queryParams: ${queryParams}`);
            }
        }
        else {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy.replaceState pushing new state: ' + `${state}, title: ${title}, url: ${url}, queryParams: ${queryParams}`);
            }
            this.pushStateInternal(state, title, url, queryParams);
        }
    }
    forward() {
        throw new Error('NSLocationStrategy.forward() - not implemented');
    }
    back(outlet, frame) {
        this.currentOutlet = outlet || this.currentOutlet;
        if (this.currentOutlet.isPageNavigationBack) {
            const states = this.currentOutlet.states;
            // We are navigating to the previous page
            // clear the stack until we get to a page navigation state
            let state = states.pop();
            let count = 1;
            if (frame) {
                while (state.frame && state.frame !== frame) {
                    state = states.pop();
                    count++;
                }
            }
            while (!state.isPageNavigation) {
                state = states.pop();
                count++;
            }
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog(`NSLocationStrategy.back() while navigating back. States popped: ${count}`);
            }
            this.callPopState(state, true);
        }
        else {
            let state = this.currentOutlet.peekState();
            if (state && state.isPageNavigation) {
                // This was a page navigation - so navigate through frame.
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerLog('NSLocationStrategy.back() while not navigating back but top' + ' state is page - will call frame.goBack()');
                }
                if (!outlet) {
                    const topmostFrame = this.frameService.getFrame();
                    this.currentOutlet = this.getOutletByFrame(topmostFrame) || this.currentOutlet;
                }
                const frameToBack = this.currentOutlet.getFrameToBack();
                if (frameToBack) {
                    frameToBack.goBack();
                }
            }
            else {
                // Nested navigation - just pop the state
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerLog('NSLocationStrategy.back() while not navigating back but top' + ' state is not page - just pop');
                }
                this.callPopState(this.currentOutlet.states.pop(), true);
            }
        }
    }
    canGoBack(outlet) {
        outlet = outlet || this.currentOutlet;
        return outlet.states.length > 1;
    }
    onPopState(fn) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.onPopState');
        }
        this.popStateCallbacks.push(fn);
    }
    getBaseHref() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.getBaseHref()');
        }
        return '';
    }
    callPopState(state, pop = true, outlet) {
        outlet = outlet || this.currentOutlet;
        const urlSerializer = new DefaultUrlSerializer();
        let changedOutlet = this.getSegmentGroupByOutlet(outlet);
        if (state && changedOutlet) {
            this.updateSegmentGroup(this.currentUrlTree.root, changedOutlet, state.segmentGroup);
        }
        else if (changedOutlet) {
            // when closing modal view there are scenarios (e.g. root viewContainerRef) when we need
            // to clean up the named page router outlet to make sure we will open the modal properly again if needed.
            this.updateSegmentGroup(this.currentUrlTree.root, changedOutlet, null);
        }
        const url = urlSerializer.serialize(this.currentUrlTree);
        const change = { url: url, pop: pop };
        for (let fn of this.popStateCallbacks) {
            fn(change);
        }
    }
    toString() {
        let result = [];
        this.outlets.forEach((outlet) => {
            const outletStates = outlet.states;
            const outletLog = outletStates
                // tslint:disable-next-line:max-line-length
                .map((v, i) => `${outlet.outletKeys}.${i}.[${v.isPageNavigation ? 'PAGE' : 'INTERNAL'}].[${outlet.modalNavigationDepth ? 'MODAL' : 'BASE'}] "${v.segmentGroup.toString()}"`)
                .reverse();
            result = result.concat(outletLog);
        });
        return result.join('\n');
    }
    // Methods for syncing with page navigation in PageRouterOutlet
    _beginBackPageNavigation(frame) {
        const outlet = this.getOutletByFrame(frame);
        if (!outlet || outlet.isPageNavigationBack) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerError('Attempted to call startGoBack while going back.');
            }
            return;
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.startGoBack()');
        }
        outlet.isPageNavigationBack = true;
        this.currentOutlet = outlet;
    }
    _finishBackPageNavigation(frame) {
        const outlet = this.getOutletByFrame(frame);
        if (!outlet || !outlet.isPageNavigationBack) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerError('Attempted to call endGoBack while not going back.');
            }
            return;
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.finishBackPageNavigation()');
        }
        outlet.isPageNavigationBack = false;
    }
    _beginModalNavigation(frame) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy._beginModalNavigation()');
        }
        this.currentOutlet = this.getOutletByFrame(frame) || this.currentOutlet;
        // It is possible to have frame, but not corresponding Outlet, if
        // showing modal dialog on app.component.ts ngOnInit() e.g. In that case
        // the modal is treated as none modal navigation.
        if (this.currentOutlet) {
            this.currentOutlet.showingModal = true;
            this._modalNavigationDepth++;
        }
    }
    _closeModalNavigation() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.closeModalNavigation()');
        }
        const isShowingModal = this._modalNavigationDepth > 0;
        if (isShowingModal) {
            this._modalNavigationDepth--;
        }
        // currentOutlet should be the one that corresponds to the topmost frame
        const topmostOutlet = this.getOutletByFrame(this.frameService.getFrame());
        const outlet = this.findOutletByModal(this._modalNavigationDepth, isShowingModal) || topmostOutlet;
        if (outlet) {
            this.currentOutlet = outlet;
            this.currentOutlet.showingModal = false;
            this.callPopState(this.currentOutlet.peekState(), false);
        }
    }
    _beginPageNavigation(frame) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy._beginPageNavigation()');
        }
        this.currentOutlet = this.getOutletByFrame(frame);
        const lastState = this.currentOutlet.peekState();
        if (lastState) {
            lastState.isPageNavigation = true;
        }
        const navOptions = this._currentNavigationOptions || defaultNavOptions;
        if (navOptions.clearHistory) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy._beginPageNavigation clearing states history');
            }
            this.currentOutlet.states = [lastState];
        }
        this._currentNavigationOptions = undefined;
        return navOptions;
    }
    _setNavigationOptions(options) {
        this._currentNavigationOptions = {
            clearHistory: isPresent(options.clearHistory) ? options.clearHistory : false,
            animated: isPresent(options.animated) ? options.animated : true,
            transition: options.transition,
        };
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy._setNavigationOptions(' + `${JSON.stringify(this._currentNavigationOptions)})`);
        }
    }
    _getOutlets() {
        return this.outlets;
    }
    updateOutletFrame(outlet, frame, isEmptyOutletFrame) {
        const lastState = outlet.peekState();
        if (lastState && !lastState.frame && !isEmptyOutletFrame) {
            lastState.frame = frame;
        }
        if (!outlet.containsFrame(frame)) {
            outlet.frames.push(frame);
        }
        this.currentOutlet = outlet;
    }
    clearOutlet(frame) {
        this.outlets = this.outlets.filter((currentOutlet) => {
            let isEqualToCurrent;
            if (this.currentOutlet) {
                isEqualToCurrent = currentOutlet.pathByOutlets === this.currentOutlet.pathByOutlets;
            }
            // Remove outlet from the url tree.
            if (currentOutlet.containsFrame(frame) && !isEqualToCurrent) {
                this.callPopState(null, true, currentOutlet);
            }
            // Skip frames filtering since currentOutlet is <router-outlet> when no frames available.
            if (currentOutlet.frames.length && !currentOutlet.isNSEmptyOutlet) {
                currentOutlet.frames = currentOutlet.frames.filter((currentFrame) => currentFrame !== frame);
                return currentOutlet.frames.length;
            }
            return !currentOutlet.containsFrame(frame);
        });
    }
    getSegmentGroupFullPath(segmentGroup) {
        let fullPath = '';
        while (segmentGroup) {
            const url = segmentGroup.toString();
            if (fullPath) {
                fullPath = (url ? url + '/' : '') + fullPath;
            }
            else {
                fullPath = url;
            }
            segmentGroup = segmentGroup.parent;
        }
        return fullPath;
    }
    getRouteFullPath(currentRoute) {
        const outletName = currentRoute.outlet;
        let fullPath;
        currentRoute = currentRoute.parent;
        while (currentRoute) {
            const urls = currentRoute.url.value || currentRoute.url;
            let url = urls;
            if (Array.isArray(urls)) {
                url = url.join('/');
            }
            fullPath = fullPath ? (url ? url + '/' : url) + fullPath : url;
            currentRoute = currentRoute.parent;
        }
        return fullPath ? fullPath + '-' + outletName : outletName;
    }
    getPathByOutlets(urlSegmentGroup) {
        if (!urlSegmentGroup) {
            return '';
        }
        let pathToOutlet;
        let lastPath = urlSegmentGroup.outlet || 'primary';
        let parent = urlSegmentGroup.parent;
        while (parent && urlSegmentGroup.root !== parent) {
            if (parent && parent.outlet !== lastPath) {
                if (lastPath === 'primary') {
                    lastPath = parent.outlet;
                }
                else {
                    lastPath = parent.outlet;
                    pathToOutlet = lastPath + '-' + (pathToOutlet || urlSegmentGroup.outlet);
                }
            }
            parent = parent.parent;
        }
        return pathToOutlet || lastPath;
    }
    findOutlet(outletKey, activatedRouteSnapshot) {
        let outlet = this.outlets.find((currentOutlet) => {
            let equalModalDepth = currentOutlet.modalNavigationDepth === this._modalNavigationDepth;
            return equalModalDepth && currentOutlet.outletKeys.indexOf(outletKey) > -1;
        });
        // No Outlet with the given outletKey could happen when using nested unnamed p-r-o
        // primary -> primary -> prymary
        if (!outlet && activatedRouteSnapshot) {
            const pathByOutlets = this.getPathByOutlets(activatedRouteSnapshot);
            outlet = this.outlets.find((currentOutlet) => {
                let equalModalDepth = currentOutlet.modalNavigationDepth === this._modalNavigationDepth;
                return equalModalDepth && currentOutlet.pathByOutlets === pathByOutlets;
            });
        }
        return outlet;
    }
    findOutletByModal(modalNavigation, isShowingModal) {
        return this.outlets.find((outlet) => {
            let equalModalDepth = outlet.modalNavigationDepth === modalNavigation;
            return isShowingModal ? equalModalDepth && outlet.showingModal : equalModalDepth;
        });
    }
    getOutletByFrame(frame) {
        let outlet;
        for (let index = 0; index < this.outlets.length; index++) {
            const currentOutlet = this.outlets[index];
            if (currentOutlet.containsFrame(frame)) {
                outlet = currentOutlet;
                break;
            }
        }
        return outlet;
    }
    updateStates(outlet, currentSegmentGroup, queryParams) {
        const isNewPage = outlet.states.length === 0;
        const lastState = outlet.states[outlet.states.length - 1];
        const equalStateUrls = outlet.containsTopState(currentSegmentGroup.toString());
        const locationState = {
            segmentGroup: currentSegmentGroup,
            isRootSegmentGroup: false,
            isPageNavigation: isNewPage,
            queryParams: Object.assign({}, queryParams),
        };
        if (!lastState || !equalStateUrls) {
            outlet.states.push(locationState);
            // Update last state segmentGroup of parent Outlet.
            if (this._modalNavigationDepth === 0 && !outlet.showingModal) {
                this.updateParentsStates(outlet, currentSegmentGroup.parent);
            }
            return true;
        }
        return false;
    }
    updateParentsStates(outlet, newSegmentGroup) {
        let parentOutlet = outlet.parent;
        // Update parents lastState segmentGroups
        while (parentOutlet && newSegmentGroup) {
            const state = parentOutlet.peekState();
            if (state) {
                state.segmentGroup = newSegmentGroup;
                newSegmentGroup = newSegmentGroup.parent;
                parentOutlet = parentOutlet.parent;
            }
        }
    }
    // tslint:disable-next-line:max-line-length
    createOutlet(outletKey, path, segmentGroup, parent, modalNavigation, queryParams = {}) {
        const pathByOutlets = this.getPathByOutlets(segmentGroup);
        const newOutlet = new Outlet(outletKey, path, pathByOutlets, modalNavigation);
        const locationState = {
            segmentGroup: segmentGroup,
            isRootSegmentGroup: false,
            isPageNavigation: true,
            queryParams: Object.assign({}, queryParams),
        };
        newOutlet.states = [locationState];
        newOutlet.parent = parent;
        this.outlets.push(newOutlet);
        // Update last state segmentGroup of parent Outlet.
        if (this._modalNavigationDepth === 0 && !newOutlet.showingModal) {
            this.updateParentsStates(newOutlet, segmentGroup.parent);
        }
        return newOutlet;
    }
    getSegmentGroupByOutlet(outlet) {
        const pathList = outlet.pathByOutlets.split('-');
        let segmentGroup = this.currentUrlTree.root;
        let pathToOutlet;
        for (let index = 0; index < pathList.length; index++) {
            const currentPath = pathList[index];
            const childrenCount = Object.keys(segmentGroup.children).length;
            if (childrenCount && segmentGroup.children[currentPath]) {
                const url = segmentGroup.toString();
                pathToOutlet = pathToOutlet ? pathToOutlet + '/' + url : url;
                segmentGroup = segmentGroup.children[currentPath];
            }
            else {
                // If no child outlet found with the given name - forget about all previously found outlets.
                // example: seaching for 'primary-second-primary' shouldn't return 'primary-second'
                // if no 'primary' child available on 'second'.
                segmentGroup = null;
                break;
            }
        }
        // Paths should also match since there could be another Outlet
        // with the same pathByOutlets but different url path.
        if (segmentGroup && outlet.path && pathToOutlet && outlet.path !== pathToOutlet) {
            segmentGroup = null;
        }
        return segmentGroup;
    }
    // Traversal and replacement of segmentGroup.
    updateSegmentGroup(rootNode, oldSegmentGroup, newSegmentGroup) {
        const queue = [];
        let currentTree = rootNode;
        while (currentTree) {
            Object.keys(currentTree.children).forEach((outletName) => {
                if (currentTree.children[outletName] === oldSegmentGroup) {
                    if (newSegmentGroup) {
                        currentTree.children[outletName] = newSegmentGroup;
                    }
                    else {
                        delete currentTree.children[outletName];
                    }
                }
                queue.push(currentTree.children[outletName]);
            });
            currentTree = queue.shift();
        }
    }
    upsertModalOutlet(parentOutlet, segmentedGroup, queryParams) {
        let currentModalOutlet = this.findOutletByModal(this._modalNavigationDepth);
        // We want to treat every p-r-o as a standalone Outlet.
        if (!currentModalOutlet) {
            if (this._modalNavigationDepth > 1) {
                // The parent of the current Outlet should be the previous opened modal (if any).
                parentOutlet = this.findOutletByModal(this._modalNavigationDepth - 1);
            }
            // No currentModalOutlet available when opening 'primary' p-r-o.
            const outletName = 'primary';
            const outletPath = parentOutlet.peekState().segmentGroup.toString();
            const outletKey = this.getOutletKey(outletPath, outletName);
            // tslint:disable-next-line:max-line-length
            currentModalOutlet = this.createOutlet(outletKey, outletPath, segmentedGroup, parentOutlet, this._modalNavigationDepth, queryParams);
            this.currentOutlet = currentModalOutlet;
        }
        else if (this.updateStates(currentModalOutlet, segmentedGroup, queryParams)) {
            this.currentOutlet = currentModalOutlet; // If states updated
        }
    }
    getOutletKey(path, outletName) {
        return path ? path + '-' + outletName : outletName;
    }
    ngOnDestroy() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NSLocationStrategy.ngOnDestroy()');
        }
        this.outlets = [];
        this.currentOutlet = null;
    }
}
NSLocationStrategy.ɵprov = ɵɵdefineInjectable({ factory: function NSLocationStrategy_Factory() { return new NSLocationStrategy(ɵɵinject(FrameService)); }, token: NSLocationStrategy, providedIn: "root" });
NSLocationStrategy.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
NSLocationStrategy.ctorParameters = () => [
    { type: FrameService }
];

/**
 * Wrapper component used for loading components when navigating
 * It uses DetachedContainer as selector so that it is containerRef is not attached to
 * the visual tree.
 */
class DetachedLoader {
    // tslint:disable-line:component-class-suffix
    constructor(resolver, changeDetector, containerRef) {
        this.resolver = resolver;
        this.changeDetector = changeDetector;
        this.containerRef = containerRef;
    }
    loadInLocation(componentType) {
        const factory = this.resolver.resolveComponentFactory(componentType);
        const componentRef = this.containerRef.createComponent(factory, this.containerRef.length, this.containerRef.injector);
        // Component is created, built may not be checked if we are loading
        // inside component with OnPush CD strategy. Mark us for check to be sure CD will reach us.
        // We are inside a promise here so no need for setTimeout - CD should trigger
        // after the promise.
        Trace.write('DetachedLoader.loadInLocation component loaded -> markForCheck', 'detached-loader');
        return Promise.resolve(componentRef);
    }
    detectChanges() {
        this.changeDetector.markForCheck();
    }
    // TODO: change this API -- async promises not needed here anymore.
    loadComponent(componentType) {
        Trace.write('DetachedLoader.loadComponent', 'detached-loader');
        return this.loadInLocation(componentType);
    }
    loadWithFactory(factory) {
        return this.containerRef.createComponent(factory, this.containerRef.length, this.containerRef.injector, null);
    }
}
DetachedLoader.decorators = [
    { type: Component, args: [{
                selector: 'DetachedContainer',
                template: `<Placeholder #loader></Placeholder>`
            },] }
];
DetachedLoader.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef },
    { type: ViewContainerRef }
];

/**
 * Utility method to ensure a NgModule is only imported once in a codebase, otherwise will throw to help prevent accidental double importing
 * @param parentModule Parent module name
 * @param moduleName The module name
 */
function throwIfAlreadyLoaded(parentModule, moduleName) {
    if (parentModule) {
        throw new Error(`${moduleName} has already been loaded. Import ${moduleName} in the AppModule only.`);
    }
}
/**
 * Utility method which will only fire the callback once ever
 * @param fn callback to call only once
 */
function once(fn) {
    let wasCalled = false;
    return function wrapper() {
        if (wasCalled) {
            return;
        }
        wasCalled = true;
        fn.apply(null, arguments);
    };
}

class ModalDialogParams {
    constructor(context = {}, closeCallback) {
        this.context = context;
        this.closeCallback = closeCallback;
    }
}
class ModalDialogService {
    constructor(location) {
        this.location = location;
    }
    showModal(type, options) {
        if (!options.viewContainerRef) {
            throw new Error('No viewContainerRef: ' + 'Make sure you pass viewContainerRef in ModalDialogOptions.');
        }
        let parentView = options.viewContainerRef.element.nativeElement;
        if (options.target) {
            parentView = options.target;
        }
        if ((parentView instanceof AppHostView || parentView instanceof AppHostAsyncView) && parentView.ngAppRoot) {
            parentView = parentView.ngAppRoot;
        }
        // _ngDialogRoot is the first child of the previously detached proxy.
        // It should have 'viewController' (iOS) or '_dialogFragment' (Android) available for
        // presenting future modal views.
        if (parentView._ngDialogRoot) {
            parentView = parentView._ngDialogRoot;
        }
        const pageFactory = options.viewContainerRef.injector.get(PAGE_FACTORY);
        // resolve from particular module (moduleRef)
        // or from same module as parentView (viewContainerRef)
        const componentContainer = options.moduleRef || options.viewContainerRef;
        const resolver = componentContainer.injector.get(ComponentFactoryResolver);
        let frame = parentView;
        if (!(parentView instanceof Frame)) {
            frame = (parentView.page && parentView.page.frame) || Frame.topmost();
        }
        this.location._beginModalNavigation(frame);
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                try {
                    this._showDialog(Object.assign(Object.assign({}, options), { containerRef: options.viewContainerRef, context: options.context, doneCallback: resolve, pageFactory,
                        parentView,
                        resolver,
                        type }));
                }
                catch (err) {
                    reject(err);
                }
            }, 10);
        });
    }
    _showDialog(options) {
        let componentView;
        let detachedLoaderRef;
        const closeCallback = once((...args) => {
            options.doneCallback.apply(undefined, args);
            if (componentView) {
                componentView.closeModal();
                this.location._closeModalNavigation();
                detachedLoaderRef.instance.detectChanges();
                detachedLoaderRef.destroy();
            }
        });
        const modalParams = new ModalDialogParams(options.context, closeCallback);
        const childInjector = Injector.create({
            providers: [{ provide: ModalDialogParams, useValue: modalParams }],
            parent: options.containerRef.injector,
        });
        const detachedFactory = options.resolver.resolveComponentFactory(DetachedLoader);
        detachedLoaderRef = options.containerRef.createComponent(detachedFactory, 0, childInjector, null);
        detachedLoaderRef.instance.loadComponent(options.type).then((compRef) => {
            const detachedProxy = compRef.location.nativeElement;
            if (detachedProxy.getChildrenCount() > 1) {
                throw new Error('Modal content has more than one root view.');
            }
            componentView = detachedProxy.getChildAt(0);
            if (componentView.parent) {
                componentView.parent._ngDialogRoot = componentView;
                componentView.parent.removeChild(componentView);
            }
            options.parentView.showModal(componentView, Object.assign(Object.assign({}, options), { closeCallback }));
        });
    }
}
ModalDialogService.decorators = [
    { type: Injectable }
];
ModalDialogService.ctorParameters = () => [
    { type: NSLocationStrategy }
];

class InvisibleNode extends View {
    constructor() {
        super();
        this.nodeType = 1;
        this.nodeName = getClassName(this);
    }
    toString() {
        return `${this.nodeName}(${this.id})`;
    }
}
class CommentNode extends InvisibleNode {
    constructor() {
        super();
        this.meta = {
            skipAddToDom: true,
        };
        this.id = CommentNode.id.toString();
        CommentNode.id += 1;
    }
}
CommentNode.id = 0;
class TextNode extends InvisibleNode {
    constructor() {
        super();
        this.meta = {
            skipAddToDom: true,
        };
        this.id = TextNode.id.toString();
        TextNode.id += 1;
    }
}
TextNode.id = 0;
const getClassName = (instance) => instance.constructor.name;
const ɵ0 = getClassName;
function isDetachedElement(element) {
    return element && element.meta && element.meta.skipAddToDom;
}
function isView(view) {
    return view instanceof View;
}
function isInvisibleNode(view) {
    return view instanceof InvisibleNode;
}
const elementMap = new Map();
const camelCaseSplit = /([a-z0-9])([A-Z])/g;
const defaultViewMeta = { skipAddToDom: false };
function registerElement(elementName, resolver, meta) {
    const entry = { resolver, meta };
    elementMap.set(elementName, entry);
    elementMap.set(elementName.toLowerCase(), entry);
    elementMap.set(elementName.replace(camelCaseSplit, '$1-$2').toLowerCase(), entry);
}
function getViewClass(elementName) {
    const entry = elementMap.get(elementName) || elementMap.get(elementName.toLowerCase());
    if (!entry) {
        throw new TypeError(`No known component for element ${elementName}.`);
    }
    try {
        return entry.resolver();
    }
    catch (e) {
        throw new TypeError(`Could not load view for: ${elementName}.${e}`);
    }
}
function getViewMeta(nodeName) {
    const entry = elementMap.get(nodeName) || elementMap.get(nodeName.toLowerCase());
    return (entry && entry.meta) || defaultViewMeta;
}
function isKnownView(elementName) {
    return elementMap.has(elementName) || elementMap.has(elementName.toLowerCase());
}
function getSingleViewRecursive(nodes, nestLevel) {
    const actualNodes = nodes.filter((node) => !(node instanceof InvisibleNode));
    if (actualNodes.length === 0) {
        throw new Error(`No suitable views found in list template! ` + `Nesting level: ${nestLevel}`);
    }
    else if (actualNodes.length > 1) {
        throw new Error(`More than one view found in list template!` + `Nesting level: ${nestLevel}`);
    }
    const rootLayout = actualNodes[0];
    if (!rootLayout) {
        return getSingleViewRecursive(rootLayout.children, nestLevel + 1);
    }
    const parentLayout = rootLayout.parent;
    if (parentLayout instanceof LayoutBase) {
        let node = rootLayout.parentNode;
        parentLayout.removeChild(rootLayout);
        rootLayout.parentNode = node;
    }
    return rootLayout;
}
const ɵ1 = (parent, child, next) => {
    // Page cannot be added to Frame with _addChildFromBuilder (thwos "use defaultPage" error)
    if (isInvisibleNode(child)) {
        return;
    }
    else if (child instanceof Page) {
        parent.navigate({ create: () => child });
    }
    else {
        throw new Error('Only a Page can be a child of Frame');
    }
};
const frameMeta = {
    insertChild: ɵ1,
};
// Register default NativeScript components
// Note: ActionBar related components are registerd together with action-bar directives.
registerElement('AbsoluteLayout', () => AbsoluteLayout);
registerElement('ActivityIndicator', () => ActivityIndicator);
registerElement('BottomNavigation', () => BottomNavigation);
registerElement('Button', () => Button);
registerElement('ContentView', () => ContentView);
registerElement('DatePicker', () => DatePicker);
registerElement('DockLayout', () => DockLayout);
registerElement('Frame', () => Frame, frameMeta);
registerElement('GridLayout', () => GridLayout);
registerElement('HtmlView', () => HtmlView);
registerElement('Image', () => Image);
// Parse5 changes <Image> tags to <img>. WTF!
registerElement('img', () => Image);
registerElement('Label', () => Label);
registerElement('ListPicker', () => ListPicker);
registerElement('ListView', () => ListView);
registerElement('Page', () => Page);
registerElement('Placeholder', () => Placeholder);
registerElement('Progress', () => Progress);
registerElement('ProxyViewContainer', () => ProxyViewContainer);
registerElement('Repeater', () => Repeater);
registerElement('ScrollView', () => ScrollView);
registerElement('SearchBar', () => SearchBar);
registerElement('SegmentedBar', () => SegmentedBar);
registerElement('SegmentedBarItem', () => SegmentedBarItem);
registerElement('Slider', () => Slider);
registerElement('StackLayout', () => StackLayout);
registerElement('FlexboxLayout', () => FlexboxLayout);
registerElement('Switch', () => Switch);
registerElement('TabView', () => TabView);
registerElement('TabStrip', () => TabStrip);
registerElement('TabStripItem', () => TabStripItem);
registerElement('TabContentItem', () => TabContentItem);
registerElement('Tabs', () => Tabs);
registerElement('TextField', () => TextField);
registerElement('TextView', () => TextView);
registerElement('TimePicker', () => TimePicker);
registerElement('WebView', () => WebView);
registerElement('WrapLayout', () => WrapLayout);
registerElement('FormattedString', () => FormattedString);
registerElement('Span', () => Span);
registerElement('DetachedContainer', () => ProxyViewContainer, {
    skipAddToDom: true,
});
registerElement('page-router-outlet', () => Frame);

const NG_VIEW = '_ngViewRef';
class ItemContext {
    constructor($implicit, item, index, even, odd) {
        this.$implicit = $implicit;
        this.item = item;
        this.index = index;
        this.even = even;
        this.odd = odd;
    }
}
class TemplatedItemsComponent {
    constructor(_elementRef, _iterableDiffers) {
        this._iterableDiffers = _iterableDiffers;
        this.setupItemView = new EventEmitter();
        this.templatedItemsView = _elementRef.nativeElement;
        this.templatedItemsView.on('itemLoading', this.onItemLoading, this);
    }
    get items() {
        return this._items;
    }
    set items(value) {
        this._items = value;
        let needDiffer = true;
        if (value instanceof ObservableArray) {
            needDiffer = false;
        }
        if (needDiffer && !this._differ && ɵisListLikeIterable(value)) {
            this._differ = this._iterableDiffers.find(this._items).create((_index, item) => {
                return item;
            });
        }
        this.templatedItemsView.items = this._items;
    }
    ngAfterContentInit() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.listViewLog('TemplatedItemsView.ngAfterContentInit()');
        }
        this.setItemTemplates();
    }
    ngOnDestroy() {
        this.templatedItemsView.off('itemLoading', this.onItemLoading, this);
        this.templatedItemsView = null;
        if (this._templateMap) {
            this._templateMap.clear();
        }
    }
    setItemTemplates() {
        // The itemTemplateQuery may be changed after list items are added that contain <template> inside,
        // so cache and use only the original template to avoid errors.
        this.itemTemplate = this.itemTemplateQuery;
        if (this._templateMap) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog('Setting templates');
            }
            const templates = [];
            this._templateMap.forEach((value) => {
                templates.push(value);
            });
            this.templatedItemsView.itemTemplates = templates;
        }
    }
    registerTemplate(key, template) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.listViewLog(`registerTemplate for key: ${key}`);
        }
        if (!this._templateMap) {
            this._templateMap = new Map();
        }
        const keyedTemplate = {
            key,
            createView: this.getItemTemplateViewFactory(template),
        };
        this._templateMap.set(key, keyedTemplate);
    }
    onItemLoading(args) {
        if (!args.view && !this.itemTemplate) {
            return;
        }
        const index = args.index;
        const items = args.object.items;
        const currentItem = typeof items.getItem === 'function' ? items.getItem(index) : items[index];
        let viewRef;
        if (args.view) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog(`onItemLoading: ${index} - Reusing existing view`);
            }
            viewRef = args.view[NG_VIEW];
            // Getting angular view from original element (in cases when ProxyViewContainer
            // is used NativeScript internally wraps it in a StackLayout)
            if (!viewRef && args.view instanceof LayoutBase && args.view.getChildrenCount() > 0) {
                viewRef = args.view.getChildAt(0)[NG_VIEW];
            }
            if (!viewRef && NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewError(`ViewReference not found for item ${index}. View recycling is not working`);
            }
            // No ng-template is setup, continue with 'defaultTemplate'
            if (!viewRef) {
                return;
            }
        }
        if (!viewRef) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog(`onItemLoading: ${index} - Creating view from template`);
            }
            viewRef = this.loader.createEmbeddedView(this.itemTemplate, new ItemContext(), 0);
            args.view = getItemViewRoot(viewRef);
            args.view[NG_VIEW] = viewRef;
        }
        this.setupViewRef(viewRef, currentItem, index);
        this.detectChangesOnChild(viewRef, index);
    }
    setupViewRef(viewRef, data, index) {
        const context = viewRef.context;
        context.$implicit = data;
        context.item = data;
        context.index = index;
        context.even = index % 2 === 0;
        context.odd = !context.even;
        this.setupItemView.next({ view: viewRef, data: data, index: index, context: context });
    }
    getItemTemplateViewFactory(template) {
        return () => {
            const viewRef = this.loader.createEmbeddedView(template, new ItemContext(), 0);
            const resultView = getItemViewRoot(viewRef);
            resultView[NG_VIEW] = viewRef;
            return resultView;
        };
    }
    detectChangesOnChild(viewRef, index) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.listViewLog(`Manually detect changes in child: ${index}`);
        }
        viewRef.markForCheck();
        viewRef.detectChanges();
    }
    ngDoCheck() {
        if (this._differ) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog('ngDoCheck() - execute differ');
            }
            const changes = this._differ.diff(this._items);
            if (changes) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.listViewLog('ngDoCheck() - refresh');
                }
                this.templatedItemsView.refresh();
            }
        }
    }
}
TemplatedItemsComponent.decorators = [
    { type: Directive }
];
TemplatedItemsComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IterableDiffers }
];
TemplatedItemsComponent.propDecorators = {
    loader: [{ type: ViewChild, args: ['loader', { read: ViewContainerRef, static: false },] }],
    setupItemView: [{ type: Output }],
    itemTemplateQuery: [{ type: ContentChild, args: [TemplateRef, { read: TemplateRef, static: false },] }],
    items: [{ type: Input }]
};
__decorate([
    profile
], TemplatedItemsComponent.prototype, "onItemLoading", null);
__decorate([
    profile
], TemplatedItemsComponent.prototype, "detectChangesOnChild", null);
function getItemViewRoot(viewRef, rootLocator = getSingleViewRecursive) {
    const rootView = rootLocator(viewRef.rootNodes, 0);
    return rootView;
}
const TEMPLATED_ITEMS_COMPONENT = new InjectionToken('TemplatedItemsComponent');
class TemplateKeyDirective {
    constructor(templateRef, comp) {
        this.templateRef = templateRef;
        this.comp = comp;
    }
    set nsTemplateKey(value) {
        if (this.comp && this.templateRef) {
            this.comp.registerTemplate(value, this.templateRef);
        }
    }
}
TemplateKeyDirective.decorators = [
    { type: Directive, args: [{ selector: '[nsTemplateKey]' },] }
];
TemplateKeyDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: TemplatedItemsComponent, decorators: [{ type: Inject, args: [TEMPLATED_ITEMS_COMPONENT,] }, { type: Host }] }
];
TemplateKeyDirective.propDecorators = {
    nsTemplateKey: [{ type: Input }]
};

class ListViewComponent extends TemplatedItemsComponent {
    constructor(_elementRef, _iterableDiffers) {
        super(_elementRef, _iterableDiffers);
    }
    get nativeElement() {
        return this.templatedItemsView;
    }
}
ListViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'ListView',
                template: ` <DetachedContainer>
		<Placeholder #loader></Placeholder>
	</DetachedContainer>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: TEMPLATED_ITEMS_COMPONENT, useExisting: forwardRef(() => ListViewComponent) }]
            },] }
];
ListViewComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IterableDiffers }
];

class TabViewDirective {
    constructor(element) {
        this.tabView = element.nativeElement;
    }
    get selectedIndex() {
        return this._selectedIndex;
    }
    set selectedIndex(value) {
        this._selectedIndex = value;
        if (this.viewInitialized) {
            this.tabView.selectedIndex = this._selectedIndex;
        }
    }
    ngAfterViewInit() {
        this.viewInitialized = true;
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog('this._selectedIndex: ' + this._selectedIndex);
        }
        if (!isBlank(this._selectedIndex)) {
            this.tabView.selectedIndex = this._selectedIndex;
        }
    }
}
TabViewDirective.decorators = [
    { type: Directive, args: [{
                selector: 'TabView',
            },] }
];
TabViewDirective.ctorParameters = () => [
    { type: ElementRef }
];
TabViewDirective.propDecorators = {
    selectedIndex: [{ type: Input }]
};
class TabViewItemDirective {
    constructor(owner, templateRef, viewContainer) {
        this.owner = owner;
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
    set config(config) {
        if (!this._config || this._config.iconSource !== config.iconSource || this._config.title !== config.title || this._config.textTransform !== config.textTransform) {
            this._config = config;
            this.applyConfig();
        }
    }
    get config() {
        // tslint:disable-line:no-input-rename
        return this._config || {};
    }
    set title(title) {
        this.config = Object.assign(this.config, { title });
    }
    get title() {
        return this.config.title;
    }
    set iconSource(iconSource) {
        this.config = Object.assign(this.config, { iconSource });
    }
    get iconSource() {
        return this.config.iconSource;
    }
    set textTransform(textTransform) {
        this.config = Object.assign(this.config, { textTransform });
    }
    get textTransform() {
        return this.config.textTransform;
    }
    ensureItem() {
        if (!this.item) {
            this.item = new TabViewItem();
        }
    }
    applyConfig() {
        this.ensureItem();
        if (this.config.title) {
            this.item.title = this.config.title;
        }
        if (this.config.iconSource) {
            this.item.iconSource = this.config.iconSource;
        }
        //  TabViewItem textTransform has a default value for Android that kick in
        // only if no value (even a null value) is set.
        if (this.config.textTransform) {
            this.item.textTransform = this.config.textTransform;
        }
    }
    ngOnInit() {
        this.applyConfig();
        const viewRef = this.viewContainer.createEmbeddedView(this.templateRef);
        // Filter out text nodes and comments
        const realViews = viewRef.rootNodes.filter((node) => !(node instanceof InvisibleNode));
        if (realViews.length > 0) {
            this.item.view = realViews[0];
            const newItems = (this.owner.tabView.items || []).concat([this.item]);
            this.owner.tabView.items = newItems;
        }
    }
}
TabViewItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[tabItem]',
            },] }
];
TabViewItemDirective.ctorParameters = () => [
    { type: TabViewDirective },
    { type: TemplateRef },
    { type: ViewContainerRef }
];
TabViewItemDirective.propDecorators = {
    config: [{ type: Input, args: ['tabItem',] }],
    title: [{ type: Input }],
    iconSource: [{ type: Input }],
    textTransform: [{ type: Input }]
};

function isActionItem(view) {
    return view instanceof ActionItem;
}
function isNavigationButton(view) {
    return view instanceof NavigationButton;
}
const ɵ0$1 = (parent, child, next) => {
    if (isInvisibleNode(child)) {
        return;
    }
    else if (isNavigationButton(child)) {
        parent.navigationButton = child;
        child.parentNode = parent;
    }
    else if (isActionItem(child)) {
        addActionItem(parent, child, next);
        child.parentNode = parent;
    }
    else if (isView(child)) {
        parent.titleView = child;
    }
}, ɵ1$1 = (parent, child) => {
    if (isInvisibleNode(child)) {
        return;
    }
    else if (isNavigationButton(child)) {
        if (parent.navigationButton === child) {
            parent.navigationButton = null;
        }
        child.parentNode = null;
    }
    else if (isActionItem(child)) {
        parent.actionItems.removeItem(child);
        child.parentNode = null;
    }
    else if (isView(child) && parent.titleView && parent.titleView === child) {
        parent.titleView = null;
    }
};
const actionBarMeta = {
    skipAddToDom: true,
    insertChild: ɵ0$1,
    removeChild: ɵ1$1,
};
const addActionItem = (bar, item, next) => {
    if (next) {
        insertActionItemBefore(bar, item, next);
    }
    else {
        appendActionItem(bar, item);
    }
};
const ɵ2 = addActionItem;
const insertActionItemBefore = (bar, item, next) => {
    const actionItems = bar.actionItems;
    const actionItemsCollection = actionItems.getItems();
    const indexToInsert = actionItemsCollection.indexOf(next);
    actionItemsCollection.splice(indexToInsert, 0, item);
    actionItems.setItems(actionItemsCollection);
};
const ɵ3 = insertActionItemBefore;
const appendActionItem = (bar, item) => {
    bar.actionItems.addItem(item);
};
const ɵ4 = appendActionItem;
registerElement('ActionBar', () => ActionBar, actionBarMeta);
registerElement('ActionItem', () => ActionItem);
registerElement('NavigationButton', () => NavigationButton);
class ActionBarComponent {
    constructor(element, page) {
        this.element = element;
        this.page = page;
        if (!this.page) {
            throw new Error('Inside ActionBarComponent but no Page found in DI.');
        }
        if (isBlank(this.page.actionBarHidden)) {
            this.page.actionBarHidden = false;
        }
        this.page.actionBar = this.element.nativeElement;
        this.page.actionBar.update();
    }
}
ActionBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'ActionBar',
                template: '<ng-content></ng-content>'
            },] }
];
ActionBarComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Page }
];
class ActionBarScope {
    // tslint:disable-line:component-class-suffix
    constructor(page) {
        this.page = page;
        if (!this.page) {
            throw new Error('Inside ActionBarScope but no Page found in DI.');
        }
    }
    onNavButtonInit(navBtn) {
        this.page.actionBar.navigationButton = navBtn.element.nativeElement;
    }
    onNavButtonDestroy(navBtn) {
        const nav = navBtn.element.nativeElement;
        if (nav && this.page.actionBar.navigationButton === nav) {
            this.page.actionBar.navigationButton = null;
        }
    }
    onActionInit(item) {
        this.page.actionBar.actionItems.addItem(item.element.nativeElement);
    }
    onActionDestroy(item) {
        if (item.element.nativeElement.actionBar) {
            this.page.actionBar.actionItems.removeItem(item.element.nativeElement);
        }
    }
}
ActionBarScope.decorators = [
    { type: Component, args: [{
                selector: 'ActionBarExtension',
                template: ''
            },] }
];
ActionBarScope.ctorParameters = () => [
    { type: Page }
];
class ActionItemDirective {
    constructor(element, ownerScope) {
        this.element = element;
        this.ownerScope = ownerScope;
        if (this.ownerScope) {
            this.ownerScope.onActionInit(this);
        }
    }
    ngOnDestroy() {
        if (this.ownerScope) {
            this.ownerScope.onActionDestroy(this);
        }
    }
}
ActionItemDirective.decorators = [
    { type: Directive, args: [{
                selector: 'ActionItem',
            },] }
];
ActionItemDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ActionBarScope, decorators: [{ type: Optional }] }
];
class NavigationButtonDirective {
    constructor(element, ownerScope) {
        this.element = element;
        this.ownerScope = ownerScope;
        if (this.ownerScope) {
            this.ownerScope.onNavButtonInit(this);
        }
    }
    ngOnDestroy() {
        if (this.ownerScope) {
            this.ownerScope.onNavButtonDestroy(this);
        }
    }
}
NavigationButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'NavigationButton',
            },] }
];
NavigationButtonDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ActionBarScope, decorators: [{ type: Optional }] }
];

class AndroidFilterComponent {
    constructor() {
        this.show = isAndroid;
    }
}
AndroidFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'android',
                template: `<ng-content *ngIf="show"></ng-content>`
            },] }
];
AndroidFilterComponent.ctorParameters = () => [];
class IosFilterComponent {
    constructor() {
        this.show = isIOS;
    }
}
IosFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'ios',
                template: `<ng-content *ngIf="show"></ng-content>`
            },] }
];
IosFilterComponent.ctorParameters = () => [];

const NS_DIRECTIVES = [ListViewComponent, TemplateKeyDirective, TabViewDirective, TabViewItemDirective, ActionBarComponent, ActionBarScope, ActionItemDirective, NavigationButtonDirective, AndroidFilterComponent, IosFilterComponent];

class NativeScriptCommonModule {
}
NativeScriptCommonModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ListViewComponent, TemplateKeyDirective, TabViewDirective, TabViewItemDirective, ActionBarComponent, ActionBarScope, ActionItemDirective, NavigationButtonDirective, AndroidFilterComponent, IosFilterComponent],
                providers: [ModalDialogService, defaultDeviceProvider, defaultFrameProvider, defaultPageProvider],
                imports: [CommonModule],
                exports: [CommonModule, ListViewComponent, TemplateKeyDirective, TabViewDirective, TabViewItemDirective, ActionBarComponent, ActionBarScope, ActionItemDirective, NavigationButtonDirective, AndroidFilterComponent, IosFilterComponent],
                schemas: [NO_ERRORS_SCHEMA],
            },] }
];

const ELEMENT_NODE_TYPE = 1;
const XML_ATTRIBUTES = Object.freeze(['style', 'rows', 'columns', 'fontAttributes']);
const whiteSpaceSplitter = /\s+/;
function isLayout(view) {
    return view instanceof LayoutBase;
}
function isContentView(view) {
    return view instanceof ContentView;
}
const propertyMaps = new Map();
class ViewUtil {
    constructor(device) {
        this.isIos = device.os === platformNames.ios;
        this.isAndroid = device.os === platformNames.android;
    }
    insertChild(parent, child, previous, next) {
        if (!parent) {
            return;
        }
        const extendedParent = this.ensureNgViewExtensions(parent);
        const extendedChild = this.ensureNgViewExtensions(child);
        if (!previous) {
            previous = extendedParent.lastChild;
        }
        this.addToQueue(extendedParent, extendedChild, previous, next);
        if (isInvisibleNode(child)) {
            extendedChild.parentNode = extendedParent;
        }
        if (!isDetachedElement(child)) {
            const nextVisual = this.findNextVisual(next);
            this.addToVisualTree(extendedParent, extendedChild, nextVisual);
        }
    }
    addToQueue(parent, child, previous, next) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`ViewUtil.addToQueue parent: ${parent}, view: ${child}, ` + `previous: ${previous}, next: ${next}`);
        }
        if (previous) {
            previous.nextSibling = child;
        }
        else {
            parent.firstChild = child;
        }
        if (next) {
            child.nextSibling = next;
        }
        else {
            this.appendToQueue(parent, child);
        }
    }
    appendToQueue(parent, view) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`ViewUtil.appendToQueue parent: ${parent} view: ${view}`);
        }
        if (parent.lastChild) {
            parent.lastChild.nextSibling = view;
        }
        parent.lastChild = view;
    }
    addToVisualTree(parent, child, next) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`ViewUtil.addToVisualTree parent: ${parent}, view: ${child}, next: ${next}`);
        }
        if (parent.meta && parent.meta.insertChild) {
            parent.meta.insertChild(parent, child, next);
        }
        else if (isLayout(parent)) {
            this.insertToLayout(parent, child, next);
        }
        else if (isContentView(parent)) {
            parent.content = child;
        }
        else if (parent && parent._addChildFromBuilder) {
            parent._addChildFromBuilder(child.nodeName, child);
        }
    }
    insertToLayout(parent, child, next) {
        if (child.parent === parent) {
            this.removeLayoutChild(parent, child);
        }
        const nextVisual = this.findNextVisual(next);
        if (nextVisual) {
            const index = parent.getChildIndex(nextVisual);
            parent.insertChild(child, index);
        }
        else {
            parent.addChild(child);
        }
    }
    findNextVisual(view) {
        let next = view;
        while (next && isDetachedElement(next)) {
            next = next.nextSibling;
        }
        return next;
    }
    removeChild(parent, child) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`ViewUtil.removeChild parent: ${parent} child: ${child}`);
        }
        if (!parent) {
            return;
        }
        const extendedParent = this.ensureNgViewExtensions(parent);
        const extendedChild = this.ensureNgViewExtensions(child);
        this.removeFromQueue(extendedParent, extendedChild);
        if (!isDetachedElement(extendedChild)) {
            this.removeFromVisualTree(extendedParent, extendedChild);
        }
    }
    removeFromQueue(parent, child) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`ViewUtil.removeFromQueue parent: ${parent} child: ${child}`);
        }
        if (parent.firstChild === child && parent.lastChild === child) {
            parent.firstChild = null;
            parent.lastChild = null;
            child.nextSibling = null;
            return;
        }
        if (parent.firstChild === child) {
            parent.firstChild = child.nextSibling;
        }
        const previous = this.findPreviousElement(parent, child);
        if (parent.lastChild === child) {
            parent.lastChild = previous;
        }
        if (previous) {
            previous.nextSibling = child.nextSibling;
        }
        child.nextSibling = null;
    }
    // NOTE: This one is O(n) - use carefully
    findPreviousElement(parent, child) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`ViewUtil.findPreviousElement parent: ${parent} child: ${child}`);
        }
        let previousVisual;
        if (isLayout(parent)) {
            previousVisual = this.getPreviousVisualElement(parent, child);
        }
        let previous = previousVisual || parent.firstChild;
        // since detached elements are not added to the visual tree,
        // we need to find the actual previous sibling of the view,
        // which may as well be an invisible node
        while (previous && previous !== child && previous.nextSibling !== child) {
            previous = previous.nextSibling;
        }
        return previous;
    }
    getPreviousVisualElement(parent, child) {
        const elementIndex = parent.getChildIndex(child);
        if (elementIndex > 0) {
            return parent.getChildAt(elementIndex - 1);
        }
    }
    // NOTE: This one is O(n) - use carefully
    getChildIndex(parent, child) {
        if (isLayout(parent)) {
            return parent.getChildIndex(child);
        }
        else if (isContentView(parent)) {
            return child === parent.content ? 0 : -1;
        }
    }
    removeFromVisualTree(parent, child) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`ViewUtil.removeFromVisualTree parent: ${parent} child: ${child}`);
        }
        if (parent.meta && parent.meta.removeChild) {
            parent.meta.removeChild(parent, child);
        }
        else if (isLayout(parent)) {
            this.removeLayoutChild(parent, child);
        }
        else if (isContentView(parent) && parent.content === child) {
            parent.content = null;
        }
        else if (isView(parent)) {
            parent._removeView(child);
        }
    }
    removeLayoutChild(parent, child) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`ViewUtil.removeLayoutChild parent: ${parent} child: ${child}`);
        }
        const index = parent.getChildIndex(child);
        if (index !== -1) {
            parent.removeChild(child);
        }
    }
    createComment() {
        return new CommentNode();
    }
    createText() {
        return new TextNode();
    }
    createView(name) {
        const originalName = name;
        if (!isKnownView(name)) {
            name = 'ProxyViewContainer';
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`Creating view: ${originalName} ${name}`);
        }
        const viewClass = getViewClass(name);
        const view = new viewClass();
        const ngView = this.setNgViewExtensions(view, name);
        return ngView;
    }
    ensureNgViewExtensions(view) {
        if (view.hasOwnProperty('meta')) {
            return view;
        }
        else {
            const name = view.cssType;
            const ngView = this.setNgViewExtensions(view, name);
            return ngView;
        }
    }
    setNgViewExtensions(view, name) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`Make into a NgView view: ${view} name: "${name}"`);
        }
        const ngView = view;
        ngView.nodeName = name;
        ngView.meta = getViewMeta(name);
        // we're setting the node type of the view
        // to 'element' because of checks done in the
        // dom animation engine
        ngView.nodeType = ELEMENT_NODE_TYPE;
        return ngView;
    }
    setProperty(view, attributeName, value, namespace) {
        if (!view || (namespace && !this.runsIn(namespace))) {
            return;
        }
        if (attributeName.indexOf('.') !== -1) {
            // Handle nested properties
            const properties = attributeName.split('.');
            attributeName = properties[properties.length - 1];
            let propMap = this.getProperties(view);
            let i = 0;
            while (i < properties.length - 1 && typeof view !== 'undefined') {
                let prop = properties[i];
                if (propMap.has(prop)) {
                    prop = propMap.get(prop);
                }
                view = view[prop];
                propMap = this.getProperties(view);
                i++;
            }
        }
        if (typeof view !== 'undefined') {
            this.setPropertyInternal(view, attributeName, value);
        }
    }
    runsIn(platform) {
        return (platform === 'ios' && this.isIos) || (platform === 'android' && this.isAndroid);
    }
    setPropertyInternal(view, attributeName, value) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.viewUtilLog(`Setting attribute: ${attributeName}=${value} to ${view}`);
        }
        if (attributeName === 'class') {
            this.setClasses(view, value);
            return;
        }
        if (XML_ATTRIBUTES.indexOf(attributeName) !== -1) {
            view[attributeName] = value;
            return;
        }
        const propMap = this.getProperties(view);
        const propertyName = propMap.get(attributeName);
        // Ensure the children of a collection currently have no parent set.
        if (Array.isArray(value)) {
            this.removeParentReferencesFromItems(value);
        }
        if (propertyName) {
            // We have a lower-upper case mapped property.
            view[propertyName] = value;
            return;
        }
        // Unknown attribute value -- just set it to our object as is.
        view[attributeName] = value;
    }
    removeParentReferencesFromItems(items) {
        for (const item of items) {
            if (item.parent && item.parentNode) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.viewUtilLog(`Unassigning parent ${item.parentNode} on value: ${item}`);
                }
                item.parent = undefined;
                item.parentNode = undefined;
            }
        }
    }
    getProperties(instance) {
        const type = instance && instance.constructor;
        if (!type) {
            return new Map();
        }
        if (!propertyMaps.has(type)) {
            let propMap = new Map();
            for (let propName in instance) {
                // tslint:disable:forin
                propMap.set(propName.toLowerCase(), propName);
            }
            propertyMaps.set(type, propMap);
        }
        return propertyMaps.get(type);
    }
    cssClasses(view) {
        if (!view.ngCssClasses) {
            view.ngCssClasses = new Map();
        }
        return view.ngCssClasses;
    }
    addClass(view, className) {
        this.cssClasses(view).set(className, true);
        this.syncClasses(view);
    }
    removeClass(view, className) {
        this.cssClasses(view).delete(className);
        this.syncClasses(view);
    }
    setClasses(view, classesValue) {
        let classes = classesValue.split(whiteSpaceSplitter);
        this.cssClasses(view).clear();
        classes.forEach((className) => this.cssClasses(view).set(className, true));
        this.syncClasses(view);
    }
    syncClasses(view) {
        let classValue = Array.from(this.cssClasses(view).keys()).join(' ');
        view.className = classValue;
    }
    setStyle(view, styleName, value) {
        view.style[styleName] = value;
    }
    removeStyle(view, styleName) {
        view.style[styleName] = unsetValue;
    }
}

class NativeScriptRenderer extends Renderer2 {
    constructor(rootView, zone, viewUtil) {
        super();
        this.rootView = rootView;
        this.zone = zone;
        this.viewUtil = viewUtil;
        this.data = Object.create(null);
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog('NativeScriptRenderer created');
        }
    }
    appendChild(parent, newChild) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.appendChild child: ${newChild} parent: ${parent}`);
        }
        this.viewUtil.insertChild(parent, newChild);
    }
    insertBefore(parent, newChild, { previous, next }) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.insertBefore child: ${newChild} ` + `parent: ${parent} previous: ${previous} next: ${next}`);
        }
        this.viewUtil.insertChild(parent, newChild, previous, next);
    }
    removeChild(parent, oldChild) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.removeChild child: ${oldChild} parent: ${parent}`);
        }
        this.viewUtil.removeChild(parent, oldChild);
    }
    selectRootElement(selector) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.selectRootElement: ${selector}`);
        }
        if (selector && selector[0] === '#') {
            const result = getViewById(this.rootView, selector.slice(1));
            return (result || this.rootView);
        }
        return this.rootView;
    }
    parentNode(node) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.parentNode for node: ${node} is ${node.parentNode}`);
        }
        return node.parentNode;
    }
    nextSibling(node) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.nextSibling of ${node} is ${node.nextSibling}`);
        }
        return {
            previous: node,
            next: node.nextSibling,
        };
    }
    createComment(_value) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.createComment ${_value}`);
        }
        return this.viewUtil.createComment();
    }
    createElement(name, _namespace) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.createElement: ${name}`);
        }
        return this.viewUtil.createView(name);
    }
    createText(_value) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.createText ${_value}`);
        }
        return this.viewUtil.createText();
    }
    createViewRoot(hostElement) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.createViewRoot ${hostElement.nodeName}`);
        }
        return hostElement;
    }
    projectNodes(parentElement, nodes) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog('NativeScriptRenderer.projectNodes');
        }
        nodes.forEach((node) => this.viewUtil.insertChild(parentElement, node));
    }
    destroy() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog('NativeScriptRenderer.destroy');
        }
        // Seems to be called on component dispose only (router outlet)
        // TODO: handle this when we resolve routing and navigation.
    }
    setAttribute(view, name, value, namespace) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.setAttribute ${view} : ${name} = ${value}, namespace: ${namespace}`);
        }
        return this.viewUtil.setProperty(view, name, value, namespace);
    }
    removeAttribute(_el, _name) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.removeAttribute ${_el}: ${_name}`);
        }
    }
    setProperty(view, name, value) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.setProperty ${view} : ${name} = ${value}`);
        }
        return this.viewUtil.setProperty(view, name, value);
    }
    addClass(view, name) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.addClass ${name}`);
        }
        this.viewUtil.addClass(view, name);
    }
    removeClass(view, name) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.removeClass ${name}`);
        }
        this.viewUtil.removeClass(view, name);
    }
    setStyle(view, styleName, value, _flags) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.setStyle: ${styleName} = ${value}`);
        }
        this.viewUtil.setStyle(view, styleName, value);
    }
    removeStyle(view, styleName, _flags) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog('NativeScriptRenderer.removeStyle: ${styleName}');
        }
        this.viewUtil.removeStyle(view, styleName);
    }
    // Used only in debug mode to serialize property changes to comment nodes,
    // such as <template> placeholders.
    setBindingDebugInfo(renderElement, propertyName, propertyValue) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.setBindingDebugInfo: ${renderElement}, ${propertyName} = ${propertyValue}`);
        }
    }
    setElementDebugInfo(renderElement, _info /*RenderDebugInfo*/) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.setElementDebugInfo: ${renderElement}`);
        }
    }
    invokeElementMethod(_renderElement, methodName, args) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.invokeElementMethod ${methodName} ${args}`);
        }
    }
    setValue(_renderNode, _value) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.setValue renderNode: ${_renderNode}, value: ${_value}`);
        }
    }
    listen(renderElement, eventName, callback) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRenderer.listen: ${eventName}`);
        }
        // Explicitly wrap in zone
        let zonedCallback = (...args) => {
            this.zone.run(() => {
                callback.apply(undefined, args);
            });
        };
        renderElement.on(eventName, zonedCallback);
        if (eventName === View.loadedEvent && renderElement.isLoaded) {
            const notifyData = { eventName: View.loadedEvent, object: renderElement };
            zonedCallback(notifyData);
        }
        return () => renderElement.off(eventName, zonedCallback);
    }
}
NativeScriptRenderer.decorators = [
    { type: Injectable }
];
NativeScriptRenderer.ctorParameters = () => [
    { type: undefined },
    { type: NgZone },
    { type: ViewUtil }
];
__decorate([
    profile
], NativeScriptRenderer.prototype, "appendChild", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "insertBefore", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "removeChild", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "selectRootElement", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "parentNode", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "nextSibling", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "createComment", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "createElement", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "createText", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "createViewRoot", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "projectNodes", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "destroy", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "setAttribute", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "removeAttribute", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "setProperty", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "addClass", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "removeClass", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "setStyle", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "removeStyle", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "setBindingDebugInfo", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "setElementDebugInfo", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "invokeElementMethod", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "setValue", null);
__decorate([
    profile
], NativeScriptRenderer.prototype, "listen", null);

// CONTENT_ATTR not exported from NativeScript_renderer - we need it for styles application.
const COMPONENT_REGEX = /%COMP%/g;
const ATTR_SANITIZER = /-/g;
const COMPONENT_VARIABLE = '%COMP%';
const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
const replaceNgAttribute = function (input, componentId) {
    return input.replace(COMPONENT_REGEX, componentId);
};
const ɵ0$2 = replaceNgAttribute;
const ɵ1$2 = function addScopedStyleToCss(style) {
    Application.addCss(style, true);
};
const addScopedStyleToCss = profile(`"renderer".addScopedStyleToCss`, ɵ1$2);
class EmulatedRenderer extends NativeScriptRenderer {
    constructor(component, rootView, zone, viewUtil) {
        super(rootView, zone, viewUtil);
        const componentId = component.id.replace(ATTR_SANITIZER, '_');
        this.contentAttr = replaceNgAttribute(CONTENT_ATTR, componentId);
        this.hostAttr = replaceNgAttribute(HOST_ATTR, componentId);
        this.addStyles(component.styles, componentId);
    }
    applyToHost(view) {
        super.setAttribute(view, this.hostAttr, '');
    }
    appendChild(parent, newChild) {
        super.appendChild(parent, newChild);
    }
    createElement(parent, name) {
        const view = super.createElement(parent, name);
        // Set an attribute to the view to scope component-specific css.
        // The property name is pre-generated by Angular.
        super.setAttribute(view, this.contentAttr, '');
        return view;
    }
    addStyles(styles, componentId) {
        styles
            .map((s) => s.toString())
            .map((s) => replaceNgAttribute(s, componentId))
            .forEach(addScopedStyleToCss);
    }
}
EmulatedRenderer.decorators = [
    { type: Injectable }
];
EmulatedRenderer.ctorParameters = () => [
    { type: undefined },
    { type: undefined },
    { type: NgZone },
    { type: ViewUtil }
];
__decorate([
    profile
], EmulatedRenderer.prototype, "addStyles", null);

const ɵ0$3 = function addStyleToCss(style) {
    Application.addCss(style);
};
const addStyleToCss = profile('"renderer".addStyleToCss', ɵ0$3);
class NativeScriptRendererFactory {
    constructor(rootView, zone) {
        this.zone = zone;
        this.componentRenderers = new Map();
        this.viewUtil = new ViewUtil(Device);
        this.setRootNgView(rootView);
        this.defaultRenderer = new NativeScriptRenderer(this.rootNgView, zone, this.viewUtil);
    }
    setRootNgView(rootView) {
        if (!rootView) {
            rootView = getRootPage();
        }
        rootView.nodeName = 'NONE';
        this.rootNgView = rootView;
    }
    createRenderer(element, type) {
        if (!element || !type) {
            return this.defaultRenderer;
        }
        let renderer = this.componentRenderers.get(type.id);
        if (renderer) {
            if (renderer instanceof EmulatedRenderer) {
                renderer.applyToHost(element);
            }
            return renderer;
        }
        if (type.encapsulation === ViewEncapsulation.None) {
            type.styles.map((s) => s.toString()).forEach(addStyleToCss);
            renderer = this.defaultRenderer;
        }
        else {
            renderer = new EmulatedRenderer(type, this.rootNgView, this.zone, this.viewUtil);
            renderer.applyToHost(element);
        }
        this.componentRenderers.set(type.id, renderer);
        return renderer;
    }
    ngOnDestroy() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.rendererLog(`NativeScriptRendererFactory.ngOnDestroy()`);
        }
        while (this.rootNgView && this.rootNgView.firstChild) {
            this.viewUtil.removeChild(this.rootNgView, this.rootNgView.firstChild);
        }
    }
}
NativeScriptRendererFactory.decorators = [
    { type: Injectable }
];
NativeScriptRendererFactory.ctorParameters = () => [
    { type: View, decorators: [{ type: Optional }, { type: Inject, args: [APP_ROOT_VIEW,] }] },
    { type: NgZone }
];

function errorHandlerFactory() {
    return new ErrorHandler();
}
class NativeScriptModule {
    constructor(parentModule) {
        // Prevents NativeScriptModule from getting imported multiple times
        throwIfAlreadyLoaded(parentModule, 'NativeScriptModule');
    }
}
NativeScriptModule.decorators = [
    { type: NgModule, args: [{
                declarations: [DetachedLoader],
                providers: [FrameService, NativeScriptRendererFactory, SystemJsNgModuleLoader, { provide: ɵINJECTOR_SCOPE, useValue: 'root' }, { provide: ErrorHandler, useFactory: errorHandlerFactory }, { provide: RendererFactory2, useExisting: NativeScriptRendererFactory }, { provide: ViewportScroller, useClass: ɵNullViewportScroller }],
                entryComponents: [DetachedLoader],
                imports: [ApplicationModule, NativeScriptCommonModule],
                exports: [ApplicationModule, NativeScriptCommonModule, DetachedLoader],
                schemas: [NO_ERRORS_SCHEMA],
            },] }
];
NativeScriptModule.ctorParameters = () => [
    { type: NativeScriptModule, decorators: [{ type: Optional }, { type: SkipSelf }] }
];

const DASH_CASE_REGEXP = /-+([a-z0-9])/g;
function dashCaseToCamelCase(input) {
    return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
}
function createKeyframeAnimation(styles, duration, delay, easing) {
    const info = createKeyframeAnimationInfo(styles, duration, delay, easing);
    return KeyframeAnimation.keyframeAnimationFromInfo(info);
}
const createKeyframeAnimationInfo = (styles, duration, delay, easing) => ({
    isForwards: true,
    duration: duration || 0.01,
    delay,
    curve: getCurve(easing),
    keyframes: styles.map(parseAnimationKeyframe),
});
const ɵ0$4 = createKeyframeAnimationInfo;
const getCurve = (value) => animationTimingFunctionConverter(value);
const ɵ1$3 = getCurve;
const parseAnimationKeyframe = (styles) => ({
    duration: getKeyframeDuration(styles),
    declarations: getDeclarations(styles),
});
const ɵ2$1 = parseAnimationKeyframe;
const getKeyframeDuration = (styles) => styles.offset;
const ɵ3$1 = getKeyframeDuration;
function getDeclarations(styles) {
    const unparsedDeclarations = Object.keys(styles).map((property) => ({ property, value: styles[property] }));
    return parseKeyframeDeclarations(unparsedDeclarations);
}

class NativeScriptAnimationPlayer {
    constructor(target, keyframes, duration, delay, easing) {
        this.target = target;
        this.duration = duration;
        this.delay = delay;
        this.parentPlayer = null;
        this._startSubscriptions = [];
        this._doneSubscriptions = [];
        this._finished = false;
        this._started = false;
        this.initKeyframeAnimation(keyframes, duration, delay, easing);
    }
    get totalTime() {
        return this.delay + this.duration;
    }
    init() { }
    hasStarted() {
        return this._started;
    }
    onStart(fn) {
        this._startSubscriptions.push(fn);
    }
    onDone(fn) {
        this._doneSubscriptions.push(fn);
    }
    onDestroy(fn) {
        this._doneSubscriptions.push(fn);
    }
    play() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.animationsLog(`NativeScriptAnimationPlayer.play`);
        }
        if (!this.animation) {
            return;
        }
        if (!this._started) {
            this._started = true;
            this._startSubscriptions.forEach((fn) => fn());
            this._startSubscriptions = [];
        }
        // When this issue https://github.com/NativeScript/NativeScript/issues/7984 is fixes in @nativescript/core
        // we can change this fix and apply the one that is recommended in that issue.
        if (this.target.isLoaded) {
            this.playAnimation();
        }
        else {
            this.target.on(View.loadedEvent, this.onTargetLoaded.bind(this));
        }
    }
    onTargetLoaded(args) {
        this.target.off(View.loadedEvent, this.onTargetLoaded);
        this.playAnimation();
    }
    playAnimation() {
        this.animation
            .play(this.target)
            .then(() => this.onFinish())
            .catch((_e) => { });
    }
    pause() { }
    finish() {
        this.onFinish();
    }
    reset() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.animationsLog(`NativeScriptAnimationPlayer.reset`);
        }
        if (this.animation && this.animation.isPlaying) {
            this.animation.cancel();
        }
    }
    restart() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.animationsLog(`NativeScriptAnimationPlayer.restart`);
        }
        this.reset();
        this.play();
    }
    destroy() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.animationsLog(`NativeScriptAnimationPlayer.destroy`);
        }
        this.onFinish();
    }
    setPosition(_p) {
        throw new Error('AnimationPlayer.setPosition method is not supported!');
    }
    getPosition() {
        return 0;
    }
    initKeyframeAnimation(keyframes, duration, delay, easing) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.animationsLog(`NativeScriptAnimationPlayer.initKeyframeAnimation`);
        }
        this.animation = createKeyframeAnimation(keyframes, duration, delay, easing);
    }
    onFinish() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.animationsLog(`NativeScriptAnimationPlayer.onFinish`);
        }
        if (this._finished) {
            return;
        }
        this._finished = true;
        this._started = false;
        this._doneSubscriptions.forEach((fn) => fn());
        this._doneSubscriptions = [];
    }
}

class Selector {
    constructor(rawSelector) {
        this.parse(rawSelector);
    }
    match(element) {
        return this.nsSelectorMatch(element) || this.classSelectorsMatch(element);
    }
    parse(rawSelector) {
        const selectors = rawSelector.split(',').map((s) => s.trim());
        this.nsSelectors = selectors.map(CSSHelper.createSelector);
        this.classSelectors = selectors.filter((s) => s.startsWith('.')).map((s) => s.substring(1));
    }
    nsSelectorMatch(element) {
        return this.nsSelectors.some((s) => s.match(element));
    }
    classSelectorsMatch(element) {
        return this.classSelectors.some((s) => this.hasClass(element, s));
    }
    // we're using that instead of match for classes
    // that are dynamically added by the animation engine
    // such as .ng-trigger, that's added for every :enter view
    hasClass(element, cls) {
        return element && element['$$classes'] && element['$$classes'][cls];
    }
}
class NativeScriptAnimationDriver {
    validateStyleProperty(property) {
        NativeScriptDebug.animationsLog(`CssAnimationProperty.validateStyleProperty: ${property}`);
        return NativeScriptAnimationDriver.validProperties.indexOf(property) !== -1;
    }
    matchesElement(element, rawSelector) {
        NativeScriptDebug.animationsLog(`NativeScriptAnimationDriver.matchesElement ` + `element: ${element}, selector: ${rawSelector}`);
        const selector = this.makeSelector(rawSelector);
        return selector.match(element);
    }
    containsElement(elm1, elm2) {
        NativeScriptDebug.animationsLog(`NativeScriptAnimationDriver.containsElement ` + `element1: ${elm1}, element2: ${elm2}`);
        // Checking if the parent is our fake body object
        if (elm1['isOverride']) {
            return true;
        }
        const params = { originalView: elm2 };
        const result = this.visitDescendants(elm1, viewMatches, params);
        return result.found;
    }
    query(element, rawSelector, multi) {
        NativeScriptDebug.animationsLog(`NativeScriptAnimationDriver.query ` + `element: ${element}, selector: ${rawSelector} ` + `multi: ${multi}`);
        const selector = this.makeSelector(rawSelector);
        const params = { selector, multi };
        const result = this.visitDescendants(element, queryDescendants, params);
        return result.matches || [];
    }
    computeStyle(element, prop) {
        NativeScriptDebug.animationsLog(`NativeScriptAnimationDriver.computeStyle ` + `element: ${element}, prop: ${prop}`);
        const camelCaseProp = dashCaseToCamelCase(prop);
        return element.style[camelCaseProp];
    }
    animate(element, keyframes, duration, delay, easing) {
        NativeScriptDebug.animationsLog(`NativeScriptAnimationDriver.animate ` + `element: ${element}, keyframes: ${keyframes} ` + `duration: ${duration}, delay: ${delay} ` + `easing: ${easing}`);
        return new NativeScriptAnimationPlayer(element, keyframes, duration, delay, easing);
    }
    makeSelector(rawSelector) {
        return new Selector(rawSelector);
    }
    visitDescendants(element, cb, cbParams) {
        const result = {};
        // fill the result obj with the result from the callback function
        eachDescendant(element, (child) => cb(child, result, cbParams));
        return result;
    }
}
NativeScriptAnimationDriver.validProperties = [...CssAnimationProperty._getPropertyNames(), 'transform'];
function viewMatches(element, result, params) {
    if (element === params.originalView) {
        result.found = true;
    }
    return !result.found;
}
function queryDescendants(element, result, params) {
    if (!result.matches) {
        result.matches = [];
    }
    const { selector, multi } = params;
    // skip comment and text nodes
    // because they are not actual Views
    // and cannot be animated
    if (element instanceof InvisibleNode || !selector.match(element)) {
        return true;
    }
    if (element instanceof ProxyViewContainer) {
        element.eachChild((child) => {
            result.matches.push(child);
            return true;
        });
    }
    else {
        result.matches.push(element);
    }
    return multi;
}

class InjectableAnimationEngine extends ɵAnimationEngine {
    constructor(doc, driver, normalizer) {
        super(doc.body, driver, normalizer);
    }
}
InjectableAnimationEngine.decorators = [
    { type: Injectable }
];
InjectableAnimationEngine.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: AnimationDriver },
    { type: ɵAnimationStyleNormalizer }
];
function instantiateSupportedAnimationDriver() {
    return new NativeScriptAnimationDriver();
}
function instantiateRendererFactory(renderer, engine, zone) {
    return new ɵAnimationRendererFactory(renderer, engine, zone);
}
function instantiateDefaultStyleNormalizer() {
    return new ɵWebAnimationsStyleNormalizer();
}
class NativeScriptAnimationsModule {
    constructor(parentModule) {
        // Prevents NativeScriptAnimationsModule from getting imported multiple times
        throwIfAlreadyLoaded(parentModule, 'NativeScriptAnimationsModule');
    }
}
NativeScriptAnimationsModule.decorators = [
    { type: NgModule, args: [{
                imports: [NativeScriptCommonModule],
                providers: [
                    {
                        provide: AnimationDriver,
                        useFactory: instantiateSupportedAnimationDriver,
                    },
                    { provide: AnimationBuilder, useClass: ɵBrowserAnimationBuilder },
                    {
                        provide: ɵAnimationStyleNormalizer,
                        useFactory: instantiateDefaultStyleNormalizer,
                    },
                    { provide: ɵAnimationEngine, useClass: InjectableAnimationEngine },
                    {
                        provide: RendererFactory2,
                        useFactory: instantiateRendererFactory,
                        deps: [NativeScriptRendererFactory, ɵAnimationEngine, NgZone],
                    },
                ],
            },] }
];
NativeScriptAnimationsModule.ctorParameters = () => [
    { type: NativeScriptAnimationsModule, decorators: [{ type: Optional }, { type: SkipSelf }] }
];

function isLocalRequest(url) {
    return url.indexOf('~') === 0 || url.indexOf('/') === 0;
}
function getAbsolutePath(url, nsFileSystem) {
    url = url.replace('~', '').replace('/', '');
    url = path.join(nsFileSystem.currentApp().path, url);
    return url;
}
function processLocalFileRequest(url, nsFileSystem, successResponse, errorResponse) {
    url = getAbsolutePath(url, nsFileSystem);
    // request from local app resources
    return new Observable((observer) => {
        if (nsFileSystem.fileExists(url)) {
            const localFile = nsFileSystem.fileFromPath(url);
            localFile.readText().then((data) => {
                try {
                    const json = JSON.parse(data);
                    observer.next(successResponse(url, json, 200));
                    observer.complete();
                }
                catch (error) {
                    // Even though the response status was 2xx, this is still an error.
                    // The parse error contains the text of the body that failed to parse.
                    const errorResult = { error, text: data };
                    observer.error(errorResponse(url, errorResult, 200));
                }
            }, (err) => {
                observer.error(errorResponse(url, err, 400));
            });
        }
        else {
            observer.error(errorResponse(url, 'Not Found', 404));
        }
    });
}

class NsHttpBackEnd extends HttpXhrBackend {
    constructor(xhrFactory, nsFileSystem) {
        super(xhrFactory);
        this.nsFileSystem = nsFileSystem;
    }
    handle(req) {
        let result;
        if (isLocalRequest(req.url)) {
            result = this.handleLocalFileRequest(req.url);
        }
        else {
            result = super.handle(req);
        }
        return result;
    }
    handleLocalFileRequest(url) {
        return processLocalFileRequest(url, this.nsFileSystem, createSuccessResponse, createErrorResponse);
    }
}
NsHttpBackEnd.decorators = [
    { type: Injectable }
];
NsHttpBackEnd.ctorParameters = () => [
    { type: XhrFactory },
    { type: NSFileSystem }
];
function createSuccessResponse(url, body, status) {
    return new HttpResponse({
        url,
        body,
        status,
        statusText: 'OK',
    });
}
function createErrorResponse(url, body, status) {
    return new HttpErrorResponse({
        url,
        error: body,
        status,
        statusText: 'ERROR',
    });
}

class NativeScriptHttpClientModule {
}
NativeScriptHttpClientModule.decorators = [
    { type: NgModule, args: [{
                providers: [NSFileSystem, NsHttpBackEnd, { provide: HttpBackend, useExisting: NsHttpBackEnd }],
                imports: [HttpClientModule],
                exports: [HttpClientModule],
            },] }
];

class BaseValueAccessor {
    constructor(view) {
        this.view = view;
        this.pendingChangeNotification = 0;
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    registerOnChange(fn) {
        this.onChange = (arg) => {
            if (this.pendingChangeNotification) {
                clearTimeout(this.pendingChangeNotification);
            }
            this.pendingChangeNotification = setTimeout(() => {
                this.pendingChangeNotification = 0;
                fn(arg);
            }, 20);
        };
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.view.isEnabled = !isDisabled;
    }
    writeValue(_) { }
    normalizeValue(value) {
        return isBlank(value) ? unsetValue : value;
    }
}

const TEXT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => TextValueAccessor),
    multi: true,
};
/**
 * The accessor for writing a text and listening to changes that is used by the
 * {@link NgModel} directives.
 *
 *  ### Example
 *  ```
 *  <TextField [(ngModel)]="model.test">
 *  ```
 */
class TextValueAccessor extends BaseValueAccessor {
    // tslint:disable-line:directive-class-suffix
    constructor(elementRef) {
        super(elementRef.nativeElement);
    }
    writeValue(value) {
        const normalized = super.normalizeValue(value);
        this.view.text = normalized;
    }
}
TextValueAccessor.decorators = [
    { type: Directive, args: [{
                selector: 'TextField[ngModel],TextField[formControlName],TextField[formControl],' +
                    'textField[ngModel],textField[formControlName],textField[formControl],' +
                    'textfield[ngModel],textfield[formControlName],textfield[formControl],' +
                    'text-field[ngModel],text-field[formControlName],text-field[formControl],' +
                    'TextView[ngModel],TextView[formControlName],TextView[formControl],' +
                    'textView[ngModel],textView[formControlName],textView[formControl],' +
                    'textview[ngModel],textview[formControlName],textview[formControl],' +
                    'text-view[ngModel],text-view[formControlName],text-view[formControl],' +
                    'SearchBar[ngModel],SearchBar[formControlName],SearchBar[formControl],' +
                    'searchBar[ngModel],searchBar[formControlName],searchBar[formControl],' +
                    'searchbar[ngModel],searchbar[formControlName],searchbar[formControl],' +
                    'search-bar[ngModel], search-bar[formControlName],search-bar[formControl]',
                providers: [TEXT_VALUE_ACCESSOR],
                host: {
                    '(blur)': 'onTouched()',
                    '(textChange)': 'onChange($event.value)',
                },
            },] }
];
TextValueAccessor.ctorParameters = () => [
    { type: ElementRef }
];

const CHECKED_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => CheckedValueAccessor),
    multi: true,
};
/**
 * The accessor for setting a checked property and listening to changes that is used by the
 * {@link NgModel} directives.
 *
 *  ### Example
 *  ```
 *  <Switch [(ngModel)]="model.test">
 *  ```
 */
class CheckedValueAccessor extends BaseValueAccessor {
    // tslint:disable-line:directive-class-suffix
    constructor(elementRef) {
        super(elementRef.nativeElement);
    }
    writeValue(value) {
        const normalized = super.normalizeValue(value);
        this.view.checked = normalized;
    }
}
CheckedValueAccessor.decorators = [
    { type: Directive, args: [{
                selector: 'Switch[ngModel],Switch[formControlName],Switch[formControl],' + 'switch[ngModel],switch[formControlName],switch[formControl]',
                providers: [CHECKED_VALUE_ACCESSOR],
                host: {
                    '(checkedChange)': 'onChange($event.value)',
                },
            },] }
];
CheckedValueAccessor.ctorParameters = () => [
    { type: ElementRef }
];

const DATE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => DateValueAccessor),
    multi: true,
};
/**
 * The accessor for setting a date and listening to changes that is used by the
 * {@link NgModel} directives.
 *
 *  ### Example
 *  ```
 *  <DatePicker [(ngModel)]="model.test">
 *  ```
 */
class DateValueAccessor extends BaseValueAccessor {
    // tslint:disable-line:directive-class-suffix
    constructor(elementRef) {
        super(elementRef.nativeElement);
    }
    writeValue(value) {
        const normalized = super.normalizeValue(value);
        this.view.date = normalized;
    }
}
DateValueAccessor.decorators = [
    { type: Directive, args: [{
                selector: 'DatePicker[ngModel],DatePicker[formControlName],DatePicker[formControl],' + 'datepicker[ngModel],datepicker[formControlName],datepicker[formControl],' + 'datePicker[ngModel],datePicker[formControlName],datePicker[formControl],' + 'date-picker[ngModel],date-picker[formControlName],date-picker[formControl]',
                providers: [DATE_VALUE_ACCESSOR],
                host: {
                    '(dateChange)': 'onChange($event.value)',
                },
            },] }
];
DateValueAccessor.ctorParameters = () => [
    { type: ElementRef }
];

const TIME_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => TimeValueAccessor),
    multi: true,
};
/**
 * The accessor for setting a time and listening to changes that is used by the
 * {@link NgModel} directives.
 *
 *  ### Example
 *  ```
 *  <TimePicker [(ngModel)]="model.test">
 *  ```
 */
class TimeValueAccessor extends BaseValueAccessor {
    // tslint:disable-line:directive-class-suffix
    constructor(elementRef) {
        super(elementRef.nativeElement);
    }
    writeValue(value) {
        const normalized = super.normalizeValue(value);
        this.view.time = normalized;
    }
}
TimeValueAccessor.decorators = [
    { type: Directive, args: [{
                selector: 'TimePicker[ngModel],TimePicker[formControlName],TimePicker[formControl],' + 'timepicker[ngModel],timepicker[formControlName],timepicker[formControl],' + 'timePicker[ngModel],timePicker[formControlName],timePicker[formControl],' + 'time-picker[ngModel],time-picker[formControlName],time-picker[formControl]',
                providers: [TIME_VALUE_ACCESSOR],
                host: {
                    '(timeChange)': 'onChange($event.value)',
                },
            },] }
];
TimeValueAccessor.ctorParameters = () => [
    { type: ElementRef }
];

const NUMBER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NumberValueAccessor),
    multi: true,
};
/**
 * The accessor for setting a value and listening to changes that is used by the
 * {@link NgModel}
 *
 *  ### Example
 *  ```
 *  <Slider [(ngModel)]="model.test">
 *  ```
 */
class NumberValueAccessor extends BaseValueAccessor {
    // tslint:disable-line:directive-class-suffix
    constructor(elementRef) {
        super(elementRef.nativeElement);
    }
    writeValue(value) {
        const normalized = super.normalizeValue(value);
        this.view.value = normalized;
    }
}
NumberValueAccessor.decorators = [
    { type: Directive, args: [{
                selector: 'Slider[ngModel],Slider[formControlName],Slider[formControl],' + 'slider[ngModel],slider[formControlName],slider[formControl]',
                providers: [NUMBER_VALUE_ACCESSOR],
                host: {
                    '(valueChange)': 'onChange($event.value)',
                },
            },] }
];
NumberValueAccessor.ctorParameters = () => [
    { type: ElementRef }
];

const SELECTED_INDEX_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => SelectedIndexValueAccessor),
    multi: true,
};
/**
 * The accessor for setting a selectedIndex and listening to changes that is used by the
 * {@link NgModel} directives.
 *
 *  ### Example
 *  ```
 *  <SegmentedBar [(ngModel)]="model.test">
 *  ```
 */
class SelectedIndexValueAccessor extends BaseValueAccessor {
    // tslint:disable-line:max-line-length directive-class-suffix
    constructor(elementRef) {
        super(elementRef.nativeElement);
    }
    writeValue(value) {
        const normalized = super.normalizeValue(value);
        this.value = normalized;
        if (this.viewInitialized) {
            this.view.selectedIndex = this.value;
        }
    }
    ngAfterViewInit() {
        this.viewInitialized = true;
        this.view.selectedIndex = this.value;
    }
}
SelectedIndexValueAccessor.decorators = [
    { type: Directive, args: [{
                selector: 'SegmentedBar[ngModel],SegmentedBar[formControlName],SegmentedBar[formControl],' +
                    'segmentedBar[ngModel],segmentedBar[formControlName],segmentedBar[formControl],' +
                    'segmentedbar[ngModel],segmentedbar[formControlName],segmentedbar[formControl],' +
                    'segmented-bar[ngModel],segmented-bar[formControlName],segmented-bar[formControl],' +
                    'ListPicker[ngModel],ListPicker[formControlName],ListPicker[formControl],' +
                    'listPicker[ngModel],listPicker[formControlName],listPicker[formControl],' +
                    'listpicker[ngModel],listpicker[formControlName],listpicker[formControl],' +
                    'list-picker[ngModel],list-picker[formControlName],list-picker[formControl],' +
                    'TabView[ngModel],TabView[formControlName],TabView[formControl],' +
                    'tabView[ngModel],tabView[formControlName],tabView[formControl],' +
                    'tabview[ngModel],tabview[formControlName],tabview[formControl],' +
                    'tab-view[ngModel],tab-view[formControlName],tab-view[formControl]',
                providers: [SELECTED_INDEX_VALUE_ACCESSOR],
                host: {
                    '(selectedIndexChange)': 'onChange($event.value)',
                },
            },] }
];
SelectedIndexValueAccessor.ctorParameters = () => [
    { type: ElementRef }
];

class NativeScriptFormsModule {
}
NativeScriptFormsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [TextValueAccessor, CheckedValueAccessor, DateValueAccessor, TimeValueAccessor, SelectedIndexValueAccessor, NumberValueAccessor],
                providers: [],
                imports: [FormsModule],
                exports: [FormsModule, TextValueAccessor, CheckedValueAccessor, DateValueAccessor, TimeValueAccessor, SelectedIndexValueAccessor, NumberValueAccessor],
            },] }
];

/**
 * There are cases where multiple activatedRoute nodes should be associated/handled by the same PageRouterOutlet.
 * We can gat additional ActivatedRoutes nodes when there is:
 *  - Lazy loading - there is an additional ActivatedRoute node for the RouteConfig with the `loadChildren` setup
 *  - Componentless routes - there is an additional ActivatedRoute node for the componentless RouteConfig
 *
 * Example:
 *   R  <-- root
 *   |
 * feature (lazy module) <-- RouteConfig: { path: "lazy", loadChildren: "./feature/feature.module#FeatureModule" }
 *   |
 * module (componentless route) <-- RouteConfig: { path: "module", children: [...] } // Note: No 'component'
 *   |
 *  home <-- RouteConfig: { path: "module", component: MyComponent } - this is what we get as activatedRoute param
 *
 *  In these cases we will mark the top-most node (feature). NSRouteReuseStrategy will detach the tree there and
 *  use this ActivateRoute as a kay for caching.
 */
function findTopActivatedRouteNodeForOutlet(activatedRoute) {
    let outletActivatedRoute = activatedRoute;
    while (outletActivatedRoute.parent && outletActivatedRoute.parent.routeConfig && !outletActivatedRoute.parent.routeConfig.component) {
        outletActivatedRoute = outletActivatedRoute.parent;
    }
    return outletActivatedRoute;
}
const pageRouterActivatedSymbol = Symbol('page-router-activated');
const loaderRefSymbol = Symbol('loader-ref');
function destroyComponentRef(componentRef) {
    if (componentRef) {
        const loaderRef = componentRef[loaderRefSymbol];
        if (loaderRef) {
            loaderRef.destroy();
        }
        componentRef.destroy();
    }
}

class RouterExtensions {
    constructor(router, locationStrategy, frameService) {
        this.router = router;
        this.locationStrategy = locationStrategy;
        this.frameService = frameService;
    }
    navigate(commands, extras) {
        if (extras) {
            this.locationStrategy._setNavigationOptions(extras);
        }
        return this.router.navigate(commands, extras);
    }
    navigateByUrl(url, options) {
        if (options) {
            this.locationStrategy._setNavigationOptions(options);
        }
        return this.router.navigateByUrl(url);
    }
    back(backNavigationOptions) {
        if (backNavigationOptions) {
            this.backOutlets(backNavigationOptions);
        }
        else {
            this.locationStrategy.back();
        }
    }
    canGoBack(backNavigationOptions) {
        let canGoBack = true;
        if (backNavigationOptions) {
            const { outletsToBack, outlets } = this.findOutletsToBack(backNavigationOptions);
            if (outletsToBack.length !== outlets.length) {
                NativeScriptDebug.routerError('No outlet found relative to activated route');
            }
            else {
                outletsToBack.forEach((outletToBack) => {
                    if (!this.locationStrategy.canGoBack(outletToBack)) {
                        canGoBack = false;
                    }
                });
            }
        }
        else {
            canGoBack = this.locationStrategy.canGoBack();
        }
        return canGoBack;
    }
    backToPreviousPage() {
        this.frameService.getFrame().goBack();
    }
    canGoBackToPreviousPage() {
        return this.frameService.getFrame().canGoBack();
    }
    backOutlets(options) {
        const { outletsToBack, outlets } = this.findOutletsToBack(options);
        if (outletsToBack.length !== outlets.length) {
            NativeScriptDebug.routerError('No outlet found relative to activated route');
        }
        else {
            outletsToBack.forEach((outletToBack) => {
                if (outletToBack.isPageNavigationBack) {
                    NativeScriptDebug.routerError('Attempted to call startGoBack while going back:');
                }
                else {
                    this.locationStrategy.back(outletToBack);
                }
            });
        }
    }
    // tslint:disable-next-line:max-line-length
    findOutletsToBack(options) {
        const outletsToBack = [];
        const rootRoute = this.router.routerState.root;
        let outlets = options.outlets;
        let relativeRoute = options.relativeTo || rootRoute;
        const relativeRouteOutlet = this.findOutletByRoute(relativeRoute);
        const isNSEmptyOutlet = relativeRouteOutlet && relativeRouteOutlet.isNSEmptyOutlet;
        // Lazy named outlet has added 'primary' inner NSEmptyOutlet child.
        // Take parent route when `relativeTo` option points to the outer named outlet.
        if (isNSEmptyOutlet && relativeRoute.outlet !== 'primary') {
            relativeRoute = relativeRoute.parent || relativeRoute;
        }
        const routesToMatch = outlets ? relativeRoute.children : [relativeRoute];
        outlets = outlets || [relativeRoute.outlet];
        for (let index = 0; index < routesToMatch.length; index++) {
            const currentRoute = routesToMatch[index];
            if (outlets.some((currentOutlet) => currentOutlet === currentRoute.outlet)) {
                const outlet = this.findOutletByRoute(currentRoute);
                if (outlet) {
                    outletsToBack.push(outlet);
                }
            }
        }
        return { outletsToBack: outletsToBack, outlets: outlets };
    }
    findOutletByRoute(currentRoute) {
        let outlet;
        const currentRouteSnapshop = findTopActivatedRouteNodeForOutlet(currentRoute.snapshot);
        const outletKey = this.locationStrategy.getRouteFullPath(currentRouteSnapshop);
        outlet = this.locationStrategy.findOutlet(outletKey, currentRouteSnapshop);
        return outlet;
    }
}
RouterExtensions.ɵprov = ɵɵdefineInjectable({ factory: function RouterExtensions_Factory() { return new RouterExtensions(ɵɵinject(Router), ɵɵinject(NSLocationStrategy), ɵɵinject(FrameService)); }, token: RouterExtensions, providedIn: "root" });
RouterExtensions.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
RouterExtensions.ctorParameters = () => [
    { type: Router },
    { type: NSLocationStrategy },
    { type: FrameService }
];

/**
 * The nsRouterLink directive lets you link to specific parts of your app.
 *
 * Consider the following route configuration:
 * ```
 * [{ path: "/user", component: UserCmp }]
 * ```
 *
 * When linking to this `User` route, you can write:
 *
 * ```
 * <a [nsRouterLink]="["/user"]">link to user component</a>
 * ```
 *
 * NSRouterLink expects the value to be an array of path segments, followed by the params
 * for that level of routing. For instance `["/team", {teamId: 1}, "user", {userId: 2}]`
 * means that we want to generate a link to `/team;teamId=1/user;userId=2`.
 *
 * The first segment name can be prepended with `/`, `./`, or `../`.
 * If the segment begins with `/`, the router will look up the route from the root of the app.
 * If the segment begins with `./`, or doesn"t begin with a slash, the router will
 * instead look in the current component"s children for the route.
 * And if the segment begins with `../`, the router will go up one level.
 */
class NSRouterLink {
    constructor(router, navigator, route) {
        this.router = router;
        this.navigator = navigator;
        this.route = route;
        this.pageTransition = true;
        this.commands = [];
    }
    set params(data) {
        if (Array.isArray(data)) {
            this.commands = data;
        }
        else {
            this.commands = [data];
        }
    }
    onTap() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog(`nsRouterLink.tapped: ${this.commands} ` + `clear: ${this.clearHistory} ` + `transition: ${JSON.stringify(this.pageTransition)} ` + `duration: ${this.pageTransitionDuration}`);
        }
        const extras = this.getExtras();
        this.navigator.navigateByUrl(this.urlTree, extras);
    }
    getExtras() {
        const transition = this.getTransition();
        return {
            skipLocationChange: attrBoolValue(this.skipLocationChange),
            replaceUrl: attrBoolValue(this.replaceUrl),
            clearHistory: this.convertClearHistory(this.clearHistory),
            animated: transition.animated,
            transition: transition.transition,
        };
    }
    get urlTree() {
        const urlTree = this.router.createUrlTree(this.commands, {
            relativeTo: this.route,
            queryParams: this.queryParams,
            fragment: this.fragment,
            preserveQueryParams: attrBoolValue(this.preserveQueryParams),
            queryParamsHandling: this.queryParamsHandling,
            preserveFragment: attrBoolValue(this.preserveFragment),
        });
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog(`nsRouterLink urlTree created: ${urlTree}`);
        }
        return urlTree;
    }
    convertClearHistory(value) {
        return value === true || value === 'true';
    }
    getTransition() {
        let transition;
        let animated;
        if (typeof this.pageTransition === 'boolean') {
            animated = this.pageTransition;
        }
        else if (typeof this.pageTransition === 'string') {
            if (this.pageTransition === 'none' || this.pageTransition === 'false') {
                animated = false;
            }
            else {
                animated = true;
                transition = {
                    name: this.pageTransition,
                };
            }
        }
        else {
            animated = true;
            transition = this.pageTransition;
        }
        let duration = +this.pageTransitionDuration;
        if (!isNaN(duration)) {
            transition = transition || {};
            transition.duration = duration;
        }
        return { animated, transition };
    }
}
NSRouterLink.decorators = [
    { type: Directive, args: [{ selector: '[nsRouterLink]' },] }
];
NSRouterLink.ctorParameters = () => [
    { type: Router },
    { type: RouterExtensions },
    { type: ActivatedRoute }
];
NSRouterLink.propDecorators = {
    target: [{ type: Input }],
    queryParams: [{ type: Input }],
    fragment: [{ type: Input }],
    queryParamsHandling: [{ type: Input }],
    preserveQueryParams: [{ type: Input }],
    preserveFragment: [{ type: Input }],
    skipLocationChange: [{ type: Input }],
    replaceUrl: [{ type: Input }],
    clearHistory: [{ type: Input }],
    pageTransition: [{ type: Input }],
    pageTransitionDuration: [{ type: Input }],
    params: [{ type: Input, args: ['nsRouterLink',] }],
    onTap: [{ type: HostListener, args: ['tap',] }]
};
function attrBoolValue(s) {
    return s === '' || !!s;
}

/* tslint:disable:forin */
function containsTree(container, containee, exact) {
    if (exact) {
        return equalSegmentGroups(container.root, containee.root);
    }
    else {
        return containsSegmentGroup(container.root, containee.root);
    }
}
function equalSegmentGroups(container, containee) {
    if (!equalPath(container.segments, containee.segments)) {
        return false;
    }
    if (container.numberOfChildren !== containee.numberOfChildren) {
        return false;
    }
    for (let c in containee.children) {
        if (!container.children[c]) {
            return false;
        }
        if (!equalSegmentGroups(container.children[c], containee.children[c])) {
            return false;
        }
    }
    return true;
}
function containsSegmentGroup(container, containee) {
    return containsSegmentGroupHelper(container, containee, containee.segments);
}
function containsSegmentGroupHelper(container, containee, containeePaths) {
    if (container.segments.length > containeePaths.length) {
        const current = container.segments.slice(0, containeePaths.length);
        if (!equalPath(current, containeePaths)) {
            return false;
        }
        if (containee.hasChildren()) {
            return false;
        }
        return true;
    }
    else if (container.segments.length === containeePaths.length) {
        if (!equalPath(container.segments, containeePaths)) {
            return false;
        }
        for (let c in containee.children) {
            if (!container.children[c]) {
                return false;
            }
            if (!containsSegmentGroup(container.children[c], containee.children[c])) {
                return false;
            }
        }
        return true;
    }
    else {
        const current = containeePaths.slice(0, container.segments.length);
        const next = containeePaths.slice(container.segments.length);
        if (!equalPath(container.segments, current)) {
            return false;
        }
        if (!container.children[PRIMARY_OUTLET]) {
            return false;
        }
        return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);
    }
}
function equalPath(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; ++i) {
        if (a[i].path !== b[i].path) {
            return false;
        }
    }
    return true;
}

/**
 * The NSRouterLinkActive directive lets you add a CSS class to an element when the link"s route
 * becomes active.
 *
 * Consider the following example:
 *
 * ```
 * <a [nsRouterLink]="/user/bob" [nsRouterLinkActive]="active-link">Bob</a>
 * ```
 *
 * When the url is either "/user" or "/user/bob", the active-link class will
 * be added to the component. If the url changes, the class will be removed.
 *
 * You can set more than one class, as follows:
 *
 * ```
 * <a [nsRouterLink]="/user/bob" [nsRouterLinkActive]="class1 class2">Bob</a>
 * <a [nsRouterLink]="/user/bob" [nsRouterLinkActive]="["class1", "class2"]">Bob</a>
 * ```
 *
 * You can configure NSRouterLinkActive by passing `exact: true`. This will add the
 * classes only when the url matches the link exactly.
 *
 * ```
 * <a [nsRouterLink]="/user/bob" [nsRouterLinkActive]="active-link"
 * [nsRouterLinkActiveOptions]="{exact: true}">Bob</a>
 * ```
 *
 * Finally, you can apply the NSRouterLinkActive directive to an ancestor of a RouterLink.
 *
 * ```
 * <div [nsRouterLinkActive]="active-link" [nsRouterLinkActiveOptions]="{exact: true}">
 *   <a [nsRouterLink]="/user/jim">Jim</a>
 *   <a [nsRouterLink]="/user/bob">Bob</a>
 * </div>
 * ```
 *
 * This will set the active-link class on the div tag if the url is either "/user/jim" or
 * "/user/bob".
 *
 * @stable
 */
class NSRouterLinkActive {
    constructor(router, element, renderer) {
        this.router = router;
        this.element = element;
        this.renderer = renderer;
        this.classes = [];
        this.active = false;
        this.nsRouterLinkActiveOptions = { exact: false };
        this.subscription = router.events.subscribe((s) => {
            if (s instanceof NavigationEnd) {
                this.update();
            }
        });
    }
    get isActive() {
        return this.active;
    }
    ngAfterContentInit() {
        this.links.changes.subscribe(() => this.update());
        this.update();
    }
    set nsRouterLinkActive(data) {
        if (Array.isArray(data)) {
            this.classes = data;
        }
        else {
            this.classes = data.split(' ');
        }
    }
    ngOnChanges(_) {
        this.update();
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    update() {
        if (!this.links) {
            return;
        }
        const hasActiveLinks = this.hasActiveLinks();
        // react only when status has changed to prevent unnecessary dom updates
        if (this.active !== hasActiveLinks) {
            const currentUrlTree = this.router.parseUrl(this.router.url);
            const isActiveLinks = this.reduceList(currentUrlTree, this.links);
            this.classes.forEach((c) => this.renderer.setStyle(this.element.nativeElement, c, isActiveLinks));
        }
        Promise.resolve(hasActiveLinks).then((active) => (this.active = active));
    }
    reduceList(currentUrlTree, q) {
        return q.reduce((res, link) => {
            return res || containsTree(currentUrlTree, link.urlTree, this.nsRouterLinkActiveOptions.exact);
        }, false);
    }
    isLinkActive(router) {
        return (link) => router.isActive(link.urlTree, this.nsRouterLinkActiveOptions.exact);
    }
    hasActiveLinks() {
        return this.links.some(this.isLinkActive(this.router));
    }
}
NSRouterLinkActive.decorators = [
    { type: Directive, args: [{
                selector: '[nsRouterLinkActive]',
                exportAs: 'routerLinkActive',
            },] }
];
NSRouterLinkActive.ctorParameters = () => [
    { type: Router },
    { type: ElementRef },
    { type: Renderer2 }
];
NSRouterLinkActive.propDecorators = {
    links: [{ type: ContentChildren, args: [NSRouterLink,] }],
    nsRouterLinkActiveOptions: [{ type: Input }],
    nsRouterLinkActive: [{ type: Input, args: ['nsRouterLinkActive',] }]
};

const getSnapshotKey = function (snapshot) {
    return snapshot.pathFromRoot.join('->');
};
const ɵ0$5 = getSnapshotKey;
/**
 * Detached state cache
 */
class DetachedStateCache {
    constructor() {
        this.cache = new Array();
    }
    get length() {
        return this.cache.length;
    }
    push(cacheItem) {
        this.cache.push(cacheItem);
    }
    pop() {
        return this.cache.pop();
    }
    peek() {
        return this.cache[this.cache.length - 1];
    }
    clear() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routeReuseStrategyLog(`DetachedStateCache.clear() ${this.cache.length} items will be destroyed`);
        }
        while (this.cache.length > 0) {
            const state = this.cache.pop().state;
            if (!state.componentRef) {
                throw new Error('No componentRed found in DetachedRouteHandle');
            }
            destroyComponentRef(state.componentRef);
        }
    }
    clearModalCache() {
        let removedItemsCount = 0;
        const hasModalPages = this.cache.some((cacheItem) => {
            return cacheItem.isModal;
        });
        if (hasModalPages) {
            let modalCacheCleared = false;
            while (!modalCacheCleared) {
                let cacheItem = this.peek();
                const state = cacheItem.state;
                if (!state.componentRef) {
                    throw new Error('No componentRef found in DetachedRouteHandle');
                }
                destroyComponentRef(state.componentRef);
                if (cacheItem.isModal) {
                    modalCacheCleared = true;
                }
                this.pop();
                removedItemsCount++;
            }
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routeReuseStrategyLog(`DetachedStateCache.clearModalCache() ${removedItemsCount} items will be destroyed`);
        }
    }
}
/**
 * Detaches subtrees loaded inside PageRouterOutlet in forward navigation
 * and reattaches them on back.
 * Reuses routes as long as their route config is the same.
 */
class NSRouteReuseStrategy {
    constructor(location) {
        this.location = location;
        this.cacheByOutlet = {};
    }
    shouldDetach(route) {
        route = findTopActivatedRouteNodeForOutlet(route);
        const outletKey = this.location.getRouteFullPath(route);
        const outlet = this.location.findOutlet(outletKey, route);
        const key = getSnapshotKey(route);
        const isPageActivated = route[pageRouterActivatedSymbol];
        const isBack = outlet ? outlet.isPageNavigationBack : false;
        let shouldDetach = outlet && !isBack && isPageActivated;
        if (outlet) {
            if (outlet.parent && !outlet.parent.shouldDetach) {
                shouldDetach = false;
            }
            outlet.shouldDetach = shouldDetach;
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routeReuseStrategyLog(`shouldDetach isBack: ${isBack} key: ${key} result: ${shouldDetach}`);
        }
        return shouldDetach;
    }
    shouldAttach(route) {
        route = findTopActivatedRouteNodeForOutlet(route);
        const outletKey = this.location.getRouteFullPath(route);
        const outlet = this.location.findOutlet(outletKey, route);
        const cache = this.cacheByOutlet[outletKey];
        if (!cache) {
            return false;
        }
        const key = getSnapshotKey(route);
        const isBack = outlet ? outlet.isPageNavigationBack : false;
        const shouldAttach = isBack && cache.peek().key === key;
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routeReuseStrategyLog(`shouldAttach isBack: ${isBack} key: ${key} result: ${shouldAttach}`);
        }
        if (outlet) {
            outlet.shouldDetach = true;
        }
        return shouldAttach;
    }
    store(route, state) {
        route = findTopActivatedRouteNodeForOutlet(route);
        const key = getSnapshotKey(route);
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routeReuseStrategyLog(`store key: ${key}, state: ${state}`);
        }
        const outletKey = this.location.getRouteFullPath(route);
        // tslint:disable-next-line:max-line-length
        const cache = (this.cacheByOutlet[outletKey] = this.cacheByOutlet[outletKey] || new DetachedStateCache());
        if (state) {
            let isModal = false;
            if (this.location._modalNavigationDepth > 0) {
                isModal = true;
            }
            cache.push({ key, state, isModal });
        }
        else {
            const topItem = cache.peek();
            if (topItem.key === key) {
                cache.pop();
                if (!cache.length) {
                    delete this.cacheByOutlet[outletKey];
                }
            }
            else {
                throw new Error("Trying to pop from DetachedStateCache but keys don't match. " + `expected: ${topItem.key} actual: ${key}`);
            }
        }
    }
    retrieve(route) {
        route = findTopActivatedRouteNodeForOutlet(route);
        const outletKey = this.location.getRouteFullPath(route);
        const outlet = this.location.findOutlet(outletKey, route);
        const cache = this.cacheByOutlet[outletKey];
        if (!cache) {
            return null;
        }
        const key = getSnapshotKey(route);
        const isBack = outlet ? outlet.isPageNavigationBack : false;
        const cachedItem = cache.peek();
        let state = null;
        if (isBack && cachedItem && cachedItem.key === key) {
            state = cachedItem.state;
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routeReuseStrategyLog(`retrieved isBack: ${isBack} key: ${key} state: ${state}`);
        }
        return state;
    }
    shouldReuseRoute(future, curr) {
        const shouldReuse = future.routeConfig === curr.routeConfig;
        if (shouldReuse && curr && curr[pageRouterActivatedSymbol]) {
            // When reusing route - copy the pageRouterActivated to the new snapshot
            // It's needed in shouldDetach to determine if the route should be detached.
            future[pageRouterActivatedSymbol] = curr[pageRouterActivatedSymbol];
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routeReuseStrategyLog(`shouldReuseRoute result: ${shouldReuse}`);
        }
        return shouldReuse;
    }
    clearCache(outletKey) {
        const cache = this.cacheByOutlet[outletKey];
        if (cache) {
            cache.clear();
        }
    }
    clearModalCache(outletKey) {
        const cache = this.cacheByOutlet[outletKey];
        if (cache) {
            cache.clearModalCache();
        }
    }
}
NSRouteReuseStrategy.decorators = [
    { type: Injectable }
];
NSRouteReuseStrategy.ctorParameters = () => [
    { type: NSLocationStrategy }
];

class PageRoute {
    constructor(startRoute) {
        this.activatedRoute = new BehaviorSubject(startRoute);
    }
}
class DestructibleInjector {
    constructor(destructableProviders, parent) {
        this.destructableProviders = destructableProviders;
        this.parent = parent;
        this.refs = new Set();
    }
    get(token, notFoundValue, flags) {
        const ref = this.parent.get(token, notFoundValue, flags);
        if (this.destructableProviders.has(token)) {
            this.refs.add(ref);
        }
        return ref;
    }
    destroy() {
        this.refs.forEach((ref) => {
            if (ref.ngOnDestroy instanceof Function) {
                ref.ngOnDestroy();
            }
        });
        this.refs.clear();
    }
}
const routeToString = function (activatedRoute) {
    return activatedRoute.pathFromRoot.join('->');
};
const ɵ0$6 = routeToString;
class PageRouterOutlet {
    constructor(parentContexts, location, name, actionBarVisibility, isEmptyOutlet, locationStrategy, componentFactoryResolver, resolver, changeDetector, pageFactory, routeReuseStrategy, ngZone, elRef) {
        this.parentContexts = parentContexts;
        this.location = location;
        this.locationStrategy = locationStrategy;
        this.componentFactoryResolver = componentFactoryResolver;
        this.resolver = resolver;
        this.changeDetector = changeDetector;
        this.pageFactory = pageFactory;
        this.routeReuseStrategy = routeReuseStrategy;
        this.ngZone = ngZone;
        // tslint:disable-line:directive-class-suffix
        this.activated = null;
        this._activatedRoute = null;
        this.activateEvents = new EventEmitter(); // tslint:disable-line:no-output-rename
        this.deactivateEvents = new EventEmitter(); // tslint:disable-line:no-output-rename
        this.isEmptyOutlet = isEmptyOutlet;
        this.frame = elRef.nativeElement;
        this.setActionBarVisibility(actionBarVisibility);
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog(`PageRouterOutlet.constructor frame: ${this.frame}`);
        }
        this.name = name || PRIMARY_OUTLET;
        parentContexts.onChildOutletCreated(this.name, this);
        this.viewUtil = new ViewUtil(Device);
        this.detachedLoaderFactory = resolver.resolveComponentFactory(DetachedLoader);
    }
    /** @deprecated from Angular since v4 */
    get locationInjector() {
        return this.location.injector;
    }
    /** @deprecated from Angular since v4 */
    get locationFactoryResolver() {
        return this.resolver;
    }
    get isActivated() {
        return !!this.activated;
    }
    get component() {
        if (!this.activated) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('Outlet is not activated');
            }
            return;
        }
        return this.activated.instance;
    }
    get activatedRoute() {
        if (!this.activated) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('Outlet is not activated');
            }
            return;
        }
        return this._activatedRoute;
    }
    setActionBarVisibility(actionBarVisibility) {
        switch (actionBarVisibility) {
            case 'always':
            case 'never':
                this.frame.actionBarVisibility = actionBarVisibility;
                return;
            default:
                this.frame.actionBarVisibility = 'auto';
        }
    }
    ngOnDestroy() {
        // Clear accumulated modal view page cache when page-router-outlet
        // destroyed on modal view closing
        this.parentContexts.onChildOutletDestroyed(this.name);
        if (this.outlet) {
            this.outlet.outletKeys.forEach((key) => {
                this.routeReuseStrategy.clearModalCache(key);
            });
            this.locationStrategy.clearOutlet(this.frame);
        }
        else {
            NativeScriptDebug.routerLog('PageRouterOutlet.ngOnDestroy: no outlet available for page-router-outlet');
        }
        if (this.isActivated) {
            const c = this.activated.instance;
            this.activated.hostView.detach();
            destroyComponentRef(this.activated);
            this.deactivateEvents.emit(c);
            this.activated = null;
        }
    }
    deactivate() {
        if (!this.outlet || !this.outlet.isPageNavigationBack) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('Currently not in page back navigation - component should be detached instead of deactivated.');
            }
            return;
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('PageRouterOutlet.deactivate() while going back - should destroy');
        }
        if (!this.isActivated) {
            return;
        }
        const c = this.activated.instance;
        destroyComponentRef(this.activated);
        this.activated = null;
        this._activatedRoute = null;
        this.deactivateEvents.emit(c);
    }
    /**
     * Called when the `RouteReuseStrategy` instructs to detach the subtree
     */
    detach() {
        if (!this.isActivated) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('Outlet is not activated');
            }
            return;
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog(`PageRouterOutlet.detach() - ${routeToString(this._activatedRoute)}`);
        }
        // Detach from ChangeDetection
        this.activated.hostView.detach();
        const component = this.activated;
        this.activated = null;
        this._activatedRoute = null;
        return component;
    }
    /**
     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
     */
    attach(ref, activatedRoute) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog(`PageRouterOutlet.attach() - ${routeToString(activatedRoute)}`);
        }
        this.activated = ref;
        // reattach to ChangeDetection
        this.activated.hostView.markForCheck();
        this.activated.hostView.reattach();
        this._activatedRoute = activatedRoute;
        this.markActivatedRoute(activatedRoute);
        this.locationStrategy._finishBackPageNavigation(this.frame);
    }
    /**
     * Called by the Router to instantiate a new component during the commit phase of a navigation.
     * This method in turn is responsible for calling the `routerOnActivate` hook of its child.
     */
    activateWith(activatedRoute, resolver) {
        this.outlet = this.outlet || this.getOutlet(activatedRoute.snapshot);
        if (!this.outlet) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerError('No outlet found relative to activated route');
            }
            return;
        }
        this.outlet.isNSEmptyOutlet = this.isEmptyOutlet;
        this.locationStrategy.updateOutletFrame(this.outlet, this.frame, this.isEmptyOutlet);
        if (this.outlet && this.outlet.isPageNavigationBack) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('Currently in page back navigation - component should be reattached instead of activated.');
            }
            this.locationStrategy._finishBackPageNavigation(this.frame);
        }
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog(`PageRouterOutlet.activateWith() - ${routeToString(activatedRoute)}`);
        }
        this._activatedRoute = activatedRoute;
        this.markActivatedRoute(activatedRoute);
        resolver = resolver || this.resolver;
        this.activateOnGoForward(activatedRoute, resolver);
        this.activateEvents.emit(this.activated.instance);
    }
    activateOnGoForward(activatedRoute, loadedResolver) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('PageRouterOutlet.activate() forward navigation - ' + 'create detached loader in the loader container');
        }
        const factory = this.getComponentFactory(activatedRoute, loadedResolver);
        const page = this.pageFactory({
            isNavigation: true,
            componentType: factory.componentType,
        });
        const destructables = new Set([]);
        const injector = Injector.create({
            providers: [
                { provide: Page, useValue: page },
                { provide: Frame, useValue: this.frame },
                { provide: PageRoute, useValue: new PageRoute(activatedRoute) },
                { provide: ActivatedRoute, useValue: activatedRoute },
                { provide: ChildrenOutletContexts, useValue: this.parentContexts.getOrCreateContext(this.name).children },
            ],
            parent: this.location.injector,
        });
        const childInjector = new DestructibleInjector(destructables, injector);
        const loaderRef = this.location.createComponent(this.detachedLoaderFactory, this.location.length, childInjector, []);
        loaderRef.onDestroy(() => childInjector.destroy());
        this.changeDetector.markForCheck();
        this.activated = loaderRef.instance.loadWithFactory(factory);
        this.loadComponentInPage(page, this.activated, { activatedRoute });
        this.activated[loaderRefSymbol] = loaderRef;
    }
    loadComponentInPage(page, componentRef, navigationContext) {
        // Component loaded. Find its root native view.
        const componentView = componentRef.location.nativeElement;
        // Remove it from original native parent.
        this.viewUtil.removeChild(componentView.parent, componentView);
        // Add it to the new page
        this.viewUtil.insertChild(page, componentView);
        const navigatedFromCallback = global.Zone.current.wrap((args) => {
            if (args.isBackNavigation) {
                this.locationStrategy._beginBackPageNavigation(this.frame);
                this.locationStrategy.back(null, this.frame);
            }
        });
        // TODO: experiment with using NgZone instead of global above
        // const navigatedFromCallback = (args: NavigatedData) => {
        // 	if (args.isBackNavigation) {
        //     this.ngZone.run(() => {
        //       this.locationStrategy._beginBackPageNavigation(this.frame);
        //       this.locationStrategy.back(null, this.frame);
        //     });
        // 	}
        // };
        page.on(Page.navigatedFromEvent, navigatedFromCallback);
        componentRef.onDestroy(() => {
            if (page) {
                page.off(Page.navigatedFromEvent, navigatedFromCallback);
                page = null;
            }
        });
        const navOptions = this.locationStrategy._beginPageNavigation(this.frame);
        // Clear refCache if navigation with clearHistory
        if (navOptions.clearHistory) {
            const clearCallback = () => setTimeout(() => {
                if (this.outlet) {
                    this.routeReuseStrategy.clearCache(this.outlet.outletKeys[0]);
                }
            });
            page.once(Page.navigatedToEvent, clearCallback);
        }
        this.frame.navigate({
            create() {
                return page;
            },
            context: navigationContext,
            clearHistory: navOptions.clearHistory,
            animated: navOptions.animated,
            transition: navOptions.transition,
        });
    }
    // Find and mark the top activated route as an activated one.
    // In ns-location-strategy we are reusing components only if their corresponing routes
    // are marked as activated from this method.
    markActivatedRoute(activatedRoute) {
        const queue = [];
        queue.push(activatedRoute.snapshot);
        let currentRoute = queue.shift();
        while (currentRoute) {
            currentRoute.children.forEach((childRoute) => {
                queue.push(childRoute);
            });
            const topActivatedRoute = findTopActivatedRouteNodeForOutlet(currentRoute);
            let outletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute);
            let outlet = this.locationStrategy.findOutlet(outletKey, topActivatedRoute);
            if (outlet && outlet.frames.length) {
                topActivatedRoute[pageRouterActivatedSymbol] = true;
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerLog('Activated route marked as page: ' + routeToString(topActivatedRoute));
                }
            }
            currentRoute = queue.shift();
        }
    }
    getComponentFactory(activatedRoute, loadedResolver) {
        const { component } = activatedRoute.routeConfig;
        return loadedResolver ? loadedResolver.resolveComponentFactory(component) : this.componentFactoryResolver.resolveComponentFactory(component);
    }
    getOutlet(activatedRouteSnapshot) {
        const topActivatedRoute = findTopActivatedRouteNodeForOutlet(activatedRouteSnapshot);
        const outletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute);
        let outlet = this.locationStrategy.findOutlet(outletKey, topActivatedRoute);
        // Named lazy loaded outlet.
        if (!outlet && this.isEmptyOutlet) {
            const parentOutletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute.parent);
            outlet = this.locationStrategy.findOutlet(parentOutletKey, topActivatedRoute.parent);
            if (outlet) {
                outlet.outletKeys.push(outletKey);
            }
        }
        return outlet;
    }
}
PageRouterOutlet.decorators = [
    { type: Directive, args: [{ selector: 'page-router-outlet' },] }
];
PageRouterOutlet.ctorParameters = () => [
    { type: ChildrenOutletContexts },
    { type: ViewContainerRef },
    { type: String, decorators: [{ type: Attribute, args: ['name',] }] },
    { type: String, decorators: [{ type: Attribute, args: ['actionBarVisibility',] }] },
    { type: Boolean, decorators: [{ type: Attribute, args: ['isEmptyOutlet',] }] },
    { type: NSLocationStrategy },
    { type: ComponentFactoryResolver },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Inject, args: [PAGE_FACTORY,] }] },
    { type: NSRouteReuseStrategy },
    { type: NgZone },
    { type: ElementRef }
];
PageRouterOutlet.propDecorators = {
    activateEvents: [{ type: Output, args: ['activate',] }],
    deactivateEvents: [{ type: Output, args: ['deactivate',] }]
};
__decorate([
    profile
], PageRouterOutlet.prototype, "activateWith", null);
__decorate([
    profile
], PageRouterOutlet.prototype, "loadComponentInPage", null);

class NativescriptPlatformLocation extends PlatformLocation {
    constructor(locationStrategy) {
        super();
        this.locationStrategy = locationStrategy;
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.routerLog('NativescriptPlatformLocation.constructor()');
        }
    }
    getState() {
        return undefined;
    }
    getBaseHrefFromDOM() {
        return '/';
    }
    onPopState(fn) {
        this.locationStrategy.onPopState(fn);
    }
    onHashChange(_fn) { }
    get search() {
        return '';
    }
    get hash() {
        return '';
    }
    get pathname() {
        return this.locationStrategy.path();
    }
    set pathname(_newPath) {
        throw new Error('NativescriptPlatformLocation set pathname - not implemented');
    }
    pushState(state, title, url) {
        this.locationStrategy.pushState(state, title, url, null);
    }
    replaceState(state, title, url) {
        this.locationStrategy.replaceState(state, title, url, null);
    }
    forward() {
        throw new Error('NativescriptPlatformLocation.forward() - not implemented');
    }
    back() {
        this.locationStrategy.back();
    }
}
NativescriptPlatformLocation.decorators = [
    { type: Injectable }
];
NativescriptPlatformLocation.ctorParameters = () => [
    { type: NSLocationStrategy }
];

class NSEmptyOutletComponent {
    constructor(page) {
        this.page = page;
        if (this.page) {
            this.page.actionBarHidden = true;
            this.page.on('loaded', () => {
                if (this.pageRouterOutlet && this.page.frame) {
                    this.pageRouterOutlet.setActionBarVisibility(this.page.frame.actionBarVisibility);
                }
            });
        }
    }
}
NSEmptyOutletComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'ns-empty-outlet',
                template: "<page-router-outlet isEmptyOutlet='true'></page-router-outlet>"
            },] }
];
NSEmptyOutletComponent.ctorParameters = () => [
    { type: Page }
];
NSEmptyOutletComponent.propDecorators = {
    pageRouterOutlet: [{ type: ViewChild, args: [PageRouterOutlet, { read: PageRouterOutlet, static: false },] }]
};

class NSModuleFactoryLoader extends SystemJsNgModuleLoader {
    constructor(compiler, config) {
        super(compiler, config);
        console.log(`NSModuleFactoryLoader is deprecated! ` + `You no longer need to provide it as a module loader.`);
    }
}
NSModuleFactoryLoader.decorators = [
    { type: Injectable }
];
NSModuleFactoryLoader.ctorParameters = () => [
    { type: Compiler },
    { type: SystemJsNgModuleLoaderConfig, decorators: [{ type: Optional }] }
];

function provideLocationStrategy(locationStrategy, frameService) {
    return locationStrategy ? locationStrategy : new NSLocationStrategy(frameService);
}
class NativeScriptRouterModule {
    static forRoot(routes, config) {
        return {
            ngModule: NativeScriptRouterModule,
            providers: [
                ...RouterModule.forRoot(routes, config).providers,
                {
                    provide: NSLocationStrategy,
                    useFactory: provideLocationStrategy,
                    deps: [[NSLocationStrategy, new Optional(), new SkipSelf()], FrameService],
                },
                { provide: LocationStrategy, useExisting: NSLocationStrategy },
                NativescriptPlatformLocation,
                { provide: PlatformLocation, useExisting: NativescriptPlatformLocation },
                RouterExtensions,
                NSRouteReuseStrategy,
                { provide: RouteReuseStrategy, useExisting: NSRouteReuseStrategy },
            ],
        };
    }
    static forChild(routes) {
        return { ngModule: NativeScriptRouterModule, providers: RouterModule.forChild(routes).providers };
    }
}
NativeScriptRouterModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NSRouterLink, NSRouterLinkActive, PageRouterOutlet, NSEmptyOutletComponent],
                entryComponents: [NSEmptyOutletComponent],
                imports: [RouterModule, NativeScriptCommonModule],
                exports: [RouterModule, NSRouterLink, NSRouterLinkActive, PageRouterOutlet, NSEmptyOutletComponent],
                schemas: [NO_ERRORS_SCHEMA],
            },] }
];

// Initial imports and polyfills

/**
 * Generated bundle index. Do not edit.
 */

export { APP_ROOT_VIEW, ActionBarComponent, ActionBarScope, ActionItemDirective, AndroidFilterComponent, AppHostAsyncView, AppHostView, BaseValueAccessor, COMMON_PROVIDERS, CheckedValueAccessor, CommentNode, DateValueAccessor, DetachedLoader, DeviceToken, EmulatedRenderer, FileSystemResourceLoader, FrameService, IosFilterComponent, ListViewComponent, ModalDialogParams, ModalDialogService, NSEmptyOutletComponent, NSFileSystem, NSLocationStrategy, NSModuleFactoryLoader, NSRouterLink, NSRouterLinkActive, NS_DIRECTIVES, NativeScriptAnimationsModule, NativeScriptCommonModule, NativeScriptDebug, NativeScriptDocument, NativeScriptFormsModule, NativeScriptHttpClientModule, NativeScriptModule, NativeScriptPlatformRef, NativeScriptRenderer, NativeScriptRendererFactory, NativeScriptRouterModule, NativeScriptSanitizer, NavigationButtonDirective, NsHttpBackEnd, NumberValueAccessor, Outlet, PAGE_FACTORY, PageRoute, PageRouterOutlet, RouterExtensions, SelectedIndexValueAccessor, TabViewDirective, TabViewItemDirective, TemplateKeyDirective, TemplatedItemsComponent, TextValueAccessor, TimeValueAccessor, defaultDeviceProvider, defaultFrameProvider, defaultNavOptions, defaultPageFactory, defaultPageFactoryProvider, defaultPageProvider, errorHandlerFactory, getDefaultDevice, getDefaultFrame, getDefaultPage, getRootPage, getSingleViewRecursive, getViewClass, getViewMeta, isInvisibleNode, isKnownView, isView, onAfterLivesync, onBeforeLivesync, once, platformNativeScriptDynamic, provideLocationStrategy, registerElement, setRootPage, throwIfAlreadyLoaded, InvisibleNode as ɵa, NSFileSystem as ɵb, ListViewComponent as ɵc, TemplatedItemsComponent as ɵd, TEMPLATED_ITEMS_COMPONENT as ɵe, TemplateKeyDirective as ɵf, TabViewDirective as ɵg, TabViewItemDirective as ɵh, ActionBarComponent as ɵi, ActionBarScope as ɵj, ActionItemDirective as ɵk, NavigationButtonDirective as ɵl, AndroidFilterComponent as ɵm, IosFilterComponent as ɵn, ModalDialogService as ɵo, NSLocationStrategy as ɵp, ViewUtil as ɵq };
//# sourceMappingURL=nativescript-angular.js.map
