import { TestBed } from '@angular/core/testing';
import { NativeScriptModule } from '@nativescript/angular';
import { platformBrowserDynamicTesting } from '@angular/platform-browser-dynamic/testing';
// import { NS_COMPILER_PROVIDERS } from "../../platform";
import { NativeScriptTestingModule } from './nativescript-testing.module';
import { testingRootView } from './test-root-view';
/**
 * Declared test contexts. When the suite is done this map should be empty if all lifecycle
 * calls have happened as expected.
 * @private
 */
const activeTestFixtures = [];
/**
 * Return a promise that resolves after (durationMs) milliseconds
 */
export function promiseWait(durationMs) {
    return () => new Promise((resolve) => setTimeout(() => resolve(), durationMs));
}
/**
 * Perform basic TestBed environment initialization. Call this once in the main entry point to your tests.
 */
export function nsTestBedInit() {
    TestBed.initTestEnvironment(NativeScriptTestingModule, platformBrowserDynamicTesting() // NS_COMPILER_PROVIDERS)
    );
}
/**
 * Helper for configuring a TestBed instance for rendering components for test. Ideally this
 * would not be needed, and in truth it's just a wrapper to eliminate some boilerplate. It
 * exists because when you need to specify `entryComponents` for a test the setup becomes quite
 * a bit more complex than if you're just doing a basic component test.
 *
 * More about entryComponents complexity: https://github.com/angular/angular/issues/12079
 *
 * Use:
 * ```
 *   beforeEach(nsTestBedBeforeEach([MyComponent,MyFailComponent]));
 * ```
 *
 * **NOTE*** Remember to pair with {@see nsTestBedAfterEach}
 *
 * @param components Any components that you will create during the test
 * @param providers Any services your tests depend on
 * @param imports Any module imports your tests depend on
 * @param entryComponents Any entry components that your tests depend on
 */
export function nsTestBedBeforeEach(components, providers = [], imports = [], entryComponents = []) {
    return (done) => {
        activeTestFixtures.push([]);
        // If there are no entry components we can take the simple path.
        if (entryComponents.length === 0) {
            TestBed.configureTestingModule({
                declarations: [...components],
                providers: [...providers],
                imports: [NativeScriptModule, ...imports],
            });
        }
        else {
            // If there are entry components, we have to reset the testing platform.
            //
            // There's got to be a better way... (o_O)
            // TestBed.resetTestEnvironment();
            // @NgModule({
            //     declarations: entryComponents,
            //     exports: entryComponents,
            //     entryComponents: entryComponents
            // })
            // class EntryComponentsTestModule {
            // }
            // TestBed.initTestEnvironment(
            //     EntryComponentsTestModule,
            //     platformBrowserDynamicTesting(NS_COMPILER_PROVIDERS)
            // );
            // TestBed.configureTestingModule({
            //     declarations: components,
            //     imports: [
            //         NativeScriptModule, NativeScriptTestingModule, CommonModule,
            //         ...imports
            //     ],
            //     providers: [...providers, ...NATIVESCRIPT_TESTING_PROVIDERS],
            // });
        }
        TestBed.compileComponents()
            .then(() => done())
            .catch((e) => {
            console.log(`Failed to instantiate test component with error: ${e}`);
            console.log(e.stack);
            done();
        });
    };
}
/**
 * Helper for a basic component TestBed clean up.
 * @param resetEnv When true the testing environment will be reset
 * @param resetFn When resetting the environment, use this init function
 */
export function nsTestBedAfterEach(resetEnv = true, resetFn = nsTestBedInit) {
    return () => {
        if (activeTestFixtures.length === 0) {
            throw new Error(`There are no more declared fixtures.` + `Did you call "nsTestBedBeforeEach" and "nsTestBedAfterEach" an equal number of times?`);
        }
        const root = testingRootView();
        const fixtures = activeTestFixtures.pop();
        fixtures.forEach((fixture) => {
            const fixtureView = fixture.nativeElement;
            if (fixtureView.parent === root) {
                root.removeChild(fixtureView);
            }
            fixture.destroy();
        });
        TestBed.resetTestingModule();
        if (resetEnv) {
            TestBed.resetTestEnvironment();
            resetFn();
        }
    };
}
/**
 * Render a component using the TestBed helper, and return a promise that resolves when the
 * ComponentFixture is fully initialized.
 */
export function nsTestBedRender(componentType) {
    const fixture = TestBed.createComponent(componentType);
    fixture.detectChanges();
    return (fixture
        .whenRenderingDone()
        // TODO(jd): it seems that the whenStable and whenRenderingDone utilities of ComponentFixture
        //           do not work as expected. I looked at how to fix it and it's not clear how to provide
        //           a {N} specific subclass, because ComponentFixture is newed directly rather than injected
        // What to do about it? Maybe fakeAsync can help? For now just setTimeout for 100ms (x_X)
        .then(promiseWait(100))
        .then(() => {
        const list = activeTestFixtures[activeTestFixtures.length - 1];
        if (!list) {
            console.warn('nsTestBedRender called without nsTestBedBeforeEach/nsTestBedAfter each. ' + "You are responsible for calling 'fixture.destroy()' when your test is done " + 'in order to clean up the components that are created.');
        }
        else {
            list.push(fixture);
        }
        return fixture;
    }));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3Rlc3Rpbmcvc3JjL3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFvQixPQUFPLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUVsRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSwyQ0FBMkMsQ0FBQztBQUMxRiwwREFBMEQ7QUFDMUQsT0FBTyxFQUFrQyx5QkFBeUIsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBQzFHLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUVuRDs7OztHQUlHO0FBQ0gsTUFBTSxrQkFBa0IsR0FBOEIsRUFBRSxDQUFDO0FBRXpEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLFdBQVcsQ0FBQyxVQUFrQjtJQUM3QyxPQUFPLEdBQUcsRUFBRSxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQztBQUNoRixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLFVBQVUsYUFBYTtJQUM1QixPQUFPLENBQUMsbUJBQW1CLENBQzFCLHlCQUF5QixFQUN6Qiw2QkFBNkIsRUFBRSxDQUFDLHlCQUF5QjtLQUN6RCxDQUFDO0FBQ0gsQ0FBQztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUJHO0FBQ0gsTUFBTSxVQUFVLG1CQUFtQixDQUFDLFVBQWlCLEVBQUUsWUFBbUIsRUFBRSxFQUFFLFVBQWlCLEVBQUUsRUFBRSxrQkFBeUIsRUFBRTtJQUM3SCxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUU7UUFDZixrQkFBa0IsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDNUIsZ0VBQWdFO1FBQ2hFLElBQUksZUFBZSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDakMsT0FBTyxDQUFDLHNCQUFzQixDQUFDO2dCQUM5QixZQUFZLEVBQUUsQ0FBQyxHQUFHLFVBQVUsQ0FBQztnQkFDN0IsU0FBUyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUM7Z0JBQ3pCLE9BQU8sRUFBRSxDQUFDLGtCQUFrQixFQUFFLEdBQUcsT0FBTyxDQUFDO2FBQ3pDLENBQUMsQ0FBQztTQUNIO2FBQU07WUFDTix3RUFBd0U7WUFDeEUsRUFBRTtZQUNGLDBDQUEwQztZQUMxQyxrQ0FBa0M7WUFDbEMsY0FBYztZQUNkLHFDQUFxQztZQUNyQyxnQ0FBZ0M7WUFDaEMsdUNBQXVDO1lBQ3ZDLEtBQUs7WUFDTCxvQ0FBb0M7WUFDcEMsSUFBSTtZQUNKLCtCQUErQjtZQUMvQixpQ0FBaUM7WUFDakMsMkRBQTJEO1lBQzNELEtBQUs7WUFDTCxtQ0FBbUM7WUFDbkMsZ0NBQWdDO1lBQ2hDLGlCQUFpQjtZQUNqQix1RUFBdUU7WUFDdkUscUJBQXFCO1lBQ3JCLFNBQVM7WUFDVCxvRUFBb0U7WUFDcEUsTUFBTTtTQUNOO1FBQ0QsT0FBTyxDQUFDLGlCQUFpQixFQUFFO2FBQ3pCLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQzthQUNsQixLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUNaLE9BQU8sQ0FBQyxHQUFHLENBQUMsb0RBQW9ELENBQUMsRUFBRSxDQUFDLENBQUM7WUFDckUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDckIsSUFBSSxFQUFFLENBQUM7UUFDUixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQztBQUNILENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLGtCQUFrQixDQUFDLFFBQVEsR0FBRyxJQUFJLEVBQUUsT0FBTyxHQUFHLGFBQWE7SUFDMUUsT0FBTyxHQUFHLEVBQUU7UUFDWCxJQUFJLGtCQUFrQixDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDcEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQ0FBc0MsR0FBRyx1RkFBdUYsQ0FBQyxDQUFDO1NBQ2xKO1FBQ0QsTUFBTSxJQUFJLEdBQUcsZUFBZSxFQUFnQixDQUFDO1FBQzdDLE1BQU0sUUFBUSxHQUFHLGtCQUFrQixDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUM1QixNQUFNLFdBQVcsR0FBUyxPQUFPLENBQUMsYUFBYSxDQUFDO1lBQ2hELElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSyxJQUFJLEVBQUU7Z0JBQ2hDLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDOUI7WUFDRCxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDbkIsQ0FBQyxDQUFDLENBQUM7UUFDSCxPQUFPLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUM3QixJQUFJLFFBQVEsRUFBRTtZQUNiLE9BQU8sQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1lBQy9CLE9BQU8sRUFBRSxDQUFDO1NBQ1Y7SUFDRixDQUFDLENBQUM7QUFDSCxDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLGVBQWUsQ0FBSSxhQUFzQjtJQUN4RCxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3ZELE9BQU8sQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUN4QixPQUFPLENBQ04sT0FBTztTQUNMLGlCQUFpQixFQUFFO1FBQ3BCLDZGQUE2RjtRQUM3RixpR0FBaUc7UUFDakcscUdBQXFHO1FBQ3JHLHlGQUF5RjtTQUN4RixJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3RCLElBQUksQ0FBQyxHQUFHLEVBQUU7UUFDVixNQUFNLElBQUksR0FBRyxrQkFBa0IsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDL0QsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNWLE9BQU8sQ0FBQyxJQUFJLENBQUMsMEVBQTBFLEdBQUcsNkVBQTZFLEdBQUcsdURBQXVELENBQUMsQ0FBQztTQUNuTzthQUFNO1lBQ04sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUNuQjtRQUNELE9BQU8sT0FBTyxDQUFDO0lBQ2hCLENBQUMsQ0FBQyxDQUNILENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmlldywgRnJhbWUsIExheW91dEJhc2UsIEdyaWRMYXlvdXQgfSBmcm9tICdAbmF0aXZlc2NyaXB0L2NvcmUnO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbXBvbmVudEZpeHR1cmUsIFRlc3RCZWQgfSBmcm9tICdAYW5ndWxhci9jb3JlL3Rlc3RpbmcnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5hdGl2ZVNjcmlwdE1vZHVsZSB9IGZyb20gJ0BuYXRpdmVzY3JpcHQvYW5ndWxhcic7XG5pbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljVGVzdGluZyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy90ZXN0aW5nJztcbi8vIGltcG9ydCB7IE5TX0NPTVBJTEVSX1BST1ZJREVSUyB9IGZyb20gXCIuLi8uLi9wbGF0Zm9ybVwiO1xuaW1wb3J0IHsgTkFUSVZFU0NSSVBUX1RFU1RJTkdfUFJPVklERVJTLCBOYXRpdmVTY3JpcHRUZXN0aW5nTW9kdWxlIH0gZnJvbSAnLi9uYXRpdmVzY3JpcHQtdGVzdGluZy5tb2R1bGUnO1xuaW1wb3J0IHsgdGVzdGluZ1Jvb3RWaWV3IH0gZnJvbSAnLi90ZXN0LXJvb3Qtdmlldyc7XG5cbi8qKlxuICogRGVjbGFyZWQgdGVzdCBjb250ZXh0cy4gV2hlbiB0aGUgc3VpdGUgaXMgZG9uZSB0aGlzIG1hcCBzaG91bGQgYmUgZW1wdHkgaWYgYWxsIGxpZmVjeWNsZVxuICogY2FsbHMgaGF2ZSBoYXBwZW5lZCBhcyBleHBlY3RlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGFjdGl2ZVRlc3RGaXh0dXJlczogQ29tcG9uZW50Rml4dHVyZTxhbnk+W11bXSA9IFtdO1xuXG4vKipcbiAqIFJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciAoZHVyYXRpb25NcykgbWlsbGlzZWNvbmRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9taXNlV2FpdChkdXJhdGlvbk1zOiBudW1iZXIpIHtcblx0cmV0dXJuICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoKSwgZHVyYXRpb25NcykpO1xufVxuXG4vKipcbiAqIFBlcmZvcm0gYmFzaWMgVGVzdEJlZCBlbnZpcm9ubWVudCBpbml0aWFsaXphdGlvbi4gQ2FsbCB0aGlzIG9uY2UgaW4gdGhlIG1haW4gZW50cnkgcG9pbnQgdG8geW91ciB0ZXN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5zVGVzdEJlZEluaXQoKSB7XG5cdFRlc3RCZWQuaW5pdFRlc3RFbnZpcm9ubWVudChcblx0XHROYXRpdmVTY3JpcHRUZXN0aW5nTW9kdWxlLFxuXHRcdHBsYXRmb3JtQnJvd3NlckR5bmFtaWNUZXN0aW5nKCkgLy8gTlNfQ09NUElMRVJfUFJPVklERVJTKVxuXHQpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgY29uZmlndXJpbmcgYSBUZXN0QmVkIGluc3RhbmNlIGZvciByZW5kZXJpbmcgY29tcG9uZW50cyBmb3IgdGVzdC4gSWRlYWxseSB0aGlzXG4gKiB3b3VsZCBub3QgYmUgbmVlZGVkLCBhbmQgaW4gdHJ1dGggaXQncyBqdXN0IGEgd3JhcHBlciB0byBlbGltaW5hdGUgc29tZSBib2lsZXJwbGF0ZS4gSXRcbiAqIGV4aXN0cyBiZWNhdXNlIHdoZW4geW91IG5lZWQgdG8gc3BlY2lmeSBgZW50cnlDb21wb25lbnRzYCBmb3IgYSB0ZXN0IHRoZSBzZXR1cCBiZWNvbWVzIHF1aXRlXG4gKiBhIGJpdCBtb3JlIGNvbXBsZXggdGhhbiBpZiB5b3UncmUganVzdCBkb2luZyBhIGJhc2ljIGNvbXBvbmVudCB0ZXN0LlxuICpcbiAqIE1vcmUgYWJvdXQgZW50cnlDb21wb25lbnRzIGNvbXBsZXhpdHk6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzEyMDc5XG4gKlxuICogVXNlOlxuICogYGBgXG4gKiAgIGJlZm9yZUVhY2gobnNUZXN0QmVkQmVmb3JlRWFjaChbTXlDb21wb25lbnQsTXlGYWlsQ29tcG9uZW50XSkpO1xuICogYGBgXG4gKlxuICogKipOT1RFKioqIFJlbWVtYmVyIHRvIHBhaXIgd2l0aCB7QHNlZSBuc1Rlc3RCZWRBZnRlckVhY2h9XG4gKlxuICogQHBhcmFtIGNvbXBvbmVudHMgQW55IGNvbXBvbmVudHMgdGhhdCB5b3Ugd2lsbCBjcmVhdGUgZHVyaW5nIHRoZSB0ZXN0XG4gKiBAcGFyYW0gcHJvdmlkZXJzIEFueSBzZXJ2aWNlcyB5b3VyIHRlc3RzIGRlcGVuZCBvblxuICogQHBhcmFtIGltcG9ydHMgQW55IG1vZHVsZSBpbXBvcnRzIHlvdXIgdGVzdHMgZGVwZW5kIG9uXG4gKiBAcGFyYW0gZW50cnlDb21wb25lbnRzIEFueSBlbnRyeSBjb21wb25lbnRzIHRoYXQgeW91ciB0ZXN0cyBkZXBlbmQgb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5zVGVzdEJlZEJlZm9yZUVhY2goY29tcG9uZW50czogYW55W10sIHByb3ZpZGVyczogYW55W10gPSBbXSwgaW1wb3J0czogYW55W10gPSBbXSwgZW50cnlDb21wb25lbnRzOiBhbnlbXSA9IFtdKSB7XG5cdHJldHVybiAoZG9uZSkgPT4ge1xuXHRcdGFjdGl2ZVRlc3RGaXh0dXJlcy5wdXNoKFtdKTtcblx0XHQvLyBJZiB0aGVyZSBhcmUgbm8gZW50cnkgY29tcG9uZW50cyB3ZSBjYW4gdGFrZSB0aGUgc2ltcGxlIHBhdGguXG5cdFx0aWYgKGVudHJ5Q29tcG9uZW50cy5sZW5ndGggPT09IDApIHtcblx0XHRcdFRlc3RCZWQuY29uZmlndXJlVGVzdGluZ01vZHVsZSh7XG5cdFx0XHRcdGRlY2xhcmF0aW9uczogWy4uLmNvbXBvbmVudHNdLFxuXHRcdFx0XHRwcm92aWRlcnM6IFsuLi5wcm92aWRlcnNdLFxuXHRcdFx0XHRpbXBvcnRzOiBbTmF0aXZlU2NyaXB0TW9kdWxlLCAuLi5pbXBvcnRzXSxcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBJZiB0aGVyZSBhcmUgZW50cnkgY29tcG9uZW50cywgd2UgaGF2ZSB0byByZXNldCB0aGUgdGVzdGluZyBwbGF0Zm9ybS5cblx0XHRcdC8vXG5cdFx0XHQvLyBUaGVyZSdzIGdvdCB0byBiZSBhIGJldHRlciB3YXkuLi4gKG9fTylcblx0XHRcdC8vIFRlc3RCZWQucmVzZXRUZXN0RW52aXJvbm1lbnQoKTtcblx0XHRcdC8vIEBOZ01vZHVsZSh7XG5cdFx0XHQvLyAgICAgZGVjbGFyYXRpb25zOiBlbnRyeUNvbXBvbmVudHMsXG5cdFx0XHQvLyAgICAgZXhwb3J0czogZW50cnlDb21wb25lbnRzLFxuXHRcdFx0Ly8gICAgIGVudHJ5Q29tcG9uZW50czogZW50cnlDb21wb25lbnRzXG5cdFx0XHQvLyB9KVxuXHRcdFx0Ly8gY2xhc3MgRW50cnlDb21wb25lbnRzVGVzdE1vZHVsZSB7XG5cdFx0XHQvLyB9XG5cdFx0XHQvLyBUZXN0QmVkLmluaXRUZXN0RW52aXJvbm1lbnQoXG5cdFx0XHQvLyAgICAgRW50cnlDb21wb25lbnRzVGVzdE1vZHVsZSxcblx0XHRcdC8vICAgICBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljVGVzdGluZyhOU19DT01QSUxFUl9QUk9WSURFUlMpXG5cdFx0XHQvLyApO1xuXHRcdFx0Ly8gVGVzdEJlZC5jb25maWd1cmVUZXN0aW5nTW9kdWxlKHtcblx0XHRcdC8vICAgICBkZWNsYXJhdGlvbnM6IGNvbXBvbmVudHMsXG5cdFx0XHQvLyAgICAgaW1wb3J0czogW1xuXHRcdFx0Ly8gICAgICAgICBOYXRpdmVTY3JpcHRNb2R1bGUsIE5hdGl2ZVNjcmlwdFRlc3RpbmdNb2R1bGUsIENvbW1vbk1vZHVsZSxcblx0XHRcdC8vICAgICAgICAgLi4uaW1wb3J0c1xuXHRcdFx0Ly8gICAgIF0sXG5cdFx0XHQvLyAgICAgcHJvdmlkZXJzOiBbLi4ucHJvdmlkZXJzLCAuLi5OQVRJVkVTQ1JJUFRfVEVTVElOR19QUk9WSURFUlNdLFxuXHRcdFx0Ly8gfSk7XG5cdFx0fVxuXHRcdFRlc3RCZWQuY29tcGlsZUNvbXBvbmVudHMoKVxuXHRcdFx0LnRoZW4oKCkgPT4gZG9uZSgpKVxuXHRcdFx0LmNhdGNoKChlKSA9PiB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGBGYWlsZWQgdG8gaW5zdGFudGlhdGUgdGVzdCBjb21wb25lbnQgd2l0aCBlcnJvcjogJHtlfWApO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhlLnN0YWNrKTtcblx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0fSk7XG5cdH07XG59XG5cbi8qKlxuICogSGVscGVyIGZvciBhIGJhc2ljIGNvbXBvbmVudCBUZXN0QmVkIGNsZWFuIHVwLlxuICogQHBhcmFtIHJlc2V0RW52IFdoZW4gdHJ1ZSB0aGUgdGVzdGluZyBlbnZpcm9ubWVudCB3aWxsIGJlIHJlc2V0XG4gKiBAcGFyYW0gcmVzZXRGbiBXaGVuIHJlc2V0dGluZyB0aGUgZW52aXJvbm1lbnQsIHVzZSB0aGlzIGluaXQgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5zVGVzdEJlZEFmdGVyRWFjaChyZXNldEVudiA9IHRydWUsIHJlc2V0Rm4gPSBuc1Rlc3RCZWRJbml0KSB7XG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKGFjdGl2ZVRlc3RGaXh0dXJlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgVGhlcmUgYXJlIG5vIG1vcmUgZGVjbGFyZWQgZml4dHVyZXMuYCArIGBEaWQgeW91IGNhbGwgXCJuc1Rlc3RCZWRCZWZvcmVFYWNoXCIgYW5kIFwibnNUZXN0QmVkQWZ0ZXJFYWNoXCIgYW4gZXF1YWwgbnVtYmVyIG9mIHRpbWVzP2ApO1xuXHRcdH1cblx0XHRjb25zdCByb290ID0gdGVzdGluZ1Jvb3RWaWV3KCkgYXMgTGF5b3V0QmFzZTtcblx0XHRjb25zdCBmaXh0dXJlcyA9IGFjdGl2ZVRlc3RGaXh0dXJlcy5wb3AoKTtcblx0XHRmaXh0dXJlcy5mb3JFYWNoKChmaXh0dXJlKSA9PiB7XG5cdFx0XHRjb25zdCBmaXh0dXJlVmlldyA9IDxWaWV3PmZpeHR1cmUubmF0aXZlRWxlbWVudDtcblx0XHRcdGlmIChmaXh0dXJlVmlldy5wYXJlbnQgPT09IHJvb3QpIHtcblx0XHRcdFx0cm9vdC5yZW1vdmVDaGlsZChmaXh0dXJlVmlldyk7XG5cdFx0XHR9XG5cdFx0XHRmaXh0dXJlLmRlc3Ryb3koKTtcblx0XHR9KTtcblx0XHRUZXN0QmVkLnJlc2V0VGVzdGluZ01vZHVsZSgpO1xuXHRcdGlmIChyZXNldEVudikge1xuXHRcdFx0VGVzdEJlZC5yZXNldFRlc3RFbnZpcm9ubWVudCgpO1xuXHRcdFx0cmVzZXRGbigpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgYSBjb21wb25lbnQgdXNpbmcgdGhlIFRlc3RCZWQgaGVscGVyLCBhbmQgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlXG4gKiBDb21wb25lbnRGaXh0dXJlIGlzIGZ1bGx5IGluaXRpYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbnNUZXN0QmVkUmVuZGVyPFQ+KGNvbXBvbmVudFR5cGU6IFR5cGU8VD4pOiBQcm9taXNlPENvbXBvbmVudEZpeHR1cmU8VD4+IHtcblx0Y29uc3QgZml4dHVyZSA9IFRlc3RCZWQuY3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudFR5cGUpO1xuXHRmaXh0dXJlLmRldGVjdENoYW5nZXMoKTtcblx0cmV0dXJuIChcblx0XHRmaXh0dXJlXG5cdFx0XHQud2hlblJlbmRlcmluZ0RvbmUoKVxuXHRcdFx0Ly8gVE9ETyhqZCk6IGl0IHNlZW1zIHRoYXQgdGhlIHdoZW5TdGFibGUgYW5kIHdoZW5SZW5kZXJpbmdEb25lIHV0aWxpdGllcyBvZiBDb21wb25lbnRGaXh0dXJlXG5cdFx0XHQvLyAgICAgICAgICAgZG8gbm90IHdvcmsgYXMgZXhwZWN0ZWQuIEkgbG9va2VkIGF0IGhvdyB0byBmaXggaXQgYW5kIGl0J3Mgbm90IGNsZWFyIGhvdyB0byBwcm92aWRlXG5cdFx0XHQvLyAgICAgICAgICAgYSB7Tn0gc3BlY2lmaWMgc3ViY2xhc3MsIGJlY2F1c2UgQ29tcG9uZW50Rml4dHVyZSBpcyBuZXdlZCBkaXJlY3RseSByYXRoZXIgdGhhbiBpbmplY3RlZFxuXHRcdFx0Ly8gV2hhdCB0byBkbyBhYm91dCBpdD8gTWF5YmUgZmFrZUFzeW5jIGNhbiBoZWxwPyBGb3Igbm93IGp1c3Qgc2V0VGltZW91dCBmb3IgMTAwbXMgKHhfWClcblx0XHRcdC50aGVuKHByb21pc2VXYWl0KDEwMCkpXG5cdFx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGxpc3QgPSBhY3RpdmVUZXN0Rml4dHVyZXNbYWN0aXZlVGVzdEZpeHR1cmVzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRpZiAoIWxpc3QpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ25zVGVzdEJlZFJlbmRlciBjYWxsZWQgd2l0aG91dCBuc1Rlc3RCZWRCZWZvcmVFYWNoL25zVGVzdEJlZEFmdGVyIGVhY2guICcgKyBcIllvdSBhcmUgcmVzcG9uc2libGUgZm9yIGNhbGxpbmcgJ2ZpeHR1cmUuZGVzdHJveSgpJyB3aGVuIHlvdXIgdGVzdCBpcyBkb25lIFwiICsgJ2luIG9yZGVyIHRvIGNsZWFuIHVwIHRoZSBjb21wb25lbnRzIHRoYXQgYXJlIGNyZWF0ZWQuJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdC5wdXNoKGZpeHR1cmUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmaXh0dXJlO1xuXHRcdFx0fSlcblx0KTtcbn1cbiJdfQ==