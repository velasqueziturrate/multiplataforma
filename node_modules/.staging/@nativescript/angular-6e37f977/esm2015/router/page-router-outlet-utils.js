/**
 * There are cases where multiple activatedRoute nodes should be associated/handled by the same PageRouterOutlet.
 * We can gat additional ActivatedRoutes nodes when there is:
 *  - Lazy loading - there is an additional ActivatedRoute node for the RouteConfig with the `loadChildren` setup
 *  - Componentless routes - there is an additional ActivatedRoute node for the componentless RouteConfig
 *
 * Example:
 *   R  <-- root
 *   |
 * feature (lazy module) <-- RouteConfig: { path: "lazy", loadChildren: "./feature/feature.module#FeatureModule" }
 *   |
 * module (componentless route) <-- RouteConfig: { path: "module", children: [...] } // Note: No 'component'
 *   |
 *  home <-- RouteConfig: { path: "module", component: MyComponent } - this is what we get as activatedRoute param
 *
 *  In these cases we will mark the top-most node (feature). NSRouteReuseStrategy will detach the tree there and
 *  use this ActivateRoute as a kay for caching.
 */
export function findTopActivatedRouteNodeForOutlet(activatedRoute) {
    let outletActivatedRoute = activatedRoute;
    while (outletActivatedRoute.parent && outletActivatedRoute.parent.routeConfig && !outletActivatedRoute.parent.routeConfig.component) {
        outletActivatedRoute = outletActivatedRoute.parent;
    }
    return outletActivatedRoute;
}
export const pageRouterActivatedSymbol = Symbol('page-router-activated');
export const loaderRefSymbol = Symbol('loader-ref');
export function destroyComponentRef(componentRef) {
    if (componentRef) {
        const loaderRef = componentRef[loaderRefSymbol];
        if (loaderRef) {
            loaderRef.destroy();
        }
        componentRef.destroy();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnZS1yb3V0ZXItb3V0bGV0LXV0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vcm91dGVyL3BhZ2Utcm91dGVyLW91dGxldC11dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkc7QUFDSCxNQUFNLFVBQVUsa0NBQWtDLENBQUMsY0FBc0M7SUFDeEYsSUFBSSxvQkFBb0IsR0FBRyxjQUFjLENBQUM7SUFFMUMsT0FBTyxvQkFBb0IsQ0FBQyxNQUFNLElBQUksb0JBQW9CLENBQUMsTUFBTSxDQUFDLFdBQVcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFO1FBQ3BJLG9CQUFvQixHQUFHLG9CQUFvQixDQUFDLE1BQU0sQ0FBQztLQUNuRDtJQUVELE9BQU8sb0JBQW9CLENBQUM7QUFDN0IsQ0FBQztBQUVELE1BQU0sQ0FBQyxNQUFNLHlCQUF5QixHQUFHLE1BQU0sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBQ3pFLE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7QUFFcEQsTUFBTSxVQUFVLG1CQUFtQixDQUFDLFlBQStCO0lBQ2xFLElBQUksWUFBWSxFQUFFO1FBQ2pCLE1BQU0sU0FBUyxHQUFHLFlBQVksQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUNoRCxJQUFJLFNBQVMsRUFBRTtZQUNkLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUNwQjtRQUNELFlBQVksQ0FBQyxPQUFPLEVBQUUsQ0FBQztLQUN2QjtBQUNGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjdGl2YXRlZFJvdXRlLCBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBDaGlsZHJlbk91dGxldENvbnRleHRzLCBQUklNQVJZX09VVExFVCB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5cbi8qKlxuICogVGhlcmUgYXJlIGNhc2VzIHdoZXJlIG11bHRpcGxlIGFjdGl2YXRlZFJvdXRlIG5vZGVzIHNob3VsZCBiZSBhc3NvY2lhdGVkL2hhbmRsZWQgYnkgdGhlIHNhbWUgUGFnZVJvdXRlck91dGxldC5cbiAqIFdlIGNhbiBnYXQgYWRkaXRpb25hbCBBY3RpdmF0ZWRSb3V0ZXMgbm9kZXMgd2hlbiB0aGVyZSBpczpcbiAqICAtIExhenkgbG9hZGluZyAtIHRoZXJlIGlzIGFuIGFkZGl0aW9uYWwgQWN0aXZhdGVkUm91dGUgbm9kZSBmb3IgdGhlIFJvdXRlQ29uZmlnIHdpdGggdGhlIGBsb2FkQ2hpbGRyZW5gIHNldHVwXG4gKiAgLSBDb21wb25lbnRsZXNzIHJvdXRlcyAtIHRoZXJlIGlzIGFuIGFkZGl0aW9uYWwgQWN0aXZhdGVkUm91dGUgbm9kZSBmb3IgdGhlIGNvbXBvbmVudGxlc3MgUm91dGVDb25maWdcbiAqXG4gKiBFeGFtcGxlOlxuICogICBSICA8LS0gcm9vdFxuICogICB8XG4gKiBmZWF0dXJlIChsYXp5IG1vZHVsZSkgPC0tIFJvdXRlQ29uZmlnOiB7IHBhdGg6IFwibGF6eVwiLCBsb2FkQ2hpbGRyZW46IFwiLi9mZWF0dXJlL2ZlYXR1cmUubW9kdWxlI0ZlYXR1cmVNb2R1bGVcIiB9XG4gKiAgIHxcbiAqIG1vZHVsZSAoY29tcG9uZW50bGVzcyByb3V0ZSkgPC0tIFJvdXRlQ29uZmlnOiB7IHBhdGg6IFwibW9kdWxlXCIsIGNoaWxkcmVuOiBbLi4uXSB9IC8vIE5vdGU6IE5vICdjb21wb25lbnQnXG4gKiAgIHxcbiAqICBob21lIDwtLSBSb3V0ZUNvbmZpZzogeyBwYXRoOiBcIm1vZHVsZVwiLCBjb21wb25lbnQ6IE15Q29tcG9uZW50IH0gLSB0aGlzIGlzIHdoYXQgd2UgZ2V0IGFzIGFjdGl2YXRlZFJvdXRlIHBhcmFtXG4gKlxuICogIEluIHRoZXNlIGNhc2VzIHdlIHdpbGwgbWFyayB0aGUgdG9wLW1vc3Qgbm9kZSAoZmVhdHVyZSkuIE5TUm91dGVSZXVzZVN0cmF0ZWd5IHdpbGwgZGV0YWNoIHRoZSB0cmVlIHRoZXJlIGFuZFxuICogIHVzZSB0aGlzIEFjdGl2YXRlUm91dGUgYXMgYSBrYXkgZm9yIGNhY2hpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kVG9wQWN0aXZhdGVkUm91dGVOb2RlRm9yT3V0bGV0KGFjdGl2YXRlZFJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCB7XG5cdGxldCBvdXRsZXRBY3RpdmF0ZWRSb3V0ZSA9IGFjdGl2YXRlZFJvdXRlO1xuXG5cdHdoaWxlIChvdXRsZXRBY3RpdmF0ZWRSb3V0ZS5wYXJlbnQgJiYgb3V0bGV0QWN0aXZhdGVkUm91dGUucGFyZW50LnJvdXRlQ29uZmlnICYmICFvdXRsZXRBY3RpdmF0ZWRSb3V0ZS5wYXJlbnQucm91dGVDb25maWcuY29tcG9uZW50KSB7XG5cdFx0b3V0bGV0QWN0aXZhdGVkUm91dGUgPSBvdXRsZXRBY3RpdmF0ZWRSb3V0ZS5wYXJlbnQ7XG5cdH1cblxuXHRyZXR1cm4gb3V0bGV0QWN0aXZhdGVkUm91dGU7XG59XG5cbmV4cG9ydCBjb25zdCBwYWdlUm91dGVyQWN0aXZhdGVkU3ltYm9sID0gU3ltYm9sKCdwYWdlLXJvdXRlci1hY3RpdmF0ZWQnKTtcbmV4cG9ydCBjb25zdCBsb2FkZXJSZWZTeW1ib2wgPSBTeW1ib2woJ2xvYWRlci1yZWYnKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lDb21wb25lbnRSZWYoY29tcG9uZW50UmVmOiBDb21wb25lbnRSZWY8YW55Pikge1xuXHRpZiAoY29tcG9uZW50UmVmKSB7XG5cdFx0Y29uc3QgbG9hZGVyUmVmID0gY29tcG9uZW50UmVmW2xvYWRlclJlZlN5bWJvbF07XG5cdFx0aWYgKGxvYWRlclJlZikge1xuXHRcdFx0bG9hZGVyUmVmLmRlc3Ryb3koKTtcblx0XHR9XG5cdFx0Y29tcG9uZW50UmVmLmRlc3Ryb3koKTtcblx0fVxufVxuIl19