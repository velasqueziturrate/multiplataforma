(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@nativescript/core'), require('@nativescript/zone-js'), require('@angular/common'), require('nativescript-intl'), require('@angular/core'), require('@angular/compiler'), require('@angular/router'), require('@angular/animations'), require('@angular/animations/browser'), require('@angular/platform-browser/animations'), require('@angular/common/http'), require('rxjs'), require('@angular/forms')) :
    typeof define === 'function' && define.amd ? define('@nativescript/angular', ['exports', '@nativescript/core', '@nativescript/zone-js', '@angular/common', 'nativescript-intl', '@angular/core', '@angular/compiler', '@angular/router', '@angular/animations', '@angular/animations/browser', '@angular/platform-browser/animations', '@angular/common/http', 'rxjs', '@angular/forms'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.nativescript = global.nativescript || {}, global.nativescript.angular = {}), global['ns-core'], null, global.ng.common, null, global.ng.core, global.ng.compiler, global.ng.router, global.ng.animations, global.ng.animations.browser, global.ng.platformBrowser.animations, global.ng.common.http, global.rxjs, global.ng.forms));
}(this, (function (exports, core, zoneJs, common, nativescriptIntl, i0, compiler, i1, animations, browser, animations$1, http, rxjs, forms) { 'use strict';

    (function (NativeScriptDebug) {
        NativeScriptDebug.animationsTraceCategory = 'ns-animations';
        NativeScriptDebug.rendererTraceCategory = 'ns-renderer';
        NativeScriptDebug.viewUtilCategory = 'ns-view-util';
        NativeScriptDebug.routerTraceCategory = 'ns-router';
        NativeScriptDebug.routeReuseStrategyTraceCategory = 'ns-route-reuse-strategy';
        NativeScriptDebug.listViewTraceCategory = 'ns-list-view';
        NativeScriptDebug.bootstrapCategory = 'bootstrap';
        // TODO: migrate all usage to this - avoids extraneous method executions
        NativeScriptDebug.enabled = core.Trace.isEnabled();
        function isLogEnabled() {
            return core.Trace.isEnabled();
        }
        NativeScriptDebug.isLogEnabled = isLogEnabled;
        function animationsLog(message) {
            core.Trace.write(message, NativeScriptDebug.animationsTraceCategory);
        }
        NativeScriptDebug.animationsLog = animationsLog;
        function rendererLog(msg) {
            core.Trace.write(msg, NativeScriptDebug.rendererTraceCategory);
        }
        NativeScriptDebug.rendererLog = rendererLog;
        function rendererError(message) {
            core.Trace.write(message, NativeScriptDebug.rendererTraceCategory, core.Trace.messageType.error);
        }
        NativeScriptDebug.rendererError = rendererError;
        function viewUtilLog(msg) {
            core.Trace.write(msg, NativeScriptDebug.viewUtilCategory);
        }
        NativeScriptDebug.viewUtilLog = viewUtilLog;
        function routerLog(message) {
            core.Trace.write(message, NativeScriptDebug.routerTraceCategory);
        }
        NativeScriptDebug.routerLog = routerLog;
        function routerError(message) {
            core.Trace.write(message, NativeScriptDebug.routerTraceCategory, core.Trace.messageType.error);
        }
        NativeScriptDebug.routerError = routerError;
        function routeReuseStrategyLog(message) {
            core.Trace.write(message, NativeScriptDebug.routeReuseStrategyTraceCategory);
        }
        NativeScriptDebug.routeReuseStrategyLog = routeReuseStrategyLog;
        function styleError(message) {
            core.Trace.write(message, core.Trace.categories.Style, core.Trace.messageType.error);
        }
        NativeScriptDebug.styleError = styleError;
        function listViewLog(message) {
            core.Trace.write(message, NativeScriptDebug.listViewTraceCategory);
        }
        NativeScriptDebug.listViewLog = listViewLog;
        function listViewError(message) {
            core.Trace.write(message, NativeScriptDebug.listViewTraceCategory, core.Trace.messageType.error);
        }
        NativeScriptDebug.listViewError = listViewError;
        function bootstrapLog(message) {
            core.Trace.write(message, NativeScriptDebug.bootstrapCategory);
        }
        NativeScriptDebug.bootstrapLog = bootstrapLog;
        function bootstrapLogError(message) {
            core.Trace.write(message, NativeScriptDebug.bootstrapCategory, core.Trace.messageType.error);
        }
        NativeScriptDebug.bootstrapLogError = bootstrapLogError;
    })(exports.NativeScriptDebug || (exports.NativeScriptDebug = {}));

    var NativeScriptDomAdapter = /** @class */ (function () {
        function NativeScriptDomAdapter() {
            this.resourceLoaderType = null;
        }
        NativeScriptDomAdapter.makeCurrent = function () {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog('Setting root DOM adapter...');
            }
            common.ÉµsetRootDomAdapter(new NativeScriptDomAdapter());
        };
        NativeScriptDomAdapter.prototype.hasProperty = function (_element, _name) {
            // TODO: actually check if the property exists.
            return true;
        };
        NativeScriptDomAdapter.prototype.log = function (arg) {
            console.log(arg);
        };
        NativeScriptDomAdapter.prototype.logError = function (arg) {
            console.log(arg);
        };
        NativeScriptDomAdapter.prototype.logGroup = function (arg) {
            console.log(arg);
        };
        NativeScriptDomAdapter.prototype.logGroupEnd = function () { };
        Object.defineProperty(NativeScriptDomAdapter.prototype, "attrToPropMap", {
            get: function () {
                throw new Error('Not implemented!');
            },
            set: function (_value) {
                throw new Error('Not implemented!');
            },
            enumerable: false,
            configurable: true
        });
        NativeScriptDomAdapter.prototype.setProperty = function (_el, _name, _value) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getProperty = function (_el, _name) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.invoke = function (_el, _methodName, _args) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.contains = function (_nodeA, _nodeB) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.parse = function (_templateHtml) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.query = function (_selector) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.querySelector = function (_el /** TODO #9100 */, _selector) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.querySelectorAll = function (_el /** TODO #9100 */, _selector) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.on = function (_el /** TODO #9100 */, _evt /** TODO #9100 */, _listener /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.onAndCancel = function (_el /** TODO #9100 */, _evt /** TODO #9100 */, _listener /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.dispatchEvent = function (_el /** TODO #9100 */, _evt /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.createMouseEvent = function (_eventType /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.createEvent = function (_eventType) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.preventDefault = function (_evt /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.isPrevented = function (_evt /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getInnerHTML = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getTemplateContent = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getOuterHTML = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.nodeName = function (_node /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.nodeValue = function (_node /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.type = function (_node /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.content = function (_node /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.firstChild = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.nextSibling = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.parentElement = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.childNodes = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.childNodesAsList = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.clearNodes = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.appendChild = function (_el /** TODO #9100 */, _node /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.removeChild = function (_el /** TODO #9100 */, _node /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.replaceChild = function (_el /** TODO #9100 */, _newNode /** TODO #9100 */, _oldNode /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.remove = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.insertBefore = function (_el /** TODO #9100 */, _node /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.insertAllBefore = function (_el /** TODO #9100 */, _nodes /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.insertAfter = function (_el /** TODO #9100 */, _node /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.setInnerHTML = function (_el /** TODO #9100 */, _value /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getText = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.setText = function (_el /** TODO #9100 */, _value) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getValue = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.setValue = function (_el /** TODO #9100 */, _value) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getChecked = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.setChecked = function (_el /** TODO #9100 */, _value) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.createComment = function (_text) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.createTemplate = function (_html /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.createElement = function (_tagName /** TODO #9100 */, _doc /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.createElementNS = function (_ns, _tagName, _doc /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.createTextNode = function (_text, _doc /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.createScriptTag = function (_attrName, _attrValue, _doc /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.createStyleElement = function (_css, _doc /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.createShadowRoot = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getShadowRoot = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getHost = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getDistributedNodes = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.clone /*<T extends Node>*/ = function (_node /*T*/) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getElementsByClassName = function (_element /** TODO #9100 */, _name) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getElementsByTagName = function (_element /** TODO #9100 */, _name) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.classList = function (_element /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.addClass = function (_element /** TODO #9100 */, _className) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.removeClass = function (_element /** TODO #9100 */, _className) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.hasClass = function (_element /** TODO #9100 */, _className) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.setStyle = function (_element /** TODO #9100 */, _styleName, _styleValue) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.removeStyle = function (_element /** TODO #9100 */, _styleName) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getStyle = function (_element /** TODO #9100 */, _styleName) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.hasStyle = function (_element /** TODO #9100 */, _styleName, _styleValue) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.tagName = function (_element /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.attributeMap = function (_element /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.hasAttribute = function (_element /** TODO #9100 */, _attribute) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.hasAttributeNS = function (_element /** TODO #9100 */, _ns, _attribute) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getAttribute = function (_element /** TODO #9100 */, _attribute) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getAttributeNS = function (_element /** TODO #9100 */, _ns, _attribute) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.setAttribute = function (_element /** TODO #9100 */, _name, _value) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.setAttributeNS = function (_element /** TODO #9100 */, _ns, _name, _value) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.removeAttribute = function (_element /** TODO #9100 */, _attribute) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.removeAttributeNS = function (_element /** TODO #9100 */, _ns, _attribute) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.templateAwareRoot = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.createHtmlDocument = function () {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.defaultDoc = function () {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getDefaultDocument = function () {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getBoundingClientRect = function (_el /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getTitle = function () {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.setTitle = function (_doc, _newTitle) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.elementMatches = function (_n /** TODO #9100 */, _selector) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.isTemplateElement = function (_el) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.isTextNode = function (_node /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.isCommentNode = function (_node /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.isElementNode = function (_node /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.hasShadowRoot = function (_node /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.isShadowRoot = function (_node /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.importIntoDoc /*<T extends Node>*/ = function (_node /*T*/) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.adoptNode /*<T extends Node>*/ = function (_node /*T*/) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getHref = function (_element /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getEventKey = function (_event /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.resolveAndSetHref = function (_element /** TODO #9100 */, _baseUrl, _href) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.supportsDOMEvents = function () {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.supportsNativeShadowDOM = function () {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getGlobalEventTarget = function (_doc, _target) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getHistory = function () {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getLocation = function () {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getBaseHref = function () {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.resetBaseElement = function () {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getUserAgent = function () {
            return 'Fake user agent';
        };
        NativeScriptDomAdapter.prototype.setData = function (_element /** TODO #9100 */, _name, _value) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getComputedStyle = function (_element /** TODO #9100 */) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getData = function (_element /** TODO #9100 */, _name) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.setGlobalVar = function (_name, _value) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.supportsWebAnimation = function () {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.performanceNow = function () {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getAnimationPrefix = function () {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.getTransitionEnd = function () {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.supportsAnimation = function () {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.supportsCookies = function () {
            return false;
        };
        NativeScriptDomAdapter.prototype.getCookie = function (_name) {
            throw new Error('Not implemented!');
        };
        NativeScriptDomAdapter.prototype.setCookie = function (_name, _value) {
            throw new Error('Not implemented!');
        };
        return NativeScriptDomAdapter;
    }());
    NativeScriptDomAdapter.makeCurrent();

    if (!console.group) {
        console.group = function () { };
    }
    if (!console.groupEnd) {
        console.groupEnd = function () { };
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, exports) {
        for (var p in m)
            if (p !== "default" && !exports.hasOwnProperty(p))
                __createBinding(exports, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (Object.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var APP_ROOT_VIEW = new i0.InjectionToken('NativeScriptAppRootView');
    var DeviceToken = new i0.InjectionToken('NativeScriptPlatformDeviceToken');
    var PAGE_FACTORY = new i0.InjectionToken('NativeScriptPageFactory');
    var defaultPageFactory = function (_opts) {
        return new core.Page();
    };
    var defaultPageFactoryProvider = { provide: PAGE_FACTORY, useValue: defaultPageFactory };
    var _rootPageRef;
    function setRootPage(page) {
        _rootPageRef = new WeakRef(page);
    }
    function getRootPage() {
        return _rootPageRef && _rootPageRef.get();
    }
    // Use an exported function to make the AoT compiler happy.
    function getDefaultPage() {
        var rootPage = getRootPage();
        if (rootPage instanceof core.Page) {
            return rootPage;
        }
        // if (rootPage) {
        // 	return rootPage;
        // }
        var frame = core.Frame.topmost();
        if (frame && frame.currentPage) {
            return frame.currentPage;
        }
        return null;
    }
    var defaultPageProvider = { provide: core.Page, useFactory: getDefaultPage };
    // Use an exported function to make the AoT compiler happy.
    function getDefaultFrame() {
        return core.Frame.topmost();
    }
    var defaultFrameProvider = { provide: core.Frame, useFactory: getDefaultFrame };
    // Use an exported function to make the AoT compiler happy.
    function getDefaultDevice() {
        return core.Device;
    }
    var defaultDeviceProvider = { provide: DeviceToken, useFactory: getDefaultDevice };

    var AppHostView = /** @class */ (function (_super) {
        __extends(AppHostView, _super);
        function AppHostView(backgroundColor) {
            var _this = _super.call(this) || this;
            _this.backgroundColor = backgroundColor;
            return _this;
        }
        Object.defineProperty(AppHostView.prototype, "ngAppRoot", {
            get: function () {
                return this._ngAppRoot;
            },
            set: function (value) {
                this._ngAppRoot = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AppHostView.prototype, "content", {
            get: function () {
                return this._content;
            },
            set: function (value) {
                if (this._content) {
                    this._content.parentNode = undefined;
                }
                this._content = value;
                if (value) {
                    this._content.parentNode = this;
                }
                this.ngAppRoot = value;
                if (this._content instanceof core.ProxyViewContainer) {
                    var grid = new core.GridLayout();
                    grid.backgroundColor = this.backgroundColor;
                    grid.addChild(this._content);
                    this.ngAppRoot = grid;
                }
            },
            enumerable: false,
            configurable: true
        });
        return AppHostView;
    }(core.ContentView));
    var AppHostAsyncView = /** @class */ (function (_super) {
        __extends(AppHostAsyncView, _super);
        function AppHostAsyncView(backgroundColor) {
            var _this = _super.call(this) || this;
            _this.backgroundColor = backgroundColor;
            return _this;
        }
        Object.defineProperty(AppHostAsyncView.prototype, "ngAppRoot", {
            get: function () {
                return this;
            },
            set: function (value) {
                // ignored
            },
            enumerable: false,
            configurable: true
        });
        return AppHostAsyncView;
    }(core.GridLayout));

    var onBeforeLivesync = new i0.EventEmitter();
    var onAfterLivesync = new i0.EventEmitter();
    var lastBootstrappedModule;
    var NativeScriptSanitizer = /** @class */ (function (_super) {
        __extends(NativeScriptSanitizer, _super);
        function NativeScriptSanitizer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NativeScriptSanitizer.prototype.sanitize = function (_context, value) {
            return value;
        };
        return NativeScriptSanitizer;
    }(i0.Sanitizer));
    var NativeScriptDocument = /** @class */ (function () {
        function NativeScriptDocument() {
            // Required by the AnimationDriver
            this.body = {
                isOverride: true,
            };
        }
        NativeScriptDocument.prototype.createElement = function (tag) {
            throw new Error('NativeScriptDocument is not DOM Document. There is no createElement() method.');
        };
        return NativeScriptDocument;
    }());
    var COMMON_PROVIDERS = [defaultPageFactoryProvider, { provide: i0.Sanitizer, useClass: NativeScriptSanitizer, deps: [] }, { provide: common.DOCUMENT, useClass: NativeScriptDocument, deps: [] }];
    var NativeScriptPlatformRef = /** @class */ (function (_super) {
        __extends(NativeScriptPlatformRef, _super);
        function NativeScriptPlatformRef(platform, appOptions) {
            if (appOptions === void 0) { appOptions = {}; }
            var _this = _super.call(this) || this;
            _this.platform = platform;
            _this.appOptions = appOptions;
            return _this;
        }
        NativeScriptPlatformRef.prototype.bootstrapModuleFactory = function (moduleFactory) {
            var _this = this;
            this._bootstrapper = function () {
                var bootstrapFactory = moduleFactory;
                if (_this.appOptions.hmrOptions) {
                    bootstrapFactory = _this.appOptions.hmrOptions.moduleTypeFactory();
                }
                return _this.platform.bootstrapModuleFactory(bootstrapFactory);
            };
            this.bootstrapApp();
            return null; // Make the compiler happy
        };
        NativeScriptPlatformRef.prototype.bootstrapModule = function (moduleType, compilerOptions) {
            var _this = this;
            if (compilerOptions === void 0) { compilerOptions = []; }
            this._bootstrapper = function () {
                var bootstrapType = moduleType;
                if (_this.appOptions.hmrOptions) {
                    bootstrapType = _this.appOptions.hmrOptions.moduleTypeFactory();
                }
                return _this.platform.bootstrapModule(bootstrapType, compilerOptions);
            };
            this.bootstrapApp();
            return null; // Make the compiler happy
        };
        NativeScriptPlatformRef.prototype.bootstrapApp = function () {
            var _this = this;
            global.__onLiveSyncCore = function () {
                if (_this.appOptions.hmrOptions) {
                    var rootView = core.Application.getRootView();
                    if (rootView) {
                        rootView._closeAllModalViewsInternal();
                    }
                    _this.appOptions.hmrOptions.livesyncCallback(function () { return _this._livesync(); });
                }
                else {
                    _this._livesync();
                }
            };
            if (this.appOptions && typeof this.appOptions.cssFile === 'string') {
                core.Application.setCssFileName(this.appOptions.cssFile);
            }
            this.bootstrapNativeScriptApp();
        };
        NativeScriptPlatformRef.prototype.onDestroy = function (callback) {
            this.platform.onDestroy(callback);
        };
        Object.defineProperty(NativeScriptPlatformRef.prototype, "injector", {
            get: function () {
                return this.platform.injector;
            },
            enumerable: false,
            configurable: true
        });
        NativeScriptPlatformRef.prototype.destroy = function () {
            this.platform.destroy();
        };
        Object.defineProperty(NativeScriptPlatformRef.prototype, "destroyed", {
            get: function () {
                return this.platform.destroyed;
            },
            enumerable: false,
            configurable: true
        });
        NativeScriptPlatformRef.prototype.bootstrapNativeScriptApp = function () {
            var _this = this;
            var rootContent;
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.bootstrapLog('NativeScriptPlatform bootstrap started.');
            }
            var launchCallback = core.profile('@nativescript/angular/platform-common.launchCallback', function (args) {
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.bootstrapLog('Application launch event fired');
                }
                // Create a temp page for root of the renderer
                var tempAppHostView;
                var tempAppHostAsyncView;
                if (_this.appOptions && (_this.appOptions.async || _this.appOptions.launchView)) {
                    tempAppHostAsyncView = new AppHostAsyncView(new core.Color(_this.appOptions && _this.appOptions.backgroundColor ? _this.appOptions.backgroundColor : '#fff'));
                    if (_this.appOptions.launchView) {
                        _this.appOptions.launchView.style.zIndex = 1000;
                        tempAppHostAsyncView.addChild(_this.appOptions.launchView);
                    }
                    rootContent = tempAppHostAsyncView.ngAppRoot;
                    setRootPage(tempAppHostAsyncView);
                }
                else {
                    tempAppHostView = new AppHostView(new core.Color(_this.appOptions && _this.appOptions.backgroundColor ? _this.appOptions.backgroundColor : '#fff'));
                    setRootPage(tempAppHostView);
                }
                var bootstrapPromiseCompleted = false;
                var bootstrap = function () {
                    _this._bootstrapper().then(function (moduleRef) {
                        bootstrapPromiseCompleted = true;
                        if (exports.NativeScriptDebug.isLogEnabled()) {
                            exports.NativeScriptDebug.bootstrapLog("Angular bootstrap bootstrap done. uptime: " + core.profilingUptime());
                        }
                        if (_this.appOptions.launchView && _this.appOptions.launchView.cleanup) {
                            _this.appOptions.launchView.cleanup().then(function () {
                                // cleanup any custom launch views
                                tempAppHostAsyncView.removeChild(_this.appOptions.launchView);
                                _this.appOptions.launchView = null;
                            });
                        }
                        else if (tempAppHostView) {
                            rootContent = tempAppHostView.content;
                        }
                        lastBootstrappedModule = new WeakRef(moduleRef);
                    }, function (err) {
                        bootstrapPromiseCompleted = true;
                        var errorMessage = err.message + '\n\n' + err.stack;
                        if (exports.NativeScriptDebug.isLogEnabled()) {
                            exports.NativeScriptDebug.bootstrapLogError('ERROR BOOTSTRAPPING ANGULAR');
                        }
                        if (exports.NativeScriptDebug.isLogEnabled()) {
                            exports.NativeScriptDebug.bootstrapLogError(errorMessage);
                        }
                        rootContent = _this.createErrorUI(errorMessage);
                    });
                    if (exports.NativeScriptDebug.isLogEnabled()) {
                        exports.NativeScriptDebug.bootstrapLog('bootstrapAction called, draining micro tasks queue. Root: ' + rootContent);
                    }
                    global.Zone.drainMicroTaskQueue();
                    if (exports.NativeScriptDebug.isLogEnabled()) {
                        exports.NativeScriptDebug.bootstrapLog('bootstrapAction called, draining micro tasks queue finished! Root: ' + rootContent);
                    }
                };
                if (_this.appOptions && _this.appOptions.launchView && _this.appOptions.launchView.startAnimation) {
                    // start animations on next tick (after initial boot)
                    setTimeout(function () {
                        // ensure launch animation is executed after launchView added to view stack
                        _this.appOptions.launchView.startAnimation();
                    });
                }
                bootstrap();
                // if (!bootstrapPromiseCompleted) {
                // 	const errorMessage = "Bootstrap promise didn't resolve";
                // 	if (NativeScriptDebug.isLogEnabled()) {
                // 		NativeScriptDebug.bootstrapLogError(errorMessage);
                // 	}
                // 	rootContent = this.createErrorUI(errorMessage);
                // }
                args.root = rootContent;
            });
            var exitCallback = core.profile('@nativescript/angular/platform-common.exitCallback', function (args) {
                var androidActivity = args.android;
                if (androidActivity && !androidActivity.isFinishing()) {
                    // Exit event was triggered as a part of a restart of the app.
                    return;
                }
                var lastModuleRef = lastBootstrappedModule ? lastBootstrappedModule.get() : null;
                if (lastModuleRef) {
                    // Make sure the module is only destroyed once
                    lastBootstrappedModule = null;
                    lastModuleRef.destroy();
                }
                rootContent = null;
            });
            core.Application.on(core.Application.launchEvent, launchCallback);
            core.Application.on(core.Application.exitEvent, exitCallback);
            core.Application.run();
        };
        NativeScriptPlatformRef.prototype._livesync = function () {
            var _this = this;
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.bootstrapLog('Angular livesync started.');
            }
            var lastModuleRef = lastBootstrappedModule ? lastBootstrappedModule.get() : null;
            onBeforeLivesync.next(lastModuleRef);
            if (lastModuleRef) {
                lastModuleRef.destroy();
            }
            this._bootstrapper().then(function (moduleRef) {
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.bootstrapLog('Angular livesync done.');
                }
                onAfterLivesync.next({ moduleRef: moduleRef });
                lastBootstrappedModule = new WeakRef(moduleRef);
                core.Application.resetRootView({
                    create: function () { return getRootPage(); },
                });
            }, function (error) {
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.bootstrapLogError('ERROR LIVESYNC BOOTSTRAPPING ANGULAR');
                }
                var errorMessage = error.message + '\n\n' + error.stack;
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.bootstrapLogError(errorMessage);
                }
                core.Application.resetRootView({
                    create: function () { return _this.createErrorUI(errorMessage); },
                });
                onAfterLivesync.next({ error: error });
            });
        };
        NativeScriptPlatformRef.prototype.createErrorUI = function (message) {
            var errorTextBox = new core.TextView();
            errorTextBox.text = message;
            errorTextBox.color = new core.Color('red');
            return errorTextBox;
        };
        NativeScriptPlatformRef.prototype.createFrameAndPage = function (isLivesync) {
            var frame = new core.Frame();
            var pageFactory = this.platform.injector.get(PAGE_FACTORY);
            var page = pageFactory({ isBootstrap: true, isLivesync: isLivesync });
            frame.navigate({
                create: function () {
                    return page;
                },
            });
            return { page: page, frame: frame };
        };
        return NativeScriptPlatformRef;
    }(i0.PlatformRef));
    __decorate([
        core.profile
    ], NativeScriptPlatformRef.prototype, "bootstrapModuleFactory", null);
    __decorate([
        core.profile
    ], NativeScriptPlatformRef.prototype, "bootstrapModule", null);
    __decorate([
        core.profile
    ], NativeScriptPlatformRef.prototype, "bootstrapApp", null);
    __decorate([
        core.profile
    ], NativeScriptPlatformRef.prototype, "bootstrapNativeScriptApp", null);
    __decorate([
        core.profile
    ], NativeScriptPlatformRef.prototype, "_livesync", null);

    // "Static" platform
    var _platformNativeScript = i0.createPlatformFactory(i0.platformCore, 'nativeScript', __spread(COMMON_PROVIDERS));
    function platformNativeScriptDynamic(options, extraProviders) {
        // Return raw platform to advanced users only if explicitly requested
        if (options && options.bootInExistingPage === true) {
            return _platformNativeScript(extraProviders);
        }
        else {
            return new NativeScriptPlatformRef(_platformNativeScript(extraProviders), options);
        }
    }

    // Allows greater flexibility with `file-system` and Angular
    // Also provides a way for `file-system` to be mocked for testing
    var NSFileSystem = /** @class */ (function () {
        function NSFileSystem() {
        }
        NSFileSystem.prototype.currentApp = function () {
            return core.knownFolders.currentApp();
        };
        NSFileSystem.prototype.fileFromPath = function (path) {
            return core.File.fromPath(path);
        };
        NSFileSystem.prototype.fileExists = function (path) {
            return core.File.exists(path);
        };
        return NSFileSystem;
    }());
    NSFileSystem.decorators = [
        { type: i0.Injectable }
    ];

    var sourceExtensionsMap = {
        '.scss': '.css',
        '.sass': '.css',
        '.less': '.css',
    };
    var FileSystemResourceLoader = /** @class */ (function (_super) {
        __extends(FileSystemResourceLoader, _super);
        function FileSystemResourceLoader(fs) {
            var _this = _super.call(this) || this;
            _this.fs = fs;
            return _this;
        }
        FileSystemResourceLoader.prototype.get = function (url) {
            var resolvedPath = this.resolve(url);
            var templateFile = this.fs.fileFromPath(resolvedPath);
            return templateFile.readTextSync();
        };
        FileSystemResourceLoader.prototype.resolve = function (url) {
            var normalizedSourceUrl = this.resolveRelativeUrls(url);
            var normalizedCompiledFileUrl = normalizedSourceUrl.replace(/\.\w+$/, function (ext) { return sourceExtensionsMap[ext] || ext; });
            if (normalizedCompiledFileUrl !== normalizedSourceUrl && this.fs.fileExists(normalizedCompiledFileUrl)) {
                return normalizedCompiledFileUrl;
            }
            if (this.fs.fileExists(normalizedSourceUrl)) {
                return normalizedSourceUrl;
            }
            if (normalizedCompiledFileUrl === normalizedSourceUrl) {
                throw new Error("Could not resolve " + url + ". Looked for: " + normalizedSourceUrl + ".");
            }
            else {
                throw new Error("Could not resolve " + url + "." + ("Looked for: " + normalizedCompiledFileUrl + ", " + normalizedSourceUrl + "."));
            }
        };
        FileSystemResourceLoader.prototype.resolveRelativeUrls = function (url) {
            // Angular assembles absolute URLs and prefixes them with //
            if (url.indexOf('/') !== 0) {
                // Resolve relative URLs based on the app root.
                return core.path.join(this.fs.currentApp().path, url);
            }
            else {
                return url;
            }
        };
        return FileSystemResourceLoader;
    }(compiler.ResourceLoader));
    FileSystemResourceLoader.decorators = [
        { type: i0.Injectable }
    ];
    FileSystemResourceLoader.ctorParameters = function () { return [
        { type: NSFileSystem }
    ]; };

    function isPresent(obj) {
        return obj !== undefined && obj !== null;
    }
    function isBlank(obj) {
        return obj === undefined || obj === null;
    }

    var FrameService = /** @class */ (function () {
        function FrameService() {
        }
        // TODO: Add any methods that are needed to handle frame/page navigation
        FrameService.prototype.getFrame = function () {
            var topmostFrame = core.Frame.topmost();
            return topmostFrame;
        };
        return FrameService;
    }());
    FrameService.Éµprov = i0.ÉµÉµdefineInjectable({ factory: function FrameService_Factory() { return new FrameService(); }, token: FrameService, providedIn: "root" });
    FrameService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    var Outlet = /** @class */ (function () {
        function Outlet(outletKey, path, pathByOutlets, modalNavigationDepth) {
            // More than one frame available when using NSEmptyOutletComponent component
            // in module that lazy loads children (loadChildren) and has outlet name.
            this.frames = [];
            this.states = [];
            // Used in reuse-strategy by its children to determine if they should be detached too.
            this.shouldDetach = true;
            this.outletKeys = [outletKey];
            this.isPageNavigationBack = false;
            this.showingModal = false;
            this.modalNavigationDepth = modalNavigationDepth || 0;
            this.pathByOutlets = pathByOutlets;
            this.path = path;
        }
        Outlet.prototype.containsFrame = function (frame) {
            return this.frames.indexOf(frame) > -1;
        };
        Outlet.prototype.peekState = function () {
            if (this.states.length > 0) {
                return this.states[this.states.length - 1];
            }
            return null;
        };
        Outlet.prototype.containsTopState = function (stateUrl) {
            var lastState = this.peekState();
            return lastState && lastState.segmentGroup.toString() === stateUrl;
        };
        // Search for frame that can go back.
        // Nested 'primary' outlets could result in Outlet with multiple navigatable frames.
        Outlet.prototype.getFrameToBack = function () {
            var frame = this.frames[this.frames.length - 1];
            if (!this.isNSEmptyOutlet) {
                for (var index = this.frames.length - 1; index >= 0; index--) {
                    var currentFrame = this.frames[index];
                    if (currentFrame.canGoBack()) {
                        frame = currentFrame;
                        break;
                    }
                }
            }
            return frame;
        };
        return Outlet;
    }());
    var defaultNavOptions = {
        clearHistory: false,
        animated: true,
    };

    var NSLocationStrategy = /** @class */ (function (_super) {
        __extends(NSLocationStrategy, _super);
        function NSLocationStrategy(frameService) {
            var _this = _super.call(this) || this;
            _this.frameService = frameService;
            _this.outlets = [];
            _this.popStateCallbacks = new Array();
            _this._modalNavigationDepth = 0;
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog('NSLocationStrategy.constructor()');
            }
            return _this;
        }
        NSLocationStrategy.prototype.path = function () {
            if (!this.currentUrlTree) {
                return '/';
            }
            var state = this.currentOutlet && this.currentOutlet.peekState();
            if (!state) {
                return '/';
            }
            var tree = this.currentUrlTree;
            var changedOutlet = this.getSegmentGroupByOutlet(this.currentOutlet);
            // Handle case where the user declares a component at path "/".
            // The url serializer doesn't parse this url as having a primary outlet.
            if (state.isRootSegmentGroup) {
                tree.root = state.segmentGroup;
            }
            else if (changedOutlet) {
                this.updateSegmentGroup(tree.root, changedOutlet, state.segmentGroup);
            }
            var urlSerializer = new i1.DefaultUrlSerializer();
            tree.queryParams = state.queryParams;
            var url = urlSerializer.serialize(tree);
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog('NSLocationStrategy.path(): ' + url);
            }
            return url;
        };
        NSLocationStrategy.prototype.prepareExternalUrl = function (internal) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog('NSLocationStrategy.prepareExternalUrl() internal: ' + internal);
            }
            return internal;
        };
        NSLocationStrategy.prototype.pushState = function (state, title, url, queryParams) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog('NSLocationStrategy.pushState state: ' + (state + ", title: " + title + ", url: " + url + ", queryParams: " + queryParams));
            }
            this.pushStateInternal(state, title, url, queryParams);
        };
        NSLocationStrategy.prototype.pushStateInternal = function (state, title, url, queryParams) {
            var _this = this;
            var urlSerializer = new i1.DefaultUrlSerializer();
            this.currentUrlTree = urlSerializer.parse(url);
            var urlTreeRoot = this.currentUrlTree.root;
            // Handle case where the user declares a component at path "/".
            // The url serializer doesn't parse this url as having a primary outlet.
            if (!Object.keys(urlTreeRoot.children).length) {
                var segmentGroup = this.currentUrlTree && this.currentUrlTree.root;
                var outletKey = this.getOutletKey(this.getSegmentGroupFullPath(segmentGroup), 'primary');
                var outlet = this.findOutlet(outletKey);
                if (outlet && this.updateStates(outlet, segmentGroup, this.currentUrlTree.queryParams)) {
                    this.currentOutlet = outlet; // If states updated
                }
                else if (!outlet) {
                    // tslint:disable-next-line:max-line-length
                    var rootOutlet = this.createOutlet('primary', null, segmentGroup, null, null, this.currentUrlTree.queryParams);
                    this.currentOutlet = rootOutlet;
                }
                this.currentOutlet.peekState().isRootSegmentGroup = true;
                return;
            }
            var queue = [];
            var currentTree = urlTreeRoot;
            while (currentTree) {
                Object.keys(currentTree.children).forEach(function (outletName) {
                    var currentSegmentGroup = currentTree.children[outletName];
                    currentSegmentGroup.outlet = outletName;
                    currentSegmentGroup.root = urlTreeRoot;
                    var outletPath = _this.getSegmentGroupFullPath(currentTree);
                    var outletKey = _this.getOutletKey(outletPath, outletName);
                    var outlet = _this.findOutlet(outletKey);
                    var parentOutletName = currentTree.outlet || '';
                    var parentOutletPath = _this.getSegmentGroupFullPath(currentTree.parent);
                    var parentOutletKey = _this.getOutletKey(parentOutletPath, parentOutletName);
                    var parentOutlet = _this.findOutlet(parentOutletKey);
                    var containsLastState = outlet && outlet.containsTopState(currentSegmentGroup.toString());
                    if (!outlet) {
                        // tslint:disable-next-line:max-line-length
                        outlet = _this.createOutlet(outletKey, outletPath, currentSegmentGroup, parentOutlet, _this._modalNavigationDepth, _this.currentUrlTree.queryParams);
                        _this.currentOutlet = outlet;
                    }
                    else if (_this._modalNavigationDepth > 0 && outlet.showingModal && !containsLastState) {
                        // Navigation inside modal view.
                        _this.upsertModalOutlet(outlet, currentSegmentGroup, _this.currentUrlTree.queryParams);
                    }
                    else {
                        outlet.parent = parentOutlet;
                        if (_this.updateStates(outlet, currentSegmentGroup, _this.currentUrlTree.queryParams)) {
                            _this.currentOutlet = outlet; // If states updated
                        }
                    }
                    queue.push(currentSegmentGroup);
                });
                currentTree = queue.shift();
            }
        };
        NSLocationStrategy.prototype.replaceState = function (state, title, url, queryParams) {
            var states = this.currentOutlet && this.currentOutlet.states;
            if (states && states.length > 0) {
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.routerLog('NSLocationStrategy.replaceState changing existing state: ' + (state + ", title: " + title + ", url: " + url + ", queryParams: " + queryParams));
                }
            }
            else {
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.routerLog('NSLocationStrategy.replaceState pushing new state: ' + (state + ", title: " + title + ", url: " + url + ", queryParams: " + queryParams));
                }
                this.pushStateInternal(state, title, url, queryParams);
            }
        };
        NSLocationStrategy.prototype.forward = function () {
            throw new Error('NSLocationStrategy.forward() - not implemented');
        };
        NSLocationStrategy.prototype.back = function (outlet, frame) {
            this.currentOutlet = outlet || this.currentOutlet;
            if (this.currentOutlet.isPageNavigationBack) {
                var states = this.currentOutlet.states;
                // We are navigating to the previous page
                // clear the stack until we get to a page navigation state
                var state = states.pop();
                var count = 1;
                if (frame) {
                    while (state.frame && state.frame !== frame) {
                        state = states.pop();
                        count++;
                    }
                }
                while (!state.isPageNavigation) {
                    state = states.pop();
                    count++;
                }
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.routerLog("NSLocationStrategy.back() while navigating back. States popped: " + count);
                }
                this.callPopState(state, true);
            }
            else {
                var state = this.currentOutlet.peekState();
                if (state && state.isPageNavigation) {
                    // This was a page navigation - so navigate through frame.
                    if (exports.NativeScriptDebug.isLogEnabled()) {
                        exports.NativeScriptDebug.routerLog('NSLocationStrategy.back() while not navigating back but top' + ' state is page - will call frame.goBack()');
                    }
                    if (!outlet) {
                        var topmostFrame = this.frameService.getFrame();
                        this.currentOutlet = this.getOutletByFrame(topmostFrame) || this.currentOutlet;
                    }
                    var frameToBack = this.currentOutlet.getFrameToBack();
                    if (frameToBack) {
                        frameToBack.goBack();
                    }
                }
                else {
                    // Nested navigation - just pop the state
                    if (exports.NativeScriptDebug.isLogEnabled()) {
                        exports.NativeScriptDebug.routerLog('NSLocationStrategy.back() while not navigating back but top' + ' state is not page - just pop');
                    }
                    this.callPopState(this.currentOutlet.states.pop(), true);
                }
            }
        };
        NSLocationStrategy.prototype.canGoBack = function (outlet) {
            outlet = outlet || this.currentOutlet;
            return outlet.states.length > 1;
        };
        NSLocationStrategy.prototype.onPopState = function (fn) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog('NSLocationStrategy.onPopState');
            }
            this.popStateCallbacks.push(fn);
        };
        NSLocationStrategy.prototype.getBaseHref = function () {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog('NSLocationStrategy.getBaseHref()');
            }
            return '';
        };
        NSLocationStrategy.prototype.callPopState = function (state, pop, outlet) {
            var e_1, _a;
            if (pop === void 0) { pop = true; }
            outlet = outlet || this.currentOutlet;
            var urlSerializer = new i1.DefaultUrlSerializer();
            var changedOutlet = this.getSegmentGroupByOutlet(outlet);
            if (state && changedOutlet) {
                this.updateSegmentGroup(this.currentUrlTree.root, changedOutlet, state.segmentGroup);
            }
            else if (changedOutlet) {
                // when closing modal view there are scenarios (e.g. root viewContainerRef) when we need
                // to clean up the named page router outlet to make sure we will open the modal properly again if needed.
                this.updateSegmentGroup(this.currentUrlTree.root, changedOutlet, null);
            }
            var url = urlSerializer.serialize(this.currentUrlTree);
            var change = { url: url, pop: pop };
            try {
                for (var _b = __values(this.popStateCallbacks), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var fn = _c.value;
                    fn(change);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        NSLocationStrategy.prototype.toString = function () {
            var result = [];
            this.outlets.forEach(function (outlet) {
                var outletStates = outlet.states;
                var outletLog = outletStates
                    // tslint:disable-next-line:max-line-length
                    .map(function (v, i) { return outlet.outletKeys + "." + i + ".[" + (v.isPageNavigation ? 'PAGE' : 'INTERNAL') + "].[" + (outlet.modalNavigationDepth ? 'MODAL' : 'BASE') + "] \"" + v.segmentGroup.toString() + "\""; })
                    .reverse();
                result = result.concat(outletLog);
            });
            return result.join('\n');
        };
        // Methods for syncing with page navigation in PageRouterOutlet
        NSLocationStrategy.prototype._beginBackPageNavigation = function (frame) {
            var outlet = this.getOutletByFrame(frame);
            if (!outlet || outlet.isPageNavigationBack) {
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.routerError('Attempted to call startGoBack while going back.');
                }
                return;
            }
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog('NSLocationStrategy.startGoBack()');
            }
            outlet.isPageNavigationBack = true;
            this.currentOutlet = outlet;
        };
        NSLocationStrategy.prototype._finishBackPageNavigation = function (frame) {
            var outlet = this.getOutletByFrame(frame);
            if (!outlet || !outlet.isPageNavigationBack) {
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.routerError('Attempted to call endGoBack while not going back.');
                }
                return;
            }
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog('NSLocationStrategy.finishBackPageNavigation()');
            }
            outlet.isPageNavigationBack = false;
        };
        NSLocationStrategy.prototype._beginModalNavigation = function (frame) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog('NSLocationStrategy._beginModalNavigation()');
            }
            this.currentOutlet = this.getOutletByFrame(frame) || this.currentOutlet;
            // It is possible to have frame, but not corresponding Outlet, if
            // showing modal dialog on app.component.ts ngOnInit() e.g. In that case
            // the modal is treated as none modal navigation.
            if (this.currentOutlet) {
                this.currentOutlet.showingModal = true;
                this._modalNavigationDepth++;
            }
        };
        NSLocationStrategy.prototype._closeModalNavigation = function () {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog('NSLocationStrategy.closeModalNavigation()');
            }
            var isShowingModal = this._modalNavigationDepth > 0;
            if (isShowingModal) {
                this._modalNavigationDepth--;
            }
            // currentOutlet should be the one that corresponds to the topmost frame
            var topmostOutlet = this.getOutletByFrame(this.frameService.getFrame());
            var outlet = this.findOutletByModal(this._modalNavigationDepth, isShowingModal) || topmostOutlet;
            if (outlet) {
                this.currentOutlet = outlet;
                this.currentOutlet.showingModal = false;
                this.callPopState(this.currentOutlet.peekState(), false);
            }
        };
        NSLocationStrategy.prototype._beginPageNavigation = function (frame) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog('NSLocationStrategy._beginPageNavigation()');
            }
            this.currentOutlet = this.getOutletByFrame(frame);
            var lastState = this.currentOutlet.peekState();
            if (lastState) {
                lastState.isPageNavigation = true;
            }
            var navOptions = this._currentNavigationOptions || defaultNavOptions;
            if (navOptions.clearHistory) {
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.routerLog('NSLocationStrategy._beginPageNavigation clearing states history');
                }
                this.currentOutlet.states = [lastState];
            }
            this._currentNavigationOptions = undefined;
            return navOptions;
        };
        NSLocationStrategy.prototype._setNavigationOptions = function (options) {
            this._currentNavigationOptions = {
                clearHistory: isPresent(options.clearHistory) ? options.clearHistory : false,
                animated: isPresent(options.animated) ? options.animated : true,
                transition: options.transition,
            };
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog('NSLocationStrategy._setNavigationOptions(' + (JSON.stringify(this._currentNavigationOptions) + ")"));
            }
        };
        NSLocationStrategy.prototype._getOutlets = function () {
            return this.outlets;
        };
        NSLocationStrategy.prototype.updateOutletFrame = function (outlet, frame, isEmptyOutletFrame) {
            var lastState = outlet.peekState();
            if (lastState && !lastState.frame && !isEmptyOutletFrame) {
                lastState.frame = frame;
            }
            if (!outlet.containsFrame(frame)) {
                outlet.frames.push(frame);
            }
            this.currentOutlet = outlet;
        };
        NSLocationStrategy.prototype.clearOutlet = function (frame) {
            var _this = this;
            this.outlets = this.outlets.filter(function (currentOutlet) {
                var isEqualToCurrent;
                if (_this.currentOutlet) {
                    isEqualToCurrent = currentOutlet.pathByOutlets === _this.currentOutlet.pathByOutlets;
                }
                // Remove outlet from the url tree.
                if (currentOutlet.containsFrame(frame) && !isEqualToCurrent) {
                    _this.callPopState(null, true, currentOutlet);
                }
                // Skip frames filtering since currentOutlet is <router-outlet> when no frames available.
                if (currentOutlet.frames.length && !currentOutlet.isNSEmptyOutlet) {
                    currentOutlet.frames = currentOutlet.frames.filter(function (currentFrame) { return currentFrame !== frame; });
                    return currentOutlet.frames.length;
                }
                return !currentOutlet.containsFrame(frame);
            });
        };
        NSLocationStrategy.prototype.getSegmentGroupFullPath = function (segmentGroup) {
            var fullPath = '';
            while (segmentGroup) {
                var url = segmentGroup.toString();
                if (fullPath) {
                    fullPath = (url ? url + '/' : '') + fullPath;
                }
                else {
                    fullPath = url;
                }
                segmentGroup = segmentGroup.parent;
            }
            return fullPath;
        };
        NSLocationStrategy.prototype.getRouteFullPath = function (currentRoute) {
            var outletName = currentRoute.outlet;
            var fullPath;
            currentRoute = currentRoute.parent;
            while (currentRoute) {
                var urls = currentRoute.url.value || currentRoute.url;
                var url = urls;
                if (Array.isArray(urls)) {
                    url = url.join('/');
                }
                fullPath = fullPath ? (url ? url + '/' : url) + fullPath : url;
                currentRoute = currentRoute.parent;
            }
            return fullPath ? fullPath + '-' + outletName : outletName;
        };
        NSLocationStrategy.prototype.getPathByOutlets = function (urlSegmentGroup) {
            if (!urlSegmentGroup) {
                return '';
            }
            var pathToOutlet;
            var lastPath = urlSegmentGroup.outlet || 'primary';
            var parent = urlSegmentGroup.parent;
            while (parent && urlSegmentGroup.root !== parent) {
                if (parent && parent.outlet !== lastPath) {
                    if (lastPath === 'primary') {
                        lastPath = parent.outlet;
                    }
                    else {
                        lastPath = parent.outlet;
                        pathToOutlet = lastPath + '-' + (pathToOutlet || urlSegmentGroup.outlet);
                    }
                }
                parent = parent.parent;
            }
            return pathToOutlet || lastPath;
        };
        NSLocationStrategy.prototype.findOutlet = function (outletKey, activatedRouteSnapshot) {
            var _this = this;
            var outlet = this.outlets.find(function (currentOutlet) {
                var equalModalDepth = currentOutlet.modalNavigationDepth === _this._modalNavigationDepth;
                return equalModalDepth && currentOutlet.outletKeys.indexOf(outletKey) > -1;
            });
            // No Outlet with the given outletKey could happen when using nested unnamed p-r-o
            // primary -> primary -> prymary
            if (!outlet && activatedRouteSnapshot) {
                var pathByOutlets_1 = this.getPathByOutlets(activatedRouteSnapshot);
                outlet = this.outlets.find(function (currentOutlet) {
                    var equalModalDepth = currentOutlet.modalNavigationDepth === _this._modalNavigationDepth;
                    return equalModalDepth && currentOutlet.pathByOutlets === pathByOutlets_1;
                });
            }
            return outlet;
        };
        NSLocationStrategy.prototype.findOutletByModal = function (modalNavigation, isShowingModal) {
            return this.outlets.find(function (outlet) {
                var equalModalDepth = outlet.modalNavigationDepth === modalNavigation;
                return isShowingModal ? equalModalDepth && outlet.showingModal : equalModalDepth;
            });
        };
        NSLocationStrategy.prototype.getOutletByFrame = function (frame) {
            var outlet;
            for (var index = 0; index < this.outlets.length; index++) {
                var currentOutlet = this.outlets[index];
                if (currentOutlet.containsFrame(frame)) {
                    outlet = currentOutlet;
                    break;
                }
            }
            return outlet;
        };
        NSLocationStrategy.prototype.updateStates = function (outlet, currentSegmentGroup, queryParams) {
            var isNewPage = outlet.states.length === 0;
            var lastState = outlet.states[outlet.states.length - 1];
            var equalStateUrls = outlet.containsTopState(currentSegmentGroup.toString());
            var locationState = {
                segmentGroup: currentSegmentGroup,
                isRootSegmentGroup: false,
                isPageNavigation: isNewPage,
                queryParams: Object.assign({}, queryParams),
            };
            if (!lastState || !equalStateUrls) {
                outlet.states.push(locationState);
                // Update last state segmentGroup of parent Outlet.
                if (this._modalNavigationDepth === 0 && !outlet.showingModal) {
                    this.updateParentsStates(outlet, currentSegmentGroup.parent);
                }
                return true;
            }
            return false;
        };
        NSLocationStrategy.prototype.updateParentsStates = function (outlet, newSegmentGroup) {
            var parentOutlet = outlet.parent;
            // Update parents lastState segmentGroups
            while (parentOutlet && newSegmentGroup) {
                var state = parentOutlet.peekState();
                if (state) {
                    state.segmentGroup = newSegmentGroup;
                    newSegmentGroup = newSegmentGroup.parent;
                    parentOutlet = parentOutlet.parent;
                }
            }
        };
        // tslint:disable-next-line:max-line-length
        NSLocationStrategy.prototype.createOutlet = function (outletKey, path, segmentGroup, parent, modalNavigation, queryParams) {
            if (queryParams === void 0) { queryParams = {}; }
            var pathByOutlets = this.getPathByOutlets(segmentGroup);
            var newOutlet = new Outlet(outletKey, path, pathByOutlets, modalNavigation);
            var locationState = {
                segmentGroup: segmentGroup,
                isRootSegmentGroup: false,
                isPageNavigation: true,
                queryParams: Object.assign({}, queryParams),
            };
            newOutlet.states = [locationState];
            newOutlet.parent = parent;
            this.outlets.push(newOutlet);
            // Update last state segmentGroup of parent Outlet.
            if (this._modalNavigationDepth === 0 && !newOutlet.showingModal) {
                this.updateParentsStates(newOutlet, segmentGroup.parent);
            }
            return newOutlet;
        };
        NSLocationStrategy.prototype.getSegmentGroupByOutlet = function (outlet) {
            var pathList = outlet.pathByOutlets.split('-');
            var segmentGroup = this.currentUrlTree.root;
            var pathToOutlet;
            for (var index = 0; index < pathList.length; index++) {
                var currentPath = pathList[index];
                var childrenCount = Object.keys(segmentGroup.children).length;
                if (childrenCount && segmentGroup.children[currentPath]) {
                    var url = segmentGroup.toString();
                    pathToOutlet = pathToOutlet ? pathToOutlet + '/' + url : url;
                    segmentGroup = segmentGroup.children[currentPath];
                }
                else {
                    // If no child outlet found with the given name - forget about all previously found outlets.
                    // example: seaching for 'primary-second-primary' shouldn't return 'primary-second'
                    // if no 'primary' child available on 'second'.
                    segmentGroup = null;
                    break;
                }
            }
            // Paths should also match since there could be another Outlet
            // with the same pathByOutlets but different url path.
            if (segmentGroup && outlet.path && pathToOutlet && outlet.path !== pathToOutlet) {
                segmentGroup = null;
            }
            return segmentGroup;
        };
        // Traversal and replacement of segmentGroup.
        NSLocationStrategy.prototype.updateSegmentGroup = function (rootNode, oldSegmentGroup, newSegmentGroup) {
            var queue = [];
            var currentTree = rootNode;
            while (currentTree) {
                Object.keys(currentTree.children).forEach(function (outletName) {
                    if (currentTree.children[outletName] === oldSegmentGroup) {
                        if (newSegmentGroup) {
                            currentTree.children[outletName] = newSegmentGroup;
                        }
                        else {
                            delete currentTree.children[outletName];
                        }
                    }
                    queue.push(currentTree.children[outletName]);
                });
                currentTree = queue.shift();
            }
        };
        NSLocationStrategy.prototype.upsertModalOutlet = function (parentOutlet, segmentedGroup, queryParams) {
            var currentModalOutlet = this.findOutletByModal(this._modalNavigationDepth);
            // We want to treat every p-r-o as a standalone Outlet.
            if (!currentModalOutlet) {
                if (this._modalNavigationDepth > 1) {
                    // The parent of the current Outlet should be the previous opened modal (if any).
                    parentOutlet = this.findOutletByModal(this._modalNavigationDepth - 1);
                }
                // No currentModalOutlet available when opening 'primary' p-r-o.
                var outletName = 'primary';
                var outletPath = parentOutlet.peekState().segmentGroup.toString();
                var outletKey = this.getOutletKey(outletPath, outletName);
                // tslint:disable-next-line:max-line-length
                currentModalOutlet = this.createOutlet(outletKey, outletPath, segmentedGroup, parentOutlet, this._modalNavigationDepth, queryParams);
                this.currentOutlet = currentModalOutlet;
            }
            else if (this.updateStates(currentModalOutlet, segmentedGroup, queryParams)) {
                this.currentOutlet = currentModalOutlet; // If states updated
            }
        };
        NSLocationStrategy.prototype.getOutletKey = function (path, outletName) {
            return path ? path + '-' + outletName : outletName;
        };
        NSLocationStrategy.prototype.ngOnDestroy = function () {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog('NSLocationStrategy.ngOnDestroy()');
            }
            this.outlets = [];
            this.currentOutlet = null;
        };
        return NSLocationStrategy;
    }(common.LocationStrategy));
    NSLocationStrategy.Éµprov = i0.ÉµÉµdefineInjectable({ factory: function NSLocationStrategy_Factory() { return new NSLocationStrategy(i0.ÉµÉµinject(FrameService)); }, token: NSLocationStrategy, providedIn: "root" });
    NSLocationStrategy.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    NSLocationStrategy.ctorParameters = function () { return [
        { type: FrameService }
    ]; };

    /**
     * Wrapper component used for loading components when navigating
     * It uses DetachedContainer as selector so that it is containerRef is not attached to
     * the visual tree.
     */
    var DetachedLoader = /** @class */ (function () {
        // tslint:disable-line:component-class-suffix
        function DetachedLoader(resolver, changeDetector, containerRef) {
            this.resolver = resolver;
            this.changeDetector = changeDetector;
            this.containerRef = containerRef;
        }
        DetachedLoader.prototype.loadInLocation = function (componentType) {
            var factory = this.resolver.resolveComponentFactory(componentType);
            var componentRef = this.containerRef.createComponent(factory, this.containerRef.length, this.containerRef.injector);
            // Component is created, built may not be checked if we are loading
            // inside component with OnPush CD strategy. Mark us for check to be sure CD will reach us.
            // We are inside a promise here so no need for setTimeout - CD should trigger
            // after the promise.
            core.Trace.write('DetachedLoader.loadInLocation component loaded -> markForCheck', 'detached-loader');
            return Promise.resolve(componentRef);
        };
        DetachedLoader.prototype.detectChanges = function () {
            this.changeDetector.markForCheck();
        };
        // TODO: change this API -- async promises not needed here anymore.
        DetachedLoader.prototype.loadComponent = function (componentType) {
            core.Trace.write('DetachedLoader.loadComponent', 'detached-loader');
            return this.loadInLocation(componentType);
        };
        DetachedLoader.prototype.loadWithFactory = function (factory) {
            return this.containerRef.createComponent(factory, this.containerRef.length, this.containerRef.injector, null);
        };
        return DetachedLoader;
    }());
    DetachedLoader.decorators = [
        { type: i0.Component, args: [{
                    selector: 'DetachedContainer',
                    template: "<Placeholder #loader></Placeholder>"
                },] }
    ];
    DetachedLoader.ctorParameters = function () { return [
        { type: i0.ComponentFactoryResolver },
        { type: i0.ChangeDetectorRef },
        { type: i0.ViewContainerRef }
    ]; };

    /**
     * Utility method to ensure a NgModule is only imported once in a codebase, otherwise will throw to help prevent accidental double importing
     * @param parentModule Parent module name
     * @param moduleName The module name
     */
    function throwIfAlreadyLoaded(parentModule, moduleName) {
        if (parentModule) {
            throw new Error(moduleName + " has already been loaded. Import " + moduleName + " in the AppModule only.");
        }
    }
    /**
     * Utility method which will only fire the callback once ever
     * @param fn callback to call only once
     */
    function once(fn) {
        var wasCalled = false;
        return function wrapper() {
            if (wasCalled) {
                return;
            }
            wasCalled = true;
            fn.apply(null, arguments);
        };
    }

    var ModalDialogParams = /** @class */ (function () {
        function ModalDialogParams(context, closeCallback) {
            if (context === void 0) { context = {}; }
            this.context = context;
            this.closeCallback = closeCallback;
        }
        return ModalDialogParams;
    }());
    var ModalDialogService = /** @class */ (function () {
        function ModalDialogService(location) {
            this.location = location;
        }
        ModalDialogService.prototype.showModal = function (type, options) {
            var _this = this;
            if (!options.viewContainerRef) {
                throw new Error('No viewContainerRef: ' + 'Make sure you pass viewContainerRef in ModalDialogOptions.');
            }
            var parentView = options.viewContainerRef.element.nativeElement;
            if (options.target) {
                parentView = options.target;
            }
            if ((parentView instanceof AppHostView || parentView instanceof AppHostAsyncView) && parentView.ngAppRoot) {
                parentView = parentView.ngAppRoot;
            }
            // _ngDialogRoot is the first child of the previously detached proxy.
            // It should have 'viewController' (iOS) or '_dialogFragment' (Android) available for
            // presenting future modal views.
            if (parentView._ngDialogRoot) {
                parentView = parentView._ngDialogRoot;
            }
            var pageFactory = options.viewContainerRef.injector.get(PAGE_FACTORY);
            // resolve from particular module (moduleRef)
            // or from same module as parentView (viewContainerRef)
            var componentContainer = options.moduleRef || options.viewContainerRef;
            var resolver = componentContainer.injector.get(i0.ComponentFactoryResolver);
            var frame = parentView;
            if (!(parentView instanceof core.Frame)) {
                frame = (parentView.page && parentView.page.frame) || core.Frame.topmost();
            }
            this.location._beginModalNavigation(frame);
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    try {
                        _this._showDialog(Object.assign(Object.assign({}, options), { containerRef: options.viewContainerRef, context: options.context, doneCallback: resolve, pageFactory: pageFactory,
                            parentView: parentView,
                            resolver: resolver,
                            type: type }));
                    }
                    catch (err) {
                        reject(err);
                    }
                }, 10);
            });
        };
        ModalDialogService.prototype._showDialog = function (options) {
            var _this = this;
            var componentView;
            var detachedLoaderRef;
            var closeCallback = once(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                options.doneCallback.apply(undefined, args);
                if (componentView) {
                    componentView.closeModal();
                    _this.location._closeModalNavigation();
                    detachedLoaderRef.instance.detectChanges();
                    detachedLoaderRef.destroy();
                }
            });
            var modalParams = new ModalDialogParams(options.context, closeCallback);
            var childInjector = i0.Injector.create({
                providers: [{ provide: ModalDialogParams, useValue: modalParams }],
                parent: options.containerRef.injector,
            });
            var detachedFactory = options.resolver.resolveComponentFactory(DetachedLoader);
            detachedLoaderRef = options.containerRef.createComponent(detachedFactory, 0, childInjector, null);
            detachedLoaderRef.instance.loadComponent(options.type).then(function (compRef) {
                var detachedProxy = compRef.location.nativeElement;
                if (detachedProxy.getChildrenCount() > 1) {
                    throw new Error('Modal content has more than one root view.');
                }
                componentView = detachedProxy.getChildAt(0);
                if (componentView.parent) {
                    componentView.parent._ngDialogRoot = componentView;
                    componentView.parent.removeChild(componentView);
                }
                options.parentView.showModal(componentView, Object.assign(Object.assign({}, options), { closeCallback: closeCallback }));
            });
        };
        return ModalDialogService;
    }());
    ModalDialogService.decorators = [
        { type: i0.Injectable }
    ];
    ModalDialogService.ctorParameters = function () { return [
        { type: NSLocationStrategy }
    ]; };

    var InvisibleNode = /** @class */ (function (_super) {
        __extends(InvisibleNode, _super);
        function InvisibleNode() {
            var _this = _super.call(this) || this;
            _this.nodeType = 1;
            _this.nodeName = getClassName(_this);
            return _this;
        }
        InvisibleNode.prototype.toString = function () {
            return this.nodeName + "(" + this.id + ")";
        };
        return InvisibleNode;
    }(core.View));
    var CommentNode = /** @class */ (function (_super) {
        __extends(CommentNode, _super);
        function CommentNode() {
            var _this = _super.call(this) || this;
            _this.meta = {
                skipAddToDom: true,
            };
            _this.id = CommentNode.id.toString();
            CommentNode.id += 1;
            return _this;
        }
        return CommentNode;
    }(InvisibleNode));
    CommentNode.id = 0;
    var TextNode = /** @class */ (function (_super) {
        __extends(TextNode, _super);
        function TextNode() {
            var _this = _super.call(this) || this;
            _this.meta = {
                skipAddToDom: true,
            };
            _this.id = TextNode.id.toString();
            TextNode.id += 1;
            return _this;
        }
        return TextNode;
    }(InvisibleNode));
    TextNode.id = 0;
    var getClassName = function (instance) { return instance.constructor.name; };
    var Éµ0 = getClassName;
    function isDetachedElement(element) {
        return element && element.meta && element.meta.skipAddToDom;
    }
    function isView(view) {
        return view instanceof core.View;
    }
    function isInvisibleNode(view) {
        return view instanceof InvisibleNode;
    }
    var elementMap = new Map();
    var camelCaseSplit = /([a-z0-9])([A-Z])/g;
    var defaultViewMeta = { skipAddToDom: false };
    function registerElement(elementName, resolver, meta) {
        var entry = { resolver: resolver, meta: meta };
        elementMap.set(elementName, entry);
        elementMap.set(elementName.toLowerCase(), entry);
        elementMap.set(elementName.replace(camelCaseSplit, '$1-$2').toLowerCase(), entry);
    }
    function getViewClass(elementName) {
        var entry = elementMap.get(elementName) || elementMap.get(elementName.toLowerCase());
        if (!entry) {
            throw new TypeError("No known component for element " + elementName + ".");
        }
        try {
            return entry.resolver();
        }
        catch (e) {
            throw new TypeError("Could not load view for: " + elementName + "." + e);
        }
    }
    function getViewMeta(nodeName) {
        var entry = elementMap.get(nodeName) || elementMap.get(nodeName.toLowerCase());
        return (entry && entry.meta) || defaultViewMeta;
    }
    function isKnownView(elementName) {
        return elementMap.has(elementName) || elementMap.has(elementName.toLowerCase());
    }
    function getSingleViewRecursive(nodes, nestLevel) {
        var actualNodes = nodes.filter(function (node) { return !(node instanceof InvisibleNode); });
        if (actualNodes.length === 0) {
            throw new Error("No suitable views found in list template! " + ("Nesting level: " + nestLevel));
        }
        else if (actualNodes.length > 1) {
            throw new Error("More than one view found in list template!" + ("Nesting level: " + nestLevel));
        }
        var rootLayout = actualNodes[0];
        if (!rootLayout) {
            return getSingleViewRecursive(rootLayout.children, nestLevel + 1);
        }
        var parentLayout = rootLayout.parent;
        if (parentLayout instanceof core.LayoutBase) {
            var node = rootLayout.parentNode;
            parentLayout.removeChild(rootLayout);
            rootLayout.parentNode = node;
        }
        return rootLayout;
    }
    var Éµ1 = function (parent, child, next) {
        // Page cannot be added to Frame with _addChildFromBuilder (thwos "use defaultPage" error)
        if (isInvisibleNode(child)) {
            return;
        }
        else if (child instanceof core.Page) {
            parent.navigate({ create: function () { return child; } });
        }
        else {
            throw new Error('Only a Page can be a child of Frame');
        }
    };
    var frameMeta = {
        insertChild: Éµ1,
    };
    // Register default NativeScript components
    // Note: ActionBar related components are registerd together with action-bar directives.
    registerElement('AbsoluteLayout', function () { return core.AbsoluteLayout; });
    registerElement('ActivityIndicator', function () { return core.ActivityIndicator; });
    registerElement('BottomNavigation', function () { return core.BottomNavigation; });
    registerElement('Button', function () { return core.Button; });
    registerElement('ContentView', function () { return core.ContentView; });
    registerElement('DatePicker', function () { return core.DatePicker; });
    registerElement('DockLayout', function () { return core.DockLayout; });
    registerElement('Frame', function () { return core.Frame; }, frameMeta);
    registerElement('GridLayout', function () { return core.GridLayout; });
    registerElement('HtmlView', function () { return core.HtmlView; });
    registerElement('Image', function () { return core.Image; });
    // Parse5 changes <Image> tags to <img>. WTF!
    registerElement('img', function () { return core.Image; });
    registerElement('Label', function () { return core.Label; });
    registerElement('ListPicker', function () { return core.ListPicker; });
    registerElement('ListView', function () { return core.ListView; });
    registerElement('Page', function () { return core.Page; });
    registerElement('Placeholder', function () { return core.Placeholder; });
    registerElement('Progress', function () { return core.Progress; });
    registerElement('ProxyViewContainer', function () { return core.ProxyViewContainer; });
    registerElement('Repeater', function () { return core.Repeater; });
    registerElement('ScrollView', function () { return core.ScrollView; });
    registerElement('SearchBar', function () { return core.SearchBar; });
    registerElement('SegmentedBar', function () { return core.SegmentedBar; });
    registerElement('SegmentedBarItem', function () { return core.SegmentedBarItem; });
    registerElement('Slider', function () { return core.Slider; });
    registerElement('StackLayout', function () { return core.StackLayout; });
    registerElement('FlexboxLayout', function () { return core.FlexboxLayout; });
    registerElement('Switch', function () { return core.Switch; });
    registerElement('TabView', function () { return core.TabView; });
    registerElement('TabStrip', function () { return core.TabStrip; });
    registerElement('TabStripItem', function () { return core.TabStripItem; });
    registerElement('TabContentItem', function () { return core.TabContentItem; });
    registerElement('Tabs', function () { return core.Tabs; });
    registerElement('TextField', function () { return core.TextField; });
    registerElement('TextView', function () { return core.TextView; });
    registerElement('TimePicker', function () { return core.TimePicker; });
    registerElement('WebView', function () { return core.WebView; });
    registerElement('WrapLayout', function () { return core.WrapLayout; });
    registerElement('FormattedString', function () { return core.FormattedString; });
    registerElement('Span', function () { return core.Span; });
    registerElement('DetachedContainer', function () { return core.ProxyViewContainer; }, {
        skipAddToDom: true,
    });
    registerElement('page-router-outlet', function () { return core.Frame; });

    var NG_VIEW = '_ngViewRef';
    var ItemContext = /** @class */ (function () {
        function ItemContext($implicit, item, index, even, odd) {
            this.$implicit = $implicit;
            this.item = item;
            this.index = index;
            this.even = even;
            this.odd = odd;
        }
        return ItemContext;
    }());
    var TemplatedItemsComponent = /** @class */ (function () {
        function TemplatedItemsComponent(_elementRef, _iterableDiffers) {
            this._iterableDiffers = _iterableDiffers;
            this.setupItemView = new i0.EventEmitter();
            this.templatedItemsView = _elementRef.nativeElement;
            this.templatedItemsView.on('itemLoading', this.onItemLoading, this);
        }
        Object.defineProperty(TemplatedItemsComponent.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (value) {
                this._items = value;
                var needDiffer = true;
                if (value instanceof core.ObservableArray) {
                    needDiffer = false;
                }
                if (needDiffer && !this._differ && i0.ÉµisListLikeIterable(value)) {
                    this._differ = this._iterableDiffers.find(this._items).create(function (_index, item) {
                        return item;
                    });
                }
                this.templatedItemsView.items = this._items;
            },
            enumerable: false,
            configurable: true
        });
        TemplatedItemsComponent.prototype.ngAfterContentInit = function () {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.listViewLog('TemplatedItemsView.ngAfterContentInit()');
            }
            this.setItemTemplates();
        };
        TemplatedItemsComponent.prototype.ngOnDestroy = function () {
            this.templatedItemsView.off('itemLoading', this.onItemLoading, this);
            this.templatedItemsView = null;
            if (this._templateMap) {
                this._templateMap.clear();
            }
        };
        TemplatedItemsComponent.prototype.setItemTemplates = function () {
            // The itemTemplateQuery may be changed after list items are added that contain <template> inside,
            // so cache and use only the original template to avoid errors.
            this.itemTemplate = this.itemTemplateQuery;
            if (this._templateMap) {
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.listViewLog('Setting templates');
                }
                var templates_1 = [];
                this._templateMap.forEach(function (value) {
                    templates_1.push(value);
                });
                this.templatedItemsView.itemTemplates = templates_1;
            }
        };
        TemplatedItemsComponent.prototype.registerTemplate = function (key, template) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.listViewLog("registerTemplate for key: " + key);
            }
            if (!this._templateMap) {
                this._templateMap = new Map();
            }
            var keyedTemplate = {
                key: key,
                createView: this.getItemTemplateViewFactory(template),
            };
            this._templateMap.set(key, keyedTemplate);
        };
        TemplatedItemsComponent.prototype.onItemLoading = function (args) {
            if (!args.view && !this.itemTemplate) {
                return;
            }
            var index = args.index;
            var items = args.object.items;
            var currentItem = typeof items.getItem === 'function' ? items.getItem(index) : items[index];
            var viewRef;
            if (args.view) {
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.listViewLog("onItemLoading: " + index + " - Reusing existing view");
                }
                viewRef = args.view[NG_VIEW];
                // Getting angular view from original element (in cases when ProxyViewContainer
                // is used NativeScript internally wraps it in a StackLayout)
                if (!viewRef && args.view instanceof core.LayoutBase && args.view.getChildrenCount() > 0) {
                    viewRef = args.view.getChildAt(0)[NG_VIEW];
                }
                if (!viewRef && exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.listViewError("ViewReference not found for item " + index + ". View recycling is not working");
                }
                // No ng-template is setup, continue with 'defaultTemplate'
                if (!viewRef) {
                    return;
                }
            }
            if (!viewRef) {
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.listViewLog("onItemLoading: " + index + " - Creating view from template");
                }
                viewRef = this.loader.createEmbeddedView(this.itemTemplate, new ItemContext(), 0);
                args.view = getItemViewRoot(viewRef);
                args.view[NG_VIEW] = viewRef;
            }
            this.setupViewRef(viewRef, currentItem, index);
            this.detectChangesOnChild(viewRef, index);
        };
        TemplatedItemsComponent.prototype.setupViewRef = function (viewRef, data, index) {
            var context = viewRef.context;
            context.$implicit = data;
            context.item = data;
            context.index = index;
            context.even = index % 2 === 0;
            context.odd = !context.even;
            this.setupItemView.next({ view: viewRef, data: data, index: index, context: context });
        };
        TemplatedItemsComponent.prototype.getItemTemplateViewFactory = function (template) {
            var _this = this;
            return function () {
                var viewRef = _this.loader.createEmbeddedView(template, new ItemContext(), 0);
                var resultView = getItemViewRoot(viewRef);
                resultView[NG_VIEW] = viewRef;
                return resultView;
            };
        };
        TemplatedItemsComponent.prototype.detectChangesOnChild = function (viewRef, index) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.listViewLog("Manually detect changes in child: " + index);
            }
            viewRef.markForCheck();
            viewRef.detectChanges();
        };
        TemplatedItemsComponent.prototype.ngDoCheck = function () {
            if (this._differ) {
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.listViewLog('ngDoCheck() - execute differ');
                }
                var changes = this._differ.diff(this._items);
                if (changes) {
                    if (exports.NativeScriptDebug.isLogEnabled()) {
                        exports.NativeScriptDebug.listViewLog('ngDoCheck() - refresh');
                    }
                    this.templatedItemsView.refresh();
                }
            }
        };
        return TemplatedItemsComponent;
    }());
    TemplatedItemsComponent.decorators = [
        { type: i0.Directive }
    ];
    TemplatedItemsComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.IterableDiffers }
    ]; };
    TemplatedItemsComponent.propDecorators = {
        loader: [{ type: i0.ViewChild, args: ['loader', { read: i0.ViewContainerRef, static: false },] }],
        setupItemView: [{ type: i0.Output }],
        itemTemplateQuery: [{ type: i0.ContentChild, args: [i0.TemplateRef, { read: i0.TemplateRef, static: false },] }],
        items: [{ type: i0.Input }]
    };
    __decorate([
        core.profile
    ], TemplatedItemsComponent.prototype, "onItemLoading", null);
    __decorate([
        core.profile
    ], TemplatedItemsComponent.prototype, "detectChangesOnChild", null);
    function getItemViewRoot(viewRef, rootLocator) {
        if (rootLocator === void 0) { rootLocator = getSingleViewRecursive; }
        var rootView = rootLocator(viewRef.rootNodes, 0);
        return rootView;
    }
    var TEMPLATED_ITEMS_COMPONENT = new i0.InjectionToken('TemplatedItemsComponent');
    var TemplateKeyDirective = /** @class */ (function () {
        function TemplateKeyDirective(templateRef, comp) {
            this.templateRef = templateRef;
            this.comp = comp;
        }
        Object.defineProperty(TemplateKeyDirective.prototype, "nsTemplateKey", {
            set: function (value) {
                if (this.comp && this.templateRef) {
                    this.comp.registerTemplate(value, this.templateRef);
                }
            },
            enumerable: false,
            configurable: true
        });
        return TemplateKeyDirective;
    }());
    TemplateKeyDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[nsTemplateKey]' },] }
    ];
    TemplateKeyDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef },
        { type: TemplatedItemsComponent, decorators: [{ type: i0.Inject, args: [TEMPLATED_ITEMS_COMPONENT,] }, { type: i0.Host }] }
    ]; };
    TemplateKeyDirective.propDecorators = {
        nsTemplateKey: [{ type: i0.Input }]
    };

    var ListViewComponent = /** @class */ (function (_super) {
        __extends(ListViewComponent, _super);
        function ListViewComponent(_elementRef, _iterableDiffers) {
            return _super.call(this, _elementRef, _iterableDiffers) || this;
        }
        Object.defineProperty(ListViewComponent.prototype, "nativeElement", {
            get: function () {
                return this.templatedItemsView;
            },
            enumerable: false,
            configurable: true
        });
        return ListViewComponent;
    }(TemplatedItemsComponent));
    ListViewComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ListView',
                    template: " <DetachedContainer>\n\t\t<Placeholder #loader></Placeholder>\n\t</DetachedContainer>",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    providers: [{ provide: TEMPLATED_ITEMS_COMPONENT, useExisting: i0.forwardRef(function () { return ListViewComponent; }) }]
                },] }
    ];
    ListViewComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.IterableDiffers }
    ]; };

    var TabViewDirective = /** @class */ (function () {
        function TabViewDirective(element) {
            this.tabView = element.nativeElement;
        }
        Object.defineProperty(TabViewDirective.prototype, "selectedIndex", {
            get: function () {
                return this._selectedIndex;
            },
            set: function (value) {
                this._selectedIndex = value;
                if (this.viewInitialized) {
                    this.tabView.selectedIndex = this._selectedIndex;
                }
            },
            enumerable: false,
            configurable: true
        });
        TabViewDirective.prototype.ngAfterViewInit = function () {
            this.viewInitialized = true;
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog('this._selectedIndex: ' + this._selectedIndex);
            }
            if (!isBlank(this._selectedIndex)) {
                this.tabView.selectedIndex = this._selectedIndex;
            }
        };
        return TabViewDirective;
    }());
    TabViewDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'TabView',
                },] }
    ];
    TabViewDirective.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    TabViewDirective.propDecorators = {
        selectedIndex: [{ type: i0.Input }]
    };
    var TabViewItemDirective = /** @class */ (function () {
        function TabViewItemDirective(owner, templateRef, viewContainer) {
            this.owner = owner;
            this.templateRef = templateRef;
            this.viewContainer = viewContainer;
        }
        Object.defineProperty(TabViewItemDirective.prototype, "config", {
            get: function () {
                // tslint:disable-line:no-input-rename
                return this._config || {};
            },
            set: function (config) {
                if (!this._config || this._config.iconSource !== config.iconSource || this._config.title !== config.title || this._config.textTransform !== config.textTransform) {
                    this._config = config;
                    this.applyConfig();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TabViewItemDirective.prototype, "title", {
            get: function () {
                return this.config.title;
            },
            set: function (title) {
                this.config = Object.assign(this.config, { title: title });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TabViewItemDirective.prototype, "iconSource", {
            get: function () {
                return this.config.iconSource;
            },
            set: function (iconSource) {
                this.config = Object.assign(this.config, { iconSource: iconSource });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TabViewItemDirective.prototype, "textTransform", {
            get: function () {
                return this.config.textTransform;
            },
            set: function (textTransform) {
                this.config = Object.assign(this.config, { textTransform: textTransform });
            },
            enumerable: false,
            configurable: true
        });
        TabViewItemDirective.prototype.ensureItem = function () {
            if (!this.item) {
                this.item = new core.TabViewItem();
            }
        };
        TabViewItemDirective.prototype.applyConfig = function () {
            this.ensureItem();
            if (this.config.title) {
                this.item.title = this.config.title;
            }
            if (this.config.iconSource) {
                this.item.iconSource = this.config.iconSource;
            }
            //  TabViewItem textTransform has a default value for Android that kick in
            // only if no value (even a null value) is set.
            if (this.config.textTransform) {
                this.item.textTransform = this.config.textTransform;
            }
        };
        TabViewItemDirective.prototype.ngOnInit = function () {
            this.applyConfig();
            var viewRef = this.viewContainer.createEmbeddedView(this.templateRef);
            // Filter out text nodes and comments
            var realViews = viewRef.rootNodes.filter(function (node) { return !(node instanceof InvisibleNode); });
            if (realViews.length > 0) {
                this.item.view = realViews[0];
                var newItems = (this.owner.tabView.items || []).concat([this.item]);
                this.owner.tabView.items = newItems;
            }
        };
        return TabViewItemDirective;
    }());
    TabViewItemDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[tabItem]',
                },] }
    ];
    TabViewItemDirective.ctorParameters = function () { return [
        { type: TabViewDirective },
        { type: i0.TemplateRef },
        { type: i0.ViewContainerRef }
    ]; };
    TabViewItemDirective.propDecorators = {
        config: [{ type: i0.Input, args: ['tabItem',] }],
        title: [{ type: i0.Input }],
        iconSource: [{ type: i0.Input }],
        textTransform: [{ type: i0.Input }]
    };

    function isActionItem(view) {
        return view instanceof core.ActionItem;
    }
    function isNavigationButton(view) {
        return view instanceof core.NavigationButton;
    }
    var Éµ0$1 = function (parent, child, next) {
        if (isInvisibleNode(child)) {
            return;
        }
        else if (isNavigationButton(child)) {
            parent.navigationButton = child;
            child.parentNode = parent;
        }
        else if (isActionItem(child)) {
            addActionItem(parent, child, next);
            child.parentNode = parent;
        }
        else if (isView(child)) {
            parent.titleView = child;
        }
    }, Éµ1$1 = function (parent, child) {
        if (isInvisibleNode(child)) {
            return;
        }
        else if (isNavigationButton(child)) {
            if (parent.navigationButton === child) {
                parent.navigationButton = null;
            }
            child.parentNode = null;
        }
        else if (isActionItem(child)) {
            parent.actionItems.removeItem(child);
            child.parentNode = null;
        }
        else if (isView(child) && parent.titleView && parent.titleView === child) {
            parent.titleView = null;
        }
    };
    var actionBarMeta = {
        skipAddToDom: true,
        insertChild: Éµ0$1,
        removeChild: Éµ1$1,
    };
    var addActionItem = function (bar, item, next) {
        if (next) {
            insertActionItemBefore(bar, item, next);
        }
        else {
            appendActionItem(bar, item);
        }
    };
    var Éµ2 = addActionItem;
    var insertActionItemBefore = function (bar, item, next) {
        var actionItems = bar.actionItems;
        var actionItemsCollection = actionItems.getItems();
        var indexToInsert = actionItemsCollection.indexOf(next);
        actionItemsCollection.splice(indexToInsert, 0, item);
        actionItems.setItems(actionItemsCollection);
    };
    var Éµ3 = insertActionItemBefore;
    var appendActionItem = function (bar, item) {
        bar.actionItems.addItem(item);
    };
    var Éµ4 = appendActionItem;
    registerElement('ActionBar', function () { return core.ActionBar; }, actionBarMeta);
    registerElement('ActionItem', function () { return core.ActionItem; });
    registerElement('NavigationButton', function () { return core.NavigationButton; });
    var ActionBarComponent = /** @class */ (function () {
        function ActionBarComponent(element, page) {
            this.element = element;
            this.page = page;
            if (!this.page) {
                throw new Error('Inside ActionBarComponent but no Page found in DI.');
            }
            if (isBlank(this.page.actionBarHidden)) {
                this.page.actionBarHidden = false;
            }
            this.page.actionBar = this.element.nativeElement;
            this.page.actionBar.update();
        }
        return ActionBarComponent;
    }());
    ActionBarComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ActionBar',
                    template: '<ng-content></ng-content>'
                },] }
    ];
    ActionBarComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: core.Page }
    ]; };
    var ActionBarScope = /** @class */ (function () {
        // tslint:disable-line:component-class-suffix
        function ActionBarScope(page) {
            this.page = page;
            if (!this.page) {
                throw new Error('Inside ActionBarScope but no Page found in DI.');
            }
        }
        ActionBarScope.prototype.onNavButtonInit = function (navBtn) {
            this.page.actionBar.navigationButton = navBtn.element.nativeElement;
        };
        ActionBarScope.prototype.onNavButtonDestroy = function (navBtn) {
            var nav = navBtn.element.nativeElement;
            if (nav && this.page.actionBar.navigationButton === nav) {
                this.page.actionBar.navigationButton = null;
            }
        };
        ActionBarScope.prototype.onActionInit = function (item) {
            this.page.actionBar.actionItems.addItem(item.element.nativeElement);
        };
        ActionBarScope.prototype.onActionDestroy = function (item) {
            if (item.element.nativeElement.actionBar) {
                this.page.actionBar.actionItems.removeItem(item.element.nativeElement);
            }
        };
        return ActionBarScope;
    }());
    ActionBarScope.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ActionBarExtension',
                    template: ''
                },] }
    ];
    ActionBarScope.ctorParameters = function () { return [
        { type: core.Page }
    ]; };
    var ActionItemDirective = /** @class */ (function () {
        function ActionItemDirective(element, ownerScope) {
            this.element = element;
            this.ownerScope = ownerScope;
            if (this.ownerScope) {
                this.ownerScope.onActionInit(this);
            }
        }
        ActionItemDirective.prototype.ngOnDestroy = function () {
            if (this.ownerScope) {
                this.ownerScope.onActionDestroy(this);
            }
        };
        return ActionItemDirective;
    }());
    ActionItemDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'ActionItem',
                },] }
    ];
    ActionItemDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: ActionBarScope, decorators: [{ type: i0.Optional }] }
    ]; };
    var NavigationButtonDirective = /** @class */ (function () {
        function NavigationButtonDirective(element, ownerScope) {
            this.element = element;
            this.ownerScope = ownerScope;
            if (this.ownerScope) {
                this.ownerScope.onNavButtonInit(this);
            }
        }
        NavigationButtonDirective.prototype.ngOnDestroy = function () {
            if (this.ownerScope) {
                this.ownerScope.onNavButtonDestroy(this);
            }
        };
        return NavigationButtonDirective;
    }());
    NavigationButtonDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'NavigationButton',
                },] }
    ];
    NavigationButtonDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: ActionBarScope, decorators: [{ type: i0.Optional }] }
    ]; };

    var AndroidFilterComponent = /** @class */ (function () {
        function AndroidFilterComponent() {
            this.show = core.isAndroid;
        }
        return AndroidFilterComponent;
    }());
    AndroidFilterComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'android',
                    template: "<ng-content *ngIf=\"show\"></ng-content>"
                },] }
    ];
    AndroidFilterComponent.ctorParameters = function () { return []; };
    var IosFilterComponent = /** @class */ (function () {
        function IosFilterComponent() {
            this.show = core.isIOS;
        }
        return IosFilterComponent;
    }());
    IosFilterComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ios',
                    template: "<ng-content *ngIf=\"show\"></ng-content>"
                },] }
    ];
    IosFilterComponent.ctorParameters = function () { return []; };

    var NS_DIRECTIVES = [ListViewComponent, TemplateKeyDirective, TabViewDirective, TabViewItemDirective, ActionBarComponent, ActionBarScope, ActionItemDirective, NavigationButtonDirective, AndroidFilterComponent, IosFilterComponent];

    var NativeScriptCommonModule = /** @class */ (function () {
        function NativeScriptCommonModule() {
        }
        return NativeScriptCommonModule;
    }());
    NativeScriptCommonModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [ListViewComponent, TemplateKeyDirective, TabViewDirective, TabViewItemDirective, ActionBarComponent, ActionBarScope, ActionItemDirective, NavigationButtonDirective, AndroidFilterComponent, IosFilterComponent],
                    providers: [ModalDialogService, defaultDeviceProvider, defaultFrameProvider, defaultPageProvider],
                    imports: [common.CommonModule],
                    exports: [common.CommonModule, ListViewComponent, TemplateKeyDirective, TabViewDirective, TabViewItemDirective, ActionBarComponent, ActionBarScope, ActionItemDirective, NavigationButtonDirective, AndroidFilterComponent, IosFilterComponent],
                    schemas: [i0.NO_ERRORS_SCHEMA],
                },] }
    ];

    var ELEMENT_NODE_TYPE = 1;
    var XML_ATTRIBUTES = Object.freeze(['style', 'rows', 'columns', 'fontAttributes']);
    var whiteSpaceSplitter = /\s+/;
    function isLayout(view) {
        return view instanceof core.LayoutBase;
    }
    function isContentView(view) {
        return view instanceof core.ContentView;
    }
    var propertyMaps = new Map();
    var ViewUtil = /** @class */ (function () {
        function ViewUtil(device) {
            this.isIos = device.os === core.platformNames.ios;
            this.isAndroid = device.os === core.platformNames.android;
        }
        ViewUtil.prototype.insertChild = function (parent, child, previous, next) {
            if (!parent) {
                return;
            }
            var extendedParent = this.ensureNgViewExtensions(parent);
            var extendedChild = this.ensureNgViewExtensions(child);
            if (!previous) {
                previous = extendedParent.lastChild;
            }
            this.addToQueue(extendedParent, extendedChild, previous, next);
            if (isInvisibleNode(child)) {
                extendedChild.parentNode = extendedParent;
            }
            if (!isDetachedElement(child)) {
                var nextVisual = this.findNextVisual(next);
                this.addToVisualTree(extendedParent, extendedChild, nextVisual);
            }
        };
        ViewUtil.prototype.addToQueue = function (parent, child, previous, next) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.viewUtilLog("ViewUtil.addToQueue parent: " + parent + ", view: " + child + ", " + ("previous: " + previous + ", next: " + next));
            }
            if (previous) {
                previous.nextSibling = child;
            }
            else {
                parent.firstChild = child;
            }
            if (next) {
                child.nextSibling = next;
            }
            else {
                this.appendToQueue(parent, child);
            }
        };
        ViewUtil.prototype.appendToQueue = function (parent, view) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.viewUtilLog("ViewUtil.appendToQueue parent: " + parent + " view: " + view);
            }
            if (parent.lastChild) {
                parent.lastChild.nextSibling = view;
            }
            parent.lastChild = view;
        };
        ViewUtil.prototype.addToVisualTree = function (parent, child, next) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.viewUtilLog("ViewUtil.addToVisualTree parent: " + parent + ", view: " + child + ", next: " + next);
            }
            if (parent.meta && parent.meta.insertChild) {
                parent.meta.insertChild(parent, child, next);
            }
            else if (isLayout(parent)) {
                this.insertToLayout(parent, child, next);
            }
            else if (isContentView(parent)) {
                parent.content = child;
            }
            else if (parent && parent._addChildFromBuilder) {
                parent._addChildFromBuilder(child.nodeName, child);
            }
        };
        ViewUtil.prototype.insertToLayout = function (parent, child, next) {
            if (child.parent === parent) {
                this.removeLayoutChild(parent, child);
            }
            var nextVisual = this.findNextVisual(next);
            if (nextVisual) {
                var index = parent.getChildIndex(nextVisual);
                parent.insertChild(child, index);
            }
            else {
                parent.addChild(child);
            }
        };
        ViewUtil.prototype.findNextVisual = function (view) {
            var next = view;
            while (next && isDetachedElement(next)) {
                next = next.nextSibling;
            }
            return next;
        };
        ViewUtil.prototype.removeChild = function (parent, child) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.viewUtilLog("ViewUtil.removeChild parent: " + parent + " child: " + child);
            }
            if (!parent) {
                return;
            }
            var extendedParent = this.ensureNgViewExtensions(parent);
            var extendedChild = this.ensureNgViewExtensions(child);
            this.removeFromQueue(extendedParent, extendedChild);
            if (!isDetachedElement(extendedChild)) {
                this.removeFromVisualTree(extendedParent, extendedChild);
            }
        };
        ViewUtil.prototype.removeFromQueue = function (parent, child) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.viewUtilLog("ViewUtil.removeFromQueue parent: " + parent + " child: " + child);
            }
            if (parent.firstChild === child && parent.lastChild === child) {
                parent.firstChild = null;
                parent.lastChild = null;
                child.nextSibling = null;
                return;
            }
            if (parent.firstChild === child) {
                parent.firstChild = child.nextSibling;
            }
            var previous = this.findPreviousElement(parent, child);
            if (parent.lastChild === child) {
                parent.lastChild = previous;
            }
            if (previous) {
                previous.nextSibling = child.nextSibling;
            }
            child.nextSibling = null;
        };
        // NOTE: This one is O(n) - use carefully
        ViewUtil.prototype.findPreviousElement = function (parent, child) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.viewUtilLog("ViewUtil.findPreviousElement parent: " + parent + " child: " + child);
            }
            var previousVisual;
            if (isLayout(parent)) {
                previousVisual = this.getPreviousVisualElement(parent, child);
            }
            var previous = previousVisual || parent.firstChild;
            // since detached elements are not added to the visual tree,
            // we need to find the actual previous sibling of the view,
            // which may as well be an invisible node
            while (previous && previous !== child && previous.nextSibling !== child) {
                previous = previous.nextSibling;
            }
            return previous;
        };
        ViewUtil.prototype.getPreviousVisualElement = function (parent, child) {
            var elementIndex = parent.getChildIndex(child);
            if (elementIndex > 0) {
                return parent.getChildAt(elementIndex - 1);
            }
        };
        // NOTE: This one is O(n) - use carefully
        ViewUtil.prototype.getChildIndex = function (parent, child) {
            if (isLayout(parent)) {
                return parent.getChildIndex(child);
            }
            else if (isContentView(parent)) {
                return child === parent.content ? 0 : -1;
            }
        };
        ViewUtil.prototype.removeFromVisualTree = function (parent, child) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.viewUtilLog("ViewUtil.removeFromVisualTree parent: " + parent + " child: " + child);
            }
            if (parent.meta && parent.meta.removeChild) {
                parent.meta.removeChild(parent, child);
            }
            else if (isLayout(parent)) {
                this.removeLayoutChild(parent, child);
            }
            else if (isContentView(parent) && parent.content === child) {
                parent.content = null;
            }
            else if (isView(parent)) {
                parent._removeView(child);
            }
        };
        ViewUtil.prototype.removeLayoutChild = function (parent, child) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.viewUtilLog("ViewUtil.removeLayoutChild parent: " + parent + " child: " + child);
            }
            var index = parent.getChildIndex(child);
            if (index !== -1) {
                parent.removeChild(child);
            }
        };
        ViewUtil.prototype.createComment = function () {
            return new CommentNode();
        };
        ViewUtil.prototype.createText = function () {
            return new TextNode();
        };
        ViewUtil.prototype.createView = function (name) {
            var originalName = name;
            if (!isKnownView(name)) {
                name = 'ProxyViewContainer';
            }
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.viewUtilLog("Creating view: " + originalName + " " + name);
            }
            var viewClass = getViewClass(name);
            var view = new viewClass();
            var ngView = this.setNgViewExtensions(view, name);
            return ngView;
        };
        ViewUtil.prototype.ensureNgViewExtensions = function (view) {
            if (view.hasOwnProperty('meta')) {
                return view;
            }
            else {
                var name = view.cssType;
                var ngView = this.setNgViewExtensions(view, name);
                return ngView;
            }
        };
        ViewUtil.prototype.setNgViewExtensions = function (view, name) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.viewUtilLog("Make into a NgView view: " + view + " name: \"" + name + "\"");
            }
            var ngView = view;
            ngView.nodeName = name;
            ngView.meta = getViewMeta(name);
            // we're setting the node type of the view
            // to 'element' because of checks done in the
            // dom animation engine
            ngView.nodeType = ELEMENT_NODE_TYPE;
            return ngView;
        };
        ViewUtil.prototype.setProperty = function (view, attributeName, value, namespace) {
            if (!view || (namespace && !this.runsIn(namespace))) {
                return;
            }
            if (attributeName.indexOf('.') !== -1) {
                // Handle nested properties
                var properties = attributeName.split('.');
                attributeName = properties[properties.length - 1];
                var propMap = this.getProperties(view);
                var i = 0;
                while (i < properties.length - 1 && typeof view !== 'undefined') {
                    var prop = properties[i];
                    if (propMap.has(prop)) {
                        prop = propMap.get(prop);
                    }
                    view = view[prop];
                    propMap = this.getProperties(view);
                    i++;
                }
            }
            if (typeof view !== 'undefined') {
                this.setPropertyInternal(view, attributeName, value);
            }
        };
        ViewUtil.prototype.runsIn = function (platform) {
            return (platform === 'ios' && this.isIos) || (platform === 'android' && this.isAndroid);
        };
        ViewUtil.prototype.setPropertyInternal = function (view, attributeName, value) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.viewUtilLog("Setting attribute: " + attributeName + "=" + value + " to " + view);
            }
            if (attributeName === 'class') {
                this.setClasses(view, value);
                return;
            }
            if (XML_ATTRIBUTES.indexOf(attributeName) !== -1) {
                view[attributeName] = value;
                return;
            }
            var propMap = this.getProperties(view);
            var propertyName = propMap.get(attributeName);
            // Ensure the children of a collection currently have no parent set.
            if (Array.isArray(value)) {
                this.removeParentReferencesFromItems(value);
            }
            if (propertyName) {
                // We have a lower-upper case mapped property.
                view[propertyName] = value;
                return;
            }
            // Unknown attribute value -- just set it to our object as is.
            view[attributeName] = value;
        };
        ViewUtil.prototype.removeParentReferencesFromItems = function (items) {
            var e_1, _a;
            try {
                for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                    var item = items_1_1.value;
                    if (item.parent && item.parentNode) {
                        if (exports.NativeScriptDebug.isLogEnabled()) {
                            exports.NativeScriptDebug.viewUtilLog("Unassigning parent " + item.parentNode + " on value: " + item);
                        }
                        item.parent = undefined;
                        item.parentNode = undefined;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        ViewUtil.prototype.getProperties = function (instance) {
            var type = instance && instance.constructor;
            if (!type) {
                return new Map();
            }
            if (!propertyMaps.has(type)) {
                var propMap = new Map();
                for (var propName in instance) {
                    // tslint:disable:forin
                    propMap.set(propName.toLowerCase(), propName);
                }
                propertyMaps.set(type, propMap);
            }
            return propertyMaps.get(type);
        };
        ViewUtil.prototype.cssClasses = function (view) {
            if (!view.ngCssClasses) {
                view.ngCssClasses = new Map();
            }
            return view.ngCssClasses;
        };
        ViewUtil.prototype.addClass = function (view, className) {
            this.cssClasses(view).set(className, true);
            this.syncClasses(view);
        };
        ViewUtil.prototype.removeClass = function (view, className) {
            this.cssClasses(view).delete(className);
            this.syncClasses(view);
        };
        ViewUtil.prototype.setClasses = function (view, classesValue) {
            var _this = this;
            var classes = classesValue.split(whiteSpaceSplitter);
            this.cssClasses(view).clear();
            classes.forEach(function (className) { return _this.cssClasses(view).set(className, true); });
            this.syncClasses(view);
        };
        ViewUtil.prototype.syncClasses = function (view) {
            var classValue = Array.from(this.cssClasses(view).keys()).join(' ');
            view.className = classValue;
        };
        ViewUtil.prototype.setStyle = function (view, styleName, value) {
            view.style[styleName] = value;
        };
        ViewUtil.prototype.removeStyle = function (view, styleName) {
            view.style[styleName] = core.unsetValue;
        };
        return ViewUtil;
    }());

    var NativeScriptRenderer = /** @class */ (function (_super) {
        __extends(NativeScriptRenderer, _super);
        function NativeScriptRenderer(rootView, zone, viewUtil) {
            var _this = _super.call(this) || this;
            _this.rootView = rootView;
            _this.zone = zone;
            _this.viewUtil = viewUtil;
            _this.data = Object.create(null);
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog('NativeScriptRenderer created');
            }
            return _this;
        }
        NativeScriptRenderer.prototype.appendChild = function (parent, newChild) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.appendChild child: " + newChild + " parent: " + parent);
            }
            this.viewUtil.insertChild(parent, newChild);
        };
        NativeScriptRenderer.prototype.insertBefore = function (parent, newChild, _a) {
            var previous = _a.previous, next = _a.next;
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.insertBefore child: " + newChild + " " + ("parent: " + parent + " previous: " + previous + " next: " + next));
            }
            this.viewUtil.insertChild(parent, newChild, previous, next);
        };
        NativeScriptRenderer.prototype.removeChild = function (parent, oldChild) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.removeChild child: " + oldChild + " parent: " + parent);
            }
            this.viewUtil.removeChild(parent, oldChild);
        };
        NativeScriptRenderer.prototype.selectRootElement = function (selector) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.selectRootElement: " + selector);
            }
            if (selector && selector[0] === '#') {
                var result = core.getViewById(this.rootView, selector.slice(1));
                return (result || this.rootView);
            }
            return this.rootView;
        };
        NativeScriptRenderer.prototype.parentNode = function (node) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.parentNode for node: " + node + " is " + node.parentNode);
            }
            return node.parentNode;
        };
        NativeScriptRenderer.prototype.nextSibling = function (node) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.nextSibling of " + node + " is " + node.nextSibling);
            }
            return {
                previous: node,
                next: node.nextSibling,
            };
        };
        NativeScriptRenderer.prototype.createComment = function (_value) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.createComment " + _value);
            }
            return this.viewUtil.createComment();
        };
        NativeScriptRenderer.prototype.createElement = function (name, _namespace) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.createElement: " + name);
            }
            return this.viewUtil.createView(name);
        };
        NativeScriptRenderer.prototype.createText = function (_value) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.createText " + _value);
            }
            return this.viewUtil.createText();
        };
        NativeScriptRenderer.prototype.createViewRoot = function (hostElement) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.createViewRoot " + hostElement.nodeName);
            }
            return hostElement;
        };
        NativeScriptRenderer.prototype.projectNodes = function (parentElement, nodes) {
            var _this = this;
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog('NativeScriptRenderer.projectNodes');
            }
            nodes.forEach(function (node) { return _this.viewUtil.insertChild(parentElement, node); });
        };
        NativeScriptRenderer.prototype.destroy = function () {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog('NativeScriptRenderer.destroy');
            }
            // Seems to be called on component dispose only (router outlet)
            // TODO: handle this when we resolve routing and navigation.
        };
        NativeScriptRenderer.prototype.setAttribute = function (view, name, value, namespace) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.setAttribute " + view + " : " + name + " = " + value + ", namespace: " + namespace);
            }
            return this.viewUtil.setProperty(view, name, value, namespace);
        };
        NativeScriptRenderer.prototype.removeAttribute = function (_el, _name) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.removeAttribute " + _el + ": " + _name);
            }
        };
        NativeScriptRenderer.prototype.setProperty = function (view, name, value) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.setProperty " + view + " : " + name + " = " + value);
            }
            return this.viewUtil.setProperty(view, name, value);
        };
        NativeScriptRenderer.prototype.addClass = function (view, name) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.addClass " + name);
            }
            this.viewUtil.addClass(view, name);
        };
        NativeScriptRenderer.prototype.removeClass = function (view, name) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.removeClass " + name);
            }
            this.viewUtil.removeClass(view, name);
        };
        NativeScriptRenderer.prototype.setStyle = function (view, styleName, value, _flags) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.setStyle: " + styleName + " = " + value);
            }
            this.viewUtil.setStyle(view, styleName, value);
        };
        NativeScriptRenderer.prototype.removeStyle = function (view, styleName, _flags) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog('NativeScriptRenderer.removeStyle: ${styleName}');
            }
            this.viewUtil.removeStyle(view, styleName);
        };
        // Used only in debug mode to serialize property changes to comment nodes,
        // such as <template> placeholders.
        NativeScriptRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.setBindingDebugInfo: " + renderElement + ", " + propertyName + " = " + propertyValue);
            }
        };
        NativeScriptRenderer.prototype.setElementDebugInfo = function (renderElement, _info /*RenderDebugInfo*/) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.setElementDebugInfo: " + renderElement);
            }
        };
        NativeScriptRenderer.prototype.invokeElementMethod = function (_renderElement, methodName, args) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.invokeElementMethod " + methodName + " " + args);
            }
        };
        NativeScriptRenderer.prototype.setValue = function (_renderNode, _value) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.setValue renderNode: " + _renderNode + ", value: " + _value);
            }
        };
        NativeScriptRenderer.prototype.listen = function (renderElement, eventName, callback) {
            var _this = this;
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRenderer.listen: " + eventName);
            }
            // Explicitly wrap in zone
            var zonedCallback = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                _this.zone.run(function () {
                    callback.apply(undefined, args);
                });
            };
            renderElement.on(eventName, zonedCallback);
            if (eventName === core.View.loadedEvent && renderElement.isLoaded) {
                var notifyData = { eventName: core.View.loadedEvent, object: renderElement };
                zonedCallback(notifyData);
            }
            return function () { return renderElement.off(eventName, zonedCallback); };
        };
        return NativeScriptRenderer;
    }(i0.Renderer2));
    NativeScriptRenderer.decorators = [
        { type: i0.Injectable }
    ];
    NativeScriptRenderer.ctorParameters = function () { return [
        { type: undefined },
        { type: i0.NgZone },
        { type: ViewUtil }
    ]; };
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "appendChild", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "insertBefore", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "removeChild", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "selectRootElement", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "parentNode", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "nextSibling", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "createComment", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "createElement", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "createText", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "createViewRoot", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "projectNodes", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "destroy", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "setAttribute", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "removeAttribute", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "setProperty", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "addClass", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "removeClass", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "setStyle", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "removeStyle", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "setBindingDebugInfo", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "setElementDebugInfo", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "invokeElementMethod", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "setValue", null);
    __decorate([
        core.profile
    ], NativeScriptRenderer.prototype, "listen", null);

    // CONTENT_ATTR not exported from NativeScript_renderer - we need it for styles application.
    var COMPONENT_REGEX = /%COMP%/g;
    var ATTR_SANITIZER = /-/g;
    var COMPONENT_VARIABLE = '%COMP%';
    var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
    var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
    var replaceNgAttribute = function (input, componentId) {
        return input.replace(COMPONENT_REGEX, componentId);
    };
    var Éµ0$2 = replaceNgAttribute;
    var Éµ1$2 = function addScopedStyleToCss(style) {
        core.Application.addCss(style, true);
    };
    var addScopedStyleToCss = core.profile("\"renderer\".addScopedStyleToCss", Éµ1$2);
    var EmulatedRenderer = /** @class */ (function (_super) {
        __extends(EmulatedRenderer, _super);
        function EmulatedRenderer(component, rootView, zone, viewUtil) {
            var _this = _super.call(this, rootView, zone, viewUtil) || this;
            var componentId = component.id.replace(ATTR_SANITIZER, '_');
            _this.contentAttr = replaceNgAttribute(CONTENT_ATTR, componentId);
            _this.hostAttr = replaceNgAttribute(HOST_ATTR, componentId);
            _this.addStyles(component.styles, componentId);
            return _this;
        }
        EmulatedRenderer.prototype.applyToHost = function (view) {
            _super.prototype.setAttribute.call(this, view, this.hostAttr, '');
        };
        EmulatedRenderer.prototype.appendChild = function (parent, newChild) {
            _super.prototype.appendChild.call(this, parent, newChild);
        };
        EmulatedRenderer.prototype.createElement = function (parent, name) {
            var view = _super.prototype.createElement.call(this, parent, name);
            // Set an attribute to the view to scope component-specific css.
            // The property name is pre-generated by Angular.
            _super.prototype.setAttribute.call(this, view, this.contentAttr, '');
            return view;
        };
        EmulatedRenderer.prototype.addStyles = function (styles, componentId) {
            styles
                .map(function (s) { return s.toString(); })
                .map(function (s) { return replaceNgAttribute(s, componentId); })
                .forEach(addScopedStyleToCss);
        };
        return EmulatedRenderer;
    }(NativeScriptRenderer));
    EmulatedRenderer.decorators = [
        { type: i0.Injectable }
    ];
    EmulatedRenderer.ctorParameters = function () { return [
        { type: undefined },
        { type: undefined },
        { type: i0.NgZone },
        { type: ViewUtil }
    ]; };
    __decorate([
        core.profile
    ], EmulatedRenderer.prototype, "addStyles", null);

    var Éµ0$3 = function addStyleToCss(style) {
        core.Application.addCss(style);
    };
    var addStyleToCss = core.profile('"renderer".addStyleToCss', Éµ0$3);
    var NativeScriptRendererFactory = /** @class */ (function () {
        function NativeScriptRendererFactory(rootView, zone) {
            this.zone = zone;
            this.componentRenderers = new Map();
            this.viewUtil = new ViewUtil(core.Device);
            this.setRootNgView(rootView);
            this.defaultRenderer = new NativeScriptRenderer(this.rootNgView, zone, this.viewUtil);
        }
        NativeScriptRendererFactory.prototype.setRootNgView = function (rootView) {
            if (!rootView) {
                rootView = getRootPage();
            }
            rootView.nodeName = 'NONE';
            this.rootNgView = rootView;
        };
        NativeScriptRendererFactory.prototype.createRenderer = function (element, type) {
            if (!element || !type) {
                return this.defaultRenderer;
            }
            var renderer = this.componentRenderers.get(type.id);
            if (renderer) {
                if (renderer instanceof EmulatedRenderer) {
                    renderer.applyToHost(element);
                }
                return renderer;
            }
            if (type.encapsulation === i0.ViewEncapsulation.None) {
                type.styles.map(function (s) { return s.toString(); }).forEach(addStyleToCss);
                renderer = this.defaultRenderer;
            }
            else {
                renderer = new EmulatedRenderer(type, this.rootNgView, this.zone, this.viewUtil);
                renderer.applyToHost(element);
            }
            this.componentRenderers.set(type.id, renderer);
            return renderer;
        };
        NativeScriptRendererFactory.prototype.ngOnDestroy = function () {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.rendererLog("NativeScriptRendererFactory.ngOnDestroy()");
            }
            while (this.rootNgView && this.rootNgView.firstChild) {
                this.viewUtil.removeChild(this.rootNgView, this.rootNgView.firstChild);
            }
        };
        return NativeScriptRendererFactory;
    }());
    NativeScriptRendererFactory.decorators = [
        { type: i0.Injectable }
    ];
    NativeScriptRendererFactory.ctorParameters = function () { return [
        { type: core.View, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [APP_ROOT_VIEW,] }] },
        { type: i0.NgZone }
    ]; };

    function errorHandlerFactory() {
        return new i0.ErrorHandler();
    }
    var NativeScriptModule = /** @class */ (function () {
        function NativeScriptModule(parentModule) {
            // Prevents NativeScriptModule from getting imported multiple times
            throwIfAlreadyLoaded(parentModule, 'NativeScriptModule');
        }
        return NativeScriptModule;
    }());
    NativeScriptModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [DetachedLoader],
                    providers: [FrameService, NativeScriptRendererFactory, i0.SystemJsNgModuleLoader, { provide: i0.ÉµINJECTOR_SCOPE, useValue: 'root' }, { provide: i0.ErrorHandler, useFactory: errorHandlerFactory }, { provide: i0.RendererFactory2, useExisting: NativeScriptRendererFactory }, { provide: common.ViewportScroller, useClass: common.ÉµNullViewportScroller }],
                    entryComponents: [DetachedLoader],
                    imports: [i0.ApplicationModule, NativeScriptCommonModule],
                    exports: [i0.ApplicationModule, NativeScriptCommonModule, DetachedLoader],
                    schemas: [i0.NO_ERRORS_SCHEMA],
                },] }
    ];
    NativeScriptModule.ctorParameters = function () { return [
        { type: NativeScriptModule, decorators: [{ type: i0.Optional }, { type: i0.SkipSelf }] }
    ]; };

    var DASH_CASE_REGEXP = /-+([a-z0-9])/g;
    function dashCaseToCamelCase(input) {
        return input.replace(DASH_CASE_REGEXP, function () {
            var m = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                m[_i] = arguments[_i];
            }
            return m[1].toUpperCase();
        });
    }
    function createKeyframeAnimation(styles, duration, delay, easing) {
        var info = createKeyframeAnimationInfo(styles, duration, delay, easing);
        return core.KeyframeAnimation.keyframeAnimationFromInfo(info);
    }
    var createKeyframeAnimationInfo = function (styles, duration, delay, easing) { return ({
        isForwards: true,
        duration: duration || 0.01,
        delay: delay,
        curve: getCurve(easing),
        keyframes: styles.map(parseAnimationKeyframe),
    }); };
    var Éµ0$4 = createKeyframeAnimationInfo;
    var getCurve = function (value) { return core.animationTimingFunctionConverter(value); };
    var Éµ1$3 = getCurve;
    var parseAnimationKeyframe = function (styles) { return ({
        duration: getKeyframeDuration(styles),
        declarations: getDeclarations(styles),
    }); };
    var Éµ2$1 = parseAnimationKeyframe;
    var getKeyframeDuration = function (styles) { return styles.offset; };
    var Éµ3$1 = getKeyframeDuration;
    function getDeclarations(styles) {
        var unparsedDeclarations = Object.keys(styles).map(function (property) { return ({ property: property, value: styles[property] }); });
        return core.parseKeyframeDeclarations(unparsedDeclarations);
    }

    var NativeScriptAnimationPlayer = /** @class */ (function () {
        function NativeScriptAnimationPlayer(target, keyframes, duration, delay, easing) {
            this.target = target;
            this.duration = duration;
            this.delay = delay;
            this.parentPlayer = null;
            this._startSubscriptions = [];
            this._doneSubscriptions = [];
            this._finished = false;
            this._started = false;
            this.initKeyframeAnimation(keyframes, duration, delay, easing);
        }
        Object.defineProperty(NativeScriptAnimationPlayer.prototype, "totalTime", {
            get: function () {
                return this.delay + this.duration;
            },
            enumerable: false,
            configurable: true
        });
        NativeScriptAnimationPlayer.prototype.init = function () { };
        NativeScriptAnimationPlayer.prototype.hasStarted = function () {
            return this._started;
        };
        NativeScriptAnimationPlayer.prototype.onStart = function (fn) {
            this._startSubscriptions.push(fn);
        };
        NativeScriptAnimationPlayer.prototype.onDone = function (fn) {
            this._doneSubscriptions.push(fn);
        };
        NativeScriptAnimationPlayer.prototype.onDestroy = function (fn) {
            this._doneSubscriptions.push(fn);
        };
        NativeScriptAnimationPlayer.prototype.play = function () {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.animationsLog("NativeScriptAnimationPlayer.play");
            }
            if (!this.animation) {
                return;
            }
            if (!this._started) {
                this._started = true;
                this._startSubscriptions.forEach(function (fn) { return fn(); });
                this._startSubscriptions = [];
            }
            // When this issue https://github.com/NativeScript/NativeScript/issues/7984 is fixes in @nativescript/core
            // we can change this fix and apply the one that is recommended in that issue.
            if (this.target.isLoaded) {
                this.playAnimation();
            }
            else {
                this.target.on(core.View.loadedEvent, this.onTargetLoaded.bind(this));
            }
        };
        NativeScriptAnimationPlayer.prototype.onTargetLoaded = function (args) {
            this.target.off(core.View.loadedEvent, this.onTargetLoaded);
            this.playAnimation();
        };
        NativeScriptAnimationPlayer.prototype.playAnimation = function () {
            var _this = this;
            this.animation
                .play(this.target)
                .then(function () { return _this.onFinish(); })
                .catch(function (_e) { });
        };
        NativeScriptAnimationPlayer.prototype.pause = function () { };
        NativeScriptAnimationPlayer.prototype.finish = function () {
            this.onFinish();
        };
        NativeScriptAnimationPlayer.prototype.reset = function () {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.animationsLog("NativeScriptAnimationPlayer.reset");
            }
            if (this.animation && this.animation.isPlaying) {
                this.animation.cancel();
            }
        };
        NativeScriptAnimationPlayer.prototype.restart = function () {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.animationsLog("NativeScriptAnimationPlayer.restart");
            }
            this.reset();
            this.play();
        };
        NativeScriptAnimationPlayer.prototype.destroy = function () {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.animationsLog("NativeScriptAnimationPlayer.destroy");
            }
            this.onFinish();
        };
        NativeScriptAnimationPlayer.prototype.setPosition = function (_p) {
            throw new Error('AnimationPlayer.setPosition method is not supported!');
        };
        NativeScriptAnimationPlayer.prototype.getPosition = function () {
            return 0;
        };
        NativeScriptAnimationPlayer.prototype.initKeyframeAnimation = function (keyframes, duration, delay, easing) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.animationsLog("NativeScriptAnimationPlayer.initKeyframeAnimation");
            }
            this.animation = createKeyframeAnimation(keyframes, duration, delay, easing);
        };
        NativeScriptAnimationPlayer.prototype.onFinish = function () {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.animationsLog("NativeScriptAnimationPlayer.onFinish");
            }
            if (this._finished) {
                return;
            }
            this._finished = true;
            this._started = false;
            this._doneSubscriptions.forEach(function (fn) { return fn(); });
            this._doneSubscriptions = [];
        };
        return NativeScriptAnimationPlayer;
    }());

    var Selector = /** @class */ (function () {
        function Selector(rawSelector) {
            this.parse(rawSelector);
        }
        Selector.prototype.match = function (element) {
            return this.nsSelectorMatch(element) || this.classSelectorsMatch(element);
        };
        Selector.prototype.parse = function (rawSelector) {
            var selectors = rawSelector.split(',').map(function (s) { return s.trim(); });
            this.nsSelectors = selectors.map(core.CSSHelper.createSelector);
            this.classSelectors = selectors.filter(function (s) { return s.startsWith('.'); }).map(function (s) { return s.substring(1); });
        };
        Selector.prototype.nsSelectorMatch = function (element) {
            return this.nsSelectors.some(function (s) { return s.match(element); });
        };
        Selector.prototype.classSelectorsMatch = function (element) {
            var _this = this;
            return this.classSelectors.some(function (s) { return _this.hasClass(element, s); });
        };
        // we're using that instead of match for classes
        // that are dynamically added by the animation engine
        // such as .ng-trigger, that's added for every :enter view
        Selector.prototype.hasClass = function (element, cls) {
            return element && element['$$classes'] && element['$$classes'][cls];
        };
        return Selector;
    }());
    var NativeScriptAnimationDriver = /** @class */ (function () {
        function NativeScriptAnimationDriver() {
        }
        NativeScriptAnimationDriver.prototype.validateStyleProperty = function (property) {
            exports.NativeScriptDebug.animationsLog("CssAnimationProperty.validateStyleProperty: " + property);
            return NativeScriptAnimationDriver.validProperties.indexOf(property) !== -1;
        };
        NativeScriptAnimationDriver.prototype.matchesElement = function (element, rawSelector) {
            exports.NativeScriptDebug.animationsLog("NativeScriptAnimationDriver.matchesElement " + ("element: " + element + ", selector: " + rawSelector));
            var selector = this.makeSelector(rawSelector);
            return selector.match(element);
        };
        NativeScriptAnimationDriver.prototype.containsElement = function (elm1, elm2) {
            exports.NativeScriptDebug.animationsLog("NativeScriptAnimationDriver.containsElement " + ("element1: " + elm1 + ", element2: " + elm2));
            // Checking if the parent is our fake body object
            if (elm1['isOverride']) {
                return true;
            }
            var params = { originalView: elm2 };
            var result = this.visitDescendants(elm1, viewMatches, params);
            return result.found;
        };
        NativeScriptAnimationDriver.prototype.query = function (element, rawSelector, multi) {
            exports.NativeScriptDebug.animationsLog("NativeScriptAnimationDriver.query " + ("element: " + element + ", selector: " + rawSelector + " ") + ("multi: " + multi));
            var selector = this.makeSelector(rawSelector);
            var params = { selector: selector, multi: multi };
            var result = this.visitDescendants(element, queryDescendants, params);
            return result.matches || [];
        };
        NativeScriptAnimationDriver.prototype.computeStyle = function (element, prop) {
            exports.NativeScriptDebug.animationsLog("NativeScriptAnimationDriver.computeStyle " + ("element: " + element + ", prop: " + prop));
            var camelCaseProp = dashCaseToCamelCase(prop);
            return element.style[camelCaseProp];
        };
        NativeScriptAnimationDriver.prototype.animate = function (element, keyframes, duration, delay, easing) {
            exports.NativeScriptDebug.animationsLog("NativeScriptAnimationDriver.animate " + ("element: " + element + ", keyframes: " + keyframes + " ") + ("duration: " + duration + ", delay: " + delay + " ") + ("easing: " + easing));
            return new NativeScriptAnimationPlayer(element, keyframes, duration, delay, easing);
        };
        NativeScriptAnimationDriver.prototype.makeSelector = function (rawSelector) {
            return new Selector(rawSelector);
        };
        NativeScriptAnimationDriver.prototype.visitDescendants = function (element, cb, cbParams) {
            var result = {};
            // fill the result obj with the result from the callback function
            core.eachDescendant(element, function (child) { return cb(child, result, cbParams); });
            return result;
        };
        return NativeScriptAnimationDriver;
    }());
    NativeScriptAnimationDriver.validProperties = __spread(core.CssAnimationProperty._getPropertyNames(), ['transform']);
    function viewMatches(element, result, params) {
        if (element === params.originalView) {
            result.found = true;
        }
        return !result.found;
    }
    function queryDescendants(element, result, params) {
        if (!result.matches) {
            result.matches = [];
        }
        var selector = params.selector, multi = params.multi;
        // skip comment and text nodes
        // because they are not actual Views
        // and cannot be animated
        if (element instanceof InvisibleNode || !selector.match(element)) {
            return true;
        }
        if (element instanceof core.ProxyViewContainer) {
            element.eachChild(function (child) {
                result.matches.push(child);
                return true;
            });
        }
        else {
            result.matches.push(element);
        }
        return multi;
    }

    var InjectableAnimationEngine = /** @class */ (function (_super) {
        __extends(InjectableAnimationEngine, _super);
        function InjectableAnimationEngine(doc, driver, normalizer) {
            return _super.call(this, doc.body, driver, normalizer) || this;
        }
        return InjectableAnimationEngine;
    }(browser.ÉµAnimationEngine));
    InjectableAnimationEngine.decorators = [
        { type: i0.Injectable }
    ];
    InjectableAnimationEngine.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [common.DOCUMENT,] }] },
        { type: browser.AnimationDriver },
        { type: browser.ÉµAnimationStyleNormalizer }
    ]; };
    function instantiateSupportedAnimationDriver() {
        return new NativeScriptAnimationDriver();
    }
    function instantiateRendererFactory(renderer, engine, zone) {
        return new animations$1.ÉµAnimationRendererFactory(renderer, engine, zone);
    }
    function instantiateDefaultStyleNormalizer() {
        return new browser.ÉµWebAnimationsStyleNormalizer();
    }
    var NativeScriptAnimationsModule = /** @class */ (function () {
        function NativeScriptAnimationsModule(parentModule) {
            // Prevents NativeScriptAnimationsModule from getting imported multiple times
            throwIfAlreadyLoaded(parentModule, 'NativeScriptAnimationsModule');
        }
        return NativeScriptAnimationsModule;
    }());
    NativeScriptAnimationsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [NativeScriptCommonModule],
                    providers: [
                        {
                            provide: browser.AnimationDriver,
                            useFactory: instantiateSupportedAnimationDriver,
                        },
                        { provide: animations.AnimationBuilder, useClass: animations$1.ÉµBrowserAnimationBuilder },
                        {
                            provide: browser.ÉµAnimationStyleNormalizer,
                            useFactory: instantiateDefaultStyleNormalizer,
                        },
                        { provide: browser.ÉµAnimationEngine, useClass: InjectableAnimationEngine },
                        {
                            provide: i0.RendererFactory2,
                            useFactory: instantiateRendererFactory,
                            deps: [NativeScriptRendererFactory, browser.ÉµAnimationEngine, i0.NgZone],
                        },
                    ],
                },] }
    ];
    NativeScriptAnimationsModule.ctorParameters = function () { return [
        { type: NativeScriptAnimationsModule, decorators: [{ type: i0.Optional }, { type: i0.SkipSelf }] }
    ]; };

    function isLocalRequest(url) {
        return url.indexOf('~') === 0 || url.indexOf('/') === 0;
    }
    function getAbsolutePath(url, nsFileSystem) {
        url = url.replace('~', '').replace('/', '');
        url = core.path.join(nsFileSystem.currentApp().path, url);
        return url;
    }
    function processLocalFileRequest(url, nsFileSystem, successResponse, errorResponse) {
        url = getAbsolutePath(url, nsFileSystem);
        // request from local app resources
        return new rxjs.Observable(function (observer) {
            if (nsFileSystem.fileExists(url)) {
                var localFile = nsFileSystem.fileFromPath(url);
                localFile.readText().then(function (data) {
                    try {
                        var json = JSON.parse(data);
                        observer.next(successResponse(url, json, 200));
                        observer.complete();
                    }
                    catch (error) {
                        // Even though the response status was 2xx, this is still an error.
                        // The parse error contains the text of the body that failed to parse.
                        var errorResult = { error: error, text: data };
                        observer.error(errorResponse(url, errorResult, 200));
                    }
                }, function (err) {
                    observer.error(errorResponse(url, err, 400));
                });
            }
            else {
                observer.error(errorResponse(url, 'Not Found', 404));
            }
        });
    }

    var NsHttpBackEnd = /** @class */ (function (_super) {
        __extends(NsHttpBackEnd, _super);
        function NsHttpBackEnd(xhrFactory, nsFileSystem) {
            var _this = _super.call(this, xhrFactory) || this;
            _this.nsFileSystem = nsFileSystem;
            return _this;
        }
        NsHttpBackEnd.prototype.handle = function (req) {
            var result;
            if (isLocalRequest(req.url)) {
                result = this.handleLocalFileRequest(req.url);
            }
            else {
                result = _super.prototype.handle.call(this, req);
            }
            return result;
        };
        NsHttpBackEnd.prototype.handleLocalFileRequest = function (url) {
            return processLocalFileRequest(url, this.nsFileSystem, createSuccessResponse, createErrorResponse);
        };
        return NsHttpBackEnd;
    }(http.HttpXhrBackend));
    NsHttpBackEnd.decorators = [
        { type: i0.Injectable }
    ];
    NsHttpBackEnd.ctorParameters = function () { return [
        { type: http.XhrFactory },
        { type: NSFileSystem }
    ]; };
    function createSuccessResponse(url, body, status) {
        return new http.HttpResponse({
            url: url,
            body: body,
            status: status,
            statusText: 'OK',
        });
    }
    function createErrorResponse(url, body, status) {
        return new http.HttpErrorResponse({
            url: url,
            error: body,
            status: status,
            statusText: 'ERROR',
        });
    }

    var NativeScriptHttpClientModule = /** @class */ (function () {
        function NativeScriptHttpClientModule() {
        }
        return NativeScriptHttpClientModule;
    }());
    NativeScriptHttpClientModule.decorators = [
        { type: i0.NgModule, args: [{
                    providers: [NSFileSystem, NsHttpBackEnd, { provide: http.HttpBackend, useExisting: NsHttpBackEnd }],
                    imports: [http.HttpClientModule],
                    exports: [http.HttpClientModule],
                },] }
    ];

    var BaseValueAccessor = /** @class */ (function () {
        function BaseValueAccessor(view) {
            this.view = view;
            this.pendingChangeNotification = 0;
            this.onChange = function (_) { };
            this.onTouched = function () { };
        }
        BaseValueAccessor.prototype.registerOnChange = function (fn) {
            var _this = this;
            this.onChange = function (arg) {
                if (_this.pendingChangeNotification) {
                    clearTimeout(_this.pendingChangeNotification);
                }
                _this.pendingChangeNotification = setTimeout(function () {
                    _this.pendingChangeNotification = 0;
                    fn(arg);
                }, 20);
            };
        };
        BaseValueAccessor.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        BaseValueAccessor.prototype.setDisabledState = function (isDisabled) {
            this.view.isEnabled = !isDisabled;
        };
        BaseValueAccessor.prototype.writeValue = function (_) { };
        BaseValueAccessor.prototype.normalizeValue = function (value) {
            return isBlank(value) ? core.unsetValue : value;
        };
        return BaseValueAccessor;
    }());

    var TEXT_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return TextValueAccessor; }),
        multi: true,
    };
    /**
     * The accessor for writing a text and listening to changes that is used by the
     * {@link NgModel} directives.
     *
     *  ### Example
     *  ```
     *  <TextField [(ngModel)]="model.test">
     *  ```
     */
    var TextValueAccessor = /** @class */ (function (_super) {
        __extends(TextValueAccessor, _super);
        // tslint:disable-line:directive-class-suffix
        function TextValueAccessor(elementRef) {
            return _super.call(this, elementRef.nativeElement) || this;
        }
        TextValueAccessor.prototype.writeValue = function (value) {
            var normalized = _super.prototype.normalizeValue.call(this, value);
            this.view.text = normalized;
        };
        return TextValueAccessor;
    }(BaseValueAccessor));
    TextValueAccessor.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'TextField[ngModel],TextField[formControlName],TextField[formControl],' +
                        'textField[ngModel],textField[formControlName],textField[formControl],' +
                        'textfield[ngModel],textfield[formControlName],textfield[formControl],' +
                        'text-field[ngModel],text-field[formControlName],text-field[formControl],' +
                        'TextView[ngModel],TextView[formControlName],TextView[formControl],' +
                        'textView[ngModel],textView[formControlName],textView[formControl],' +
                        'textview[ngModel],textview[formControlName],textview[formControl],' +
                        'text-view[ngModel],text-view[formControlName],text-view[formControl],' +
                        'SearchBar[ngModel],SearchBar[formControlName],SearchBar[formControl],' +
                        'searchBar[ngModel],searchBar[formControlName],searchBar[formControl],' +
                        'searchbar[ngModel],searchbar[formControlName],searchbar[formControl],' +
                        'search-bar[ngModel], search-bar[formControlName],search-bar[formControl]',
                    providers: [TEXT_VALUE_ACCESSOR],
                    host: {
                        '(blur)': 'onTouched()',
                        '(textChange)': 'onChange($event.value)',
                    },
                },] }
    ];
    TextValueAccessor.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };

    var CHECKED_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return CheckedValueAccessor; }),
        multi: true,
    };
    /**
     * The accessor for setting a checked property and listening to changes that is used by the
     * {@link NgModel} directives.
     *
     *  ### Example
     *  ```
     *  <Switch [(ngModel)]="model.test">
     *  ```
     */
    var CheckedValueAccessor = /** @class */ (function (_super) {
        __extends(CheckedValueAccessor, _super);
        // tslint:disable-line:directive-class-suffix
        function CheckedValueAccessor(elementRef) {
            return _super.call(this, elementRef.nativeElement) || this;
        }
        CheckedValueAccessor.prototype.writeValue = function (value) {
            var normalized = _super.prototype.normalizeValue.call(this, value);
            this.view.checked = normalized;
        };
        return CheckedValueAccessor;
    }(BaseValueAccessor));
    CheckedValueAccessor.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'Switch[ngModel],Switch[formControlName],Switch[formControl],' + 'switch[ngModel],switch[formControlName],switch[formControl]',
                    providers: [CHECKED_VALUE_ACCESSOR],
                    host: {
                        '(checkedChange)': 'onChange($event.value)',
                    },
                },] }
    ];
    CheckedValueAccessor.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };

    var DATE_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return DateValueAccessor; }),
        multi: true,
    };
    /**
     * The accessor for setting a date and listening to changes that is used by the
     * {@link NgModel} directives.
     *
     *  ### Example
     *  ```
     *  <DatePicker [(ngModel)]="model.test">
     *  ```
     */
    var DateValueAccessor = /** @class */ (function (_super) {
        __extends(DateValueAccessor, _super);
        // tslint:disable-line:directive-class-suffix
        function DateValueAccessor(elementRef) {
            return _super.call(this, elementRef.nativeElement) || this;
        }
        DateValueAccessor.prototype.writeValue = function (value) {
            var normalized = _super.prototype.normalizeValue.call(this, value);
            this.view.date = normalized;
        };
        return DateValueAccessor;
    }(BaseValueAccessor));
    DateValueAccessor.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'DatePicker[ngModel],DatePicker[formControlName],DatePicker[formControl],' + 'datepicker[ngModel],datepicker[formControlName],datepicker[formControl],' + 'datePicker[ngModel],datePicker[formControlName],datePicker[formControl],' + 'date-picker[ngModel],date-picker[formControlName],date-picker[formControl]',
                    providers: [DATE_VALUE_ACCESSOR],
                    host: {
                        '(dateChange)': 'onChange($event.value)',
                    },
                },] }
    ];
    DateValueAccessor.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };

    var TIME_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return TimeValueAccessor; }),
        multi: true,
    };
    /**
     * The accessor for setting a time and listening to changes that is used by the
     * {@link NgModel} directives.
     *
     *  ### Example
     *  ```
     *  <TimePicker [(ngModel)]="model.test">
     *  ```
     */
    var TimeValueAccessor = /** @class */ (function (_super) {
        __extends(TimeValueAccessor, _super);
        // tslint:disable-line:directive-class-suffix
        function TimeValueAccessor(elementRef) {
            return _super.call(this, elementRef.nativeElement) || this;
        }
        TimeValueAccessor.prototype.writeValue = function (value) {
            var normalized = _super.prototype.normalizeValue.call(this, value);
            this.view.time = normalized;
        };
        return TimeValueAccessor;
    }(BaseValueAccessor));
    TimeValueAccessor.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'TimePicker[ngModel],TimePicker[formControlName],TimePicker[formControl],' + 'timepicker[ngModel],timepicker[formControlName],timepicker[formControl],' + 'timePicker[ngModel],timePicker[formControlName],timePicker[formControl],' + 'time-picker[ngModel],time-picker[formControlName],time-picker[formControl]',
                    providers: [TIME_VALUE_ACCESSOR],
                    host: {
                        '(timeChange)': 'onChange($event.value)',
                    },
                },] }
    ];
    TimeValueAccessor.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };

    var NUMBER_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return NumberValueAccessor; }),
        multi: true,
    };
    /**
     * The accessor for setting a value and listening to changes that is used by the
     * {@link NgModel}
     *
     *  ### Example
     *  ```
     *  <Slider [(ngModel)]="model.test">
     *  ```
     */
    var NumberValueAccessor = /** @class */ (function (_super) {
        __extends(NumberValueAccessor, _super);
        // tslint:disable-line:directive-class-suffix
        function NumberValueAccessor(elementRef) {
            return _super.call(this, elementRef.nativeElement) || this;
        }
        NumberValueAccessor.prototype.writeValue = function (value) {
            var normalized = _super.prototype.normalizeValue.call(this, value);
            this.view.value = normalized;
        };
        return NumberValueAccessor;
    }(BaseValueAccessor));
    NumberValueAccessor.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'Slider[ngModel],Slider[formControlName],Slider[formControl],' + 'slider[ngModel],slider[formControlName],slider[formControl]',
                    providers: [NUMBER_VALUE_ACCESSOR],
                    host: {
                        '(valueChange)': 'onChange($event.value)',
                    },
                },] }
    ];
    NumberValueAccessor.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };

    var SELECTED_INDEX_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return SelectedIndexValueAccessor; }),
        multi: true,
    };
    /**
     * The accessor for setting a selectedIndex and listening to changes that is used by the
     * {@link NgModel} directives.
     *
     *  ### Example
     *  ```
     *  <SegmentedBar [(ngModel)]="model.test">
     *  ```
     */
    var SelectedIndexValueAccessor = /** @class */ (function (_super) {
        __extends(SelectedIndexValueAccessor, _super);
        // tslint:disable-line:max-line-length directive-class-suffix
        function SelectedIndexValueAccessor(elementRef) {
            return _super.call(this, elementRef.nativeElement) || this;
        }
        SelectedIndexValueAccessor.prototype.writeValue = function (value) {
            var normalized = _super.prototype.normalizeValue.call(this, value);
            this.value = normalized;
            if (this.viewInitialized) {
                this.view.selectedIndex = this.value;
            }
        };
        SelectedIndexValueAccessor.prototype.ngAfterViewInit = function () {
            this.viewInitialized = true;
            this.view.selectedIndex = this.value;
        };
        return SelectedIndexValueAccessor;
    }(BaseValueAccessor));
    SelectedIndexValueAccessor.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'SegmentedBar[ngModel],SegmentedBar[formControlName],SegmentedBar[formControl],' +
                        'segmentedBar[ngModel],segmentedBar[formControlName],segmentedBar[formControl],' +
                        'segmentedbar[ngModel],segmentedbar[formControlName],segmentedbar[formControl],' +
                        'segmented-bar[ngModel],segmented-bar[formControlName],segmented-bar[formControl],' +
                        'ListPicker[ngModel],ListPicker[formControlName],ListPicker[formControl],' +
                        'listPicker[ngModel],listPicker[formControlName],listPicker[formControl],' +
                        'listpicker[ngModel],listpicker[formControlName],listpicker[formControl],' +
                        'list-picker[ngModel],list-picker[formControlName],list-picker[formControl],' +
                        'TabView[ngModel],TabView[formControlName],TabView[formControl],' +
                        'tabView[ngModel],tabView[formControlName],tabView[formControl],' +
                        'tabview[ngModel],tabview[formControlName],tabview[formControl],' +
                        'tab-view[ngModel],tab-view[formControlName],tab-view[formControl]',
                    providers: [SELECTED_INDEX_VALUE_ACCESSOR],
                    host: {
                        '(selectedIndexChange)': 'onChange($event.value)',
                    },
                },] }
    ];
    SelectedIndexValueAccessor.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };

    var NativeScriptFormsModule = /** @class */ (function () {
        function NativeScriptFormsModule() {
        }
        return NativeScriptFormsModule;
    }());
    NativeScriptFormsModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [TextValueAccessor, CheckedValueAccessor, DateValueAccessor, TimeValueAccessor, SelectedIndexValueAccessor, NumberValueAccessor],
                    providers: [],
                    imports: [forms.FormsModule],
                    exports: [forms.FormsModule, TextValueAccessor, CheckedValueAccessor, DateValueAccessor, TimeValueAccessor, SelectedIndexValueAccessor, NumberValueAccessor],
                },] }
    ];

    /**
     * There are cases where multiple activatedRoute nodes should be associated/handled by the same PageRouterOutlet.
     * We can gat additional ActivatedRoutes nodes when there is:
     *  - Lazy loading - there is an additional ActivatedRoute node for the RouteConfig with the `loadChildren` setup
     *  - Componentless routes - there is an additional ActivatedRoute node for the componentless RouteConfig
     *
     * Example:
     *   R  <-- root
     *   |
     * feature (lazy module) <-- RouteConfig: { path: "lazy", loadChildren: "./feature/feature.module#FeatureModule" }
     *   |
     * module (componentless route) <-- RouteConfig: { path: "module", children: [...] } // Note: No 'component'
     *   |
     *  home <-- RouteConfig: { path: "module", component: MyComponent } - this is what we get as activatedRoute param
     *
     *  In these cases we will mark the top-most node (feature). NSRouteReuseStrategy will detach the tree there and
     *  use this ActivateRoute as a kay for caching.
     */
    function findTopActivatedRouteNodeForOutlet(activatedRoute) {
        var outletActivatedRoute = activatedRoute;
        while (outletActivatedRoute.parent && outletActivatedRoute.parent.routeConfig && !outletActivatedRoute.parent.routeConfig.component) {
            outletActivatedRoute = outletActivatedRoute.parent;
        }
        return outletActivatedRoute;
    }
    var pageRouterActivatedSymbol = Symbol('page-router-activated');
    var loaderRefSymbol = Symbol('loader-ref');
    function destroyComponentRef(componentRef) {
        if (componentRef) {
            var loaderRef = componentRef[loaderRefSymbol];
            if (loaderRef) {
                loaderRef.destroy();
            }
            componentRef.destroy();
        }
    }

    var RouterExtensions = /** @class */ (function () {
        function RouterExtensions(router, locationStrategy, frameService) {
            this.router = router;
            this.locationStrategy = locationStrategy;
            this.frameService = frameService;
        }
        RouterExtensions.prototype.navigate = function (commands, extras) {
            if (extras) {
                this.locationStrategy._setNavigationOptions(extras);
            }
            return this.router.navigate(commands, extras);
        };
        RouterExtensions.prototype.navigateByUrl = function (url, options) {
            if (options) {
                this.locationStrategy._setNavigationOptions(options);
            }
            return this.router.navigateByUrl(url);
        };
        RouterExtensions.prototype.back = function (backNavigationOptions) {
            if (backNavigationOptions) {
                this.backOutlets(backNavigationOptions);
            }
            else {
                this.locationStrategy.back();
            }
        };
        RouterExtensions.prototype.canGoBack = function (backNavigationOptions) {
            var _this = this;
            var canGoBack = true;
            if (backNavigationOptions) {
                var _a = this.findOutletsToBack(backNavigationOptions), outletsToBack = _a.outletsToBack, outlets = _a.outlets;
                if (outletsToBack.length !== outlets.length) {
                    exports.NativeScriptDebug.routerError('No outlet found relative to activated route');
                }
                else {
                    outletsToBack.forEach(function (outletToBack) {
                        if (!_this.locationStrategy.canGoBack(outletToBack)) {
                            canGoBack = false;
                        }
                    });
                }
            }
            else {
                canGoBack = this.locationStrategy.canGoBack();
            }
            return canGoBack;
        };
        RouterExtensions.prototype.backToPreviousPage = function () {
            this.frameService.getFrame().goBack();
        };
        RouterExtensions.prototype.canGoBackToPreviousPage = function () {
            return this.frameService.getFrame().canGoBack();
        };
        RouterExtensions.prototype.backOutlets = function (options) {
            var _this = this;
            var _a = this.findOutletsToBack(options), outletsToBack = _a.outletsToBack, outlets = _a.outlets;
            if (outletsToBack.length !== outlets.length) {
                exports.NativeScriptDebug.routerError('No outlet found relative to activated route');
            }
            else {
                outletsToBack.forEach(function (outletToBack) {
                    if (outletToBack.isPageNavigationBack) {
                        exports.NativeScriptDebug.routerError('Attempted to call startGoBack while going back:');
                    }
                    else {
                        _this.locationStrategy.back(outletToBack);
                    }
                });
            }
        };
        // tslint:disable-next-line:max-line-length
        RouterExtensions.prototype.findOutletsToBack = function (options) {
            var outletsToBack = [];
            var rootRoute = this.router.routerState.root;
            var outlets = options.outlets;
            var relativeRoute = options.relativeTo || rootRoute;
            var relativeRouteOutlet = this.findOutletByRoute(relativeRoute);
            var isNSEmptyOutlet = relativeRouteOutlet && relativeRouteOutlet.isNSEmptyOutlet;
            // Lazy named outlet has added 'primary' inner NSEmptyOutlet child.
            // Take parent route when `relativeTo` option points to the outer named outlet.
            if (isNSEmptyOutlet && relativeRoute.outlet !== 'primary') {
                relativeRoute = relativeRoute.parent || relativeRoute;
            }
            var routesToMatch = outlets ? relativeRoute.children : [relativeRoute];
            outlets = outlets || [relativeRoute.outlet];
            var _loop_1 = function (index) {
                var currentRoute = routesToMatch[index];
                if (outlets.some(function (currentOutlet) { return currentOutlet === currentRoute.outlet; })) {
                    var outlet = this_1.findOutletByRoute(currentRoute);
                    if (outlet) {
                        outletsToBack.push(outlet);
                    }
                }
            };
            var this_1 = this;
            for (var index = 0; index < routesToMatch.length; index++) {
                _loop_1(index);
            }
            return { outletsToBack: outletsToBack, outlets: outlets };
        };
        RouterExtensions.prototype.findOutletByRoute = function (currentRoute) {
            var outlet;
            var currentRouteSnapshop = findTopActivatedRouteNodeForOutlet(currentRoute.snapshot);
            var outletKey = this.locationStrategy.getRouteFullPath(currentRouteSnapshop);
            outlet = this.locationStrategy.findOutlet(outletKey, currentRouteSnapshop);
            return outlet;
        };
        return RouterExtensions;
    }());
    RouterExtensions.Éµprov = i0.ÉµÉµdefineInjectable({ factory: function RouterExtensions_Factory() { return new RouterExtensions(i0.ÉµÉµinject(i1.Router), i0.ÉµÉµinject(NSLocationStrategy), i0.ÉµÉµinject(FrameService)); }, token: RouterExtensions, providedIn: "root" });
    RouterExtensions.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    RouterExtensions.ctorParameters = function () { return [
        { type: i1.Router },
        { type: NSLocationStrategy },
        { type: FrameService }
    ]; };

    /**
     * The nsRouterLink directive lets you link to specific parts of your app.
     *
     * Consider the following route configuration:
     * ```
     * [{ path: "/user", component: UserCmp }]
     * ```
     *
     * When linking to this `User` route, you can write:
     *
     * ```
     * <a [nsRouterLink]="["/user"]">link to user component</a>
     * ```
     *
     * NSRouterLink expects the value to be an array of path segments, followed by the params
     * for that level of routing. For instance `["/team", {teamId: 1}, "user", {userId: 2}]`
     * means that we want to generate a link to `/team;teamId=1/user;userId=2`.
     *
     * The first segment name can be prepended with `/`, `./`, or `../`.
     * If the segment begins with `/`, the router will look up the route from the root of the app.
     * If the segment begins with `./`, or doesn"t begin with a slash, the router will
     * instead look in the current component"s children for the route.
     * And if the segment begins with `../`, the router will go up one level.
     */
    var NSRouterLink = /** @class */ (function () {
        function NSRouterLink(router, navigator, route) {
            this.router = router;
            this.navigator = navigator;
            this.route = route;
            this.pageTransition = true;
            this.commands = [];
        }
        Object.defineProperty(NSRouterLink.prototype, "params", {
            set: function (data) {
                if (Array.isArray(data)) {
                    this.commands = data;
                }
                else {
                    this.commands = [data];
                }
            },
            enumerable: false,
            configurable: true
        });
        NSRouterLink.prototype.onTap = function () {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog("nsRouterLink.tapped: " + this.commands + " " + ("clear: " + this.clearHistory + " ") + ("transition: " + JSON.stringify(this.pageTransition) + " ") + ("duration: " + this.pageTransitionDuration));
            }
            var extras = this.getExtras();
            this.navigator.navigateByUrl(this.urlTree, extras);
        };
        NSRouterLink.prototype.getExtras = function () {
            var transition = this.getTransition();
            return {
                skipLocationChange: attrBoolValue(this.skipLocationChange),
                replaceUrl: attrBoolValue(this.replaceUrl),
                clearHistory: this.convertClearHistory(this.clearHistory),
                animated: transition.animated,
                transition: transition.transition,
            };
        };
        Object.defineProperty(NSRouterLink.prototype, "urlTree", {
            get: function () {
                var urlTree = this.router.createUrlTree(this.commands, {
                    relativeTo: this.route,
                    queryParams: this.queryParams,
                    fragment: this.fragment,
                    preserveQueryParams: attrBoolValue(this.preserveQueryParams),
                    queryParamsHandling: this.queryParamsHandling,
                    preserveFragment: attrBoolValue(this.preserveFragment),
                });
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.routerLog("nsRouterLink urlTree created: " + urlTree);
                }
                return urlTree;
            },
            enumerable: false,
            configurable: true
        });
        NSRouterLink.prototype.convertClearHistory = function (value) {
            return value === true || value === 'true';
        };
        NSRouterLink.prototype.getTransition = function () {
            var transition;
            var animated;
            if (typeof this.pageTransition === 'boolean') {
                animated = this.pageTransition;
            }
            else if (typeof this.pageTransition === 'string') {
                if (this.pageTransition === 'none' || this.pageTransition === 'false') {
                    animated = false;
                }
                else {
                    animated = true;
                    transition = {
                        name: this.pageTransition,
                    };
                }
            }
            else {
                animated = true;
                transition = this.pageTransition;
            }
            var duration = +this.pageTransitionDuration;
            if (!isNaN(duration)) {
                transition = transition || {};
                transition.duration = duration;
            }
            return { animated: animated, transition: transition };
        };
        return NSRouterLink;
    }());
    NSRouterLink.decorators = [
        { type: i0.Directive, args: [{ selector: '[nsRouterLink]' },] }
    ];
    NSRouterLink.ctorParameters = function () { return [
        { type: i1.Router },
        { type: RouterExtensions },
        { type: i1.ActivatedRoute }
    ]; };
    NSRouterLink.propDecorators = {
        target: [{ type: i0.Input }],
        queryParams: [{ type: i0.Input }],
        fragment: [{ type: i0.Input }],
        queryParamsHandling: [{ type: i0.Input }],
        preserveQueryParams: [{ type: i0.Input }],
        preserveFragment: [{ type: i0.Input }],
        skipLocationChange: [{ type: i0.Input }],
        replaceUrl: [{ type: i0.Input }],
        clearHistory: [{ type: i0.Input }],
        pageTransition: [{ type: i0.Input }],
        pageTransitionDuration: [{ type: i0.Input }],
        params: [{ type: i0.Input, args: ['nsRouterLink',] }],
        onTap: [{ type: i0.HostListener, args: ['tap',] }]
    };
    function attrBoolValue(s) {
        return s === '' || !!s;
    }

    /* tslint:disable:forin */
    function containsTree(container, containee, exact) {
        if (exact) {
            return equalSegmentGroups(container.root, containee.root);
        }
        else {
            return containsSegmentGroup(container.root, containee.root);
        }
    }
    function equalSegmentGroups(container, containee) {
        if (!equalPath(container.segments, containee.segments)) {
            return false;
        }
        if (container.numberOfChildren !== containee.numberOfChildren) {
            return false;
        }
        for (var c in containee.children) {
            if (!container.children[c]) {
                return false;
            }
            if (!equalSegmentGroups(container.children[c], containee.children[c])) {
                return false;
            }
        }
        return true;
    }
    function containsSegmentGroup(container, containee) {
        return containsSegmentGroupHelper(container, containee, containee.segments);
    }
    function containsSegmentGroupHelper(container, containee, containeePaths) {
        if (container.segments.length > containeePaths.length) {
            var current = container.segments.slice(0, containeePaths.length);
            if (!equalPath(current, containeePaths)) {
                return false;
            }
            if (containee.hasChildren()) {
                return false;
            }
            return true;
        }
        else if (container.segments.length === containeePaths.length) {
            if (!equalPath(container.segments, containeePaths)) {
                return false;
            }
            for (var c in containee.children) {
                if (!container.children[c]) {
                    return false;
                }
                if (!containsSegmentGroup(container.children[c], containee.children[c])) {
                    return false;
                }
            }
            return true;
        }
        else {
            var current = containeePaths.slice(0, container.segments.length);
            var next = containeePaths.slice(container.segments.length);
            if (!equalPath(container.segments, current)) {
                return false;
            }
            if (!container.children[i1.PRIMARY_OUTLET]) {
                return false;
            }
            return containsSegmentGroupHelper(container.children[i1.PRIMARY_OUTLET], containee, next);
        }
    }
    function equalPath(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for (var i = 0; i < a.length; ++i) {
            if (a[i].path !== b[i].path) {
                return false;
            }
        }
        return true;
    }

    /**
     * The NSRouterLinkActive directive lets you add a CSS class to an element when the link"s route
     * becomes active.
     *
     * Consider the following example:
     *
     * ```
     * <a [nsRouterLink]="/user/bob" [nsRouterLinkActive]="active-link">Bob</a>
     * ```
     *
     * When the url is either "/user" or "/user/bob", the active-link class will
     * be added to the component. If the url changes, the class will be removed.
     *
     * You can set more than one class, as follows:
     *
     * ```
     * <a [nsRouterLink]="/user/bob" [nsRouterLinkActive]="class1 class2">Bob</a>
     * <a [nsRouterLink]="/user/bob" [nsRouterLinkActive]="["class1", "class2"]">Bob</a>
     * ```
     *
     * You can configure NSRouterLinkActive by passing `exact: true`. This will add the
     * classes only when the url matches the link exactly.
     *
     * ```
     * <a [nsRouterLink]="/user/bob" [nsRouterLinkActive]="active-link"
     * [nsRouterLinkActiveOptions]="{exact: true}">Bob</a>
     * ```
     *
     * Finally, you can apply the NSRouterLinkActive directive to an ancestor of a RouterLink.
     *
     * ```
     * <div [nsRouterLinkActive]="active-link" [nsRouterLinkActiveOptions]="{exact: true}">
     *   <a [nsRouterLink]="/user/jim">Jim</a>
     *   <a [nsRouterLink]="/user/bob">Bob</a>
     * </div>
     * ```
     *
     * This will set the active-link class on the div tag if the url is either "/user/jim" or
     * "/user/bob".
     *
     * @stable
     */
    var NSRouterLinkActive = /** @class */ (function () {
        function NSRouterLinkActive(router, element, renderer) {
            var _this = this;
            this.router = router;
            this.element = element;
            this.renderer = renderer;
            this.classes = [];
            this.active = false;
            this.nsRouterLinkActiveOptions = { exact: false };
            this.subscription = router.events.subscribe(function (s) {
                if (s instanceof i1.NavigationEnd) {
                    _this.update();
                }
            });
        }
        Object.defineProperty(NSRouterLinkActive.prototype, "isActive", {
            get: function () {
                return this.active;
            },
            enumerable: false,
            configurable: true
        });
        NSRouterLinkActive.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.links.changes.subscribe(function () { return _this.update(); });
            this.update();
        };
        Object.defineProperty(NSRouterLinkActive.prototype, "nsRouterLinkActive", {
            set: function (data) {
                if (Array.isArray(data)) {
                    this.classes = data;
                }
                else {
                    this.classes = data.split(' ');
                }
            },
            enumerable: false,
            configurable: true
        });
        NSRouterLinkActive.prototype.ngOnChanges = function (_) {
            this.update();
        };
        NSRouterLinkActive.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        NSRouterLinkActive.prototype.update = function () {
            var _this = this;
            if (!this.links) {
                return;
            }
            var hasActiveLinks = this.hasActiveLinks();
            // react only when status has changed to prevent unnecessary dom updates
            if (this.active !== hasActiveLinks) {
                var currentUrlTree = this.router.parseUrl(this.router.url);
                var isActiveLinks_1 = this.reduceList(currentUrlTree, this.links);
                this.classes.forEach(function (c) { return _this.renderer.setStyle(_this.element.nativeElement, c, isActiveLinks_1); });
            }
            Promise.resolve(hasActiveLinks).then(function (active) { return (_this.active = active); });
        };
        NSRouterLinkActive.prototype.reduceList = function (currentUrlTree, q) {
            var _this = this;
            return q.reduce(function (res, link) {
                return res || containsTree(currentUrlTree, link.urlTree, _this.nsRouterLinkActiveOptions.exact);
            }, false);
        };
        NSRouterLinkActive.prototype.isLinkActive = function (router) {
            var _this = this;
            return function (link) { return router.isActive(link.urlTree, _this.nsRouterLinkActiveOptions.exact); };
        };
        NSRouterLinkActive.prototype.hasActiveLinks = function () {
            return this.links.some(this.isLinkActive(this.router));
        };
        return NSRouterLinkActive;
    }());
    NSRouterLinkActive.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[nsRouterLinkActive]',
                    exportAs: 'routerLinkActive',
                },] }
    ];
    NSRouterLinkActive.ctorParameters = function () { return [
        { type: i1.Router },
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    NSRouterLinkActive.propDecorators = {
        links: [{ type: i0.ContentChildren, args: [NSRouterLink,] }],
        nsRouterLinkActiveOptions: [{ type: i0.Input }],
        nsRouterLinkActive: [{ type: i0.Input, args: ['nsRouterLinkActive',] }]
    };

    var getSnapshotKey = function (snapshot) {
        return snapshot.pathFromRoot.join('->');
    };
    var Éµ0$5 = getSnapshotKey;
    /**
     * Detached state cache
     */
    var DetachedStateCache = /** @class */ (function () {
        function DetachedStateCache() {
            this.cache = new Array();
        }
        Object.defineProperty(DetachedStateCache.prototype, "length", {
            get: function () {
                return this.cache.length;
            },
            enumerable: false,
            configurable: true
        });
        DetachedStateCache.prototype.push = function (cacheItem) {
            this.cache.push(cacheItem);
        };
        DetachedStateCache.prototype.pop = function () {
            return this.cache.pop();
        };
        DetachedStateCache.prototype.peek = function () {
            return this.cache[this.cache.length - 1];
        };
        DetachedStateCache.prototype.clear = function () {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routeReuseStrategyLog("DetachedStateCache.clear() " + this.cache.length + " items will be destroyed");
            }
            while (this.cache.length > 0) {
                var state = this.cache.pop().state;
                if (!state.componentRef) {
                    throw new Error('No componentRed found in DetachedRouteHandle');
                }
                destroyComponentRef(state.componentRef);
            }
        };
        DetachedStateCache.prototype.clearModalCache = function () {
            var removedItemsCount = 0;
            var hasModalPages = this.cache.some(function (cacheItem) {
                return cacheItem.isModal;
            });
            if (hasModalPages) {
                var modalCacheCleared = false;
                while (!modalCacheCleared) {
                    var cacheItem = this.peek();
                    var state = cacheItem.state;
                    if (!state.componentRef) {
                        throw new Error('No componentRef found in DetachedRouteHandle');
                    }
                    destroyComponentRef(state.componentRef);
                    if (cacheItem.isModal) {
                        modalCacheCleared = true;
                    }
                    this.pop();
                    removedItemsCount++;
                }
            }
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routeReuseStrategyLog("DetachedStateCache.clearModalCache() " + removedItemsCount + " items will be destroyed");
            }
        };
        return DetachedStateCache;
    }());
    /**
     * Detaches subtrees loaded inside PageRouterOutlet in forward navigation
     * and reattaches them on back.
     * Reuses routes as long as their route config is the same.
     */
    var NSRouteReuseStrategy = /** @class */ (function () {
        function NSRouteReuseStrategy(location) {
            this.location = location;
            this.cacheByOutlet = {};
        }
        NSRouteReuseStrategy.prototype.shouldDetach = function (route) {
            route = findTopActivatedRouteNodeForOutlet(route);
            var outletKey = this.location.getRouteFullPath(route);
            var outlet = this.location.findOutlet(outletKey, route);
            var key = getSnapshotKey(route);
            var isPageActivated = route[pageRouterActivatedSymbol];
            var isBack = outlet ? outlet.isPageNavigationBack : false;
            var shouldDetach = outlet && !isBack && isPageActivated;
            if (outlet) {
                if (outlet.parent && !outlet.parent.shouldDetach) {
                    shouldDetach = false;
                }
                outlet.shouldDetach = shouldDetach;
            }
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routeReuseStrategyLog("shouldDetach isBack: " + isBack + " key: " + key + " result: " + shouldDetach);
            }
            return shouldDetach;
        };
        NSRouteReuseStrategy.prototype.shouldAttach = function (route) {
            route = findTopActivatedRouteNodeForOutlet(route);
            var outletKey = this.location.getRouteFullPath(route);
            var outlet = this.location.findOutlet(outletKey, route);
            var cache = this.cacheByOutlet[outletKey];
            if (!cache) {
                return false;
            }
            var key = getSnapshotKey(route);
            var isBack = outlet ? outlet.isPageNavigationBack : false;
            var shouldAttach = isBack && cache.peek().key === key;
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routeReuseStrategyLog("shouldAttach isBack: " + isBack + " key: " + key + " result: " + shouldAttach);
            }
            if (outlet) {
                outlet.shouldDetach = true;
            }
            return shouldAttach;
        };
        NSRouteReuseStrategy.prototype.store = function (route, state) {
            route = findTopActivatedRouteNodeForOutlet(route);
            var key = getSnapshotKey(route);
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routeReuseStrategyLog("store key: " + key + ", state: " + state);
            }
            var outletKey = this.location.getRouteFullPath(route);
            // tslint:disable-next-line:max-line-length
            var cache = (this.cacheByOutlet[outletKey] = this.cacheByOutlet[outletKey] || new DetachedStateCache());
            if (state) {
                var isModal = false;
                if (this.location._modalNavigationDepth > 0) {
                    isModal = true;
                }
                cache.push({ key: key, state: state, isModal: isModal });
            }
            else {
                var topItem = cache.peek();
                if (topItem.key === key) {
                    cache.pop();
                    if (!cache.length) {
                        delete this.cacheByOutlet[outletKey];
                    }
                }
                else {
                    throw new Error("Trying to pop from DetachedStateCache but keys don't match. " + ("expected: " + topItem.key + " actual: " + key));
                }
            }
        };
        NSRouteReuseStrategy.prototype.retrieve = function (route) {
            route = findTopActivatedRouteNodeForOutlet(route);
            var outletKey = this.location.getRouteFullPath(route);
            var outlet = this.location.findOutlet(outletKey, route);
            var cache = this.cacheByOutlet[outletKey];
            if (!cache) {
                return null;
            }
            var key = getSnapshotKey(route);
            var isBack = outlet ? outlet.isPageNavigationBack : false;
            var cachedItem = cache.peek();
            var state = null;
            if (isBack && cachedItem && cachedItem.key === key) {
                state = cachedItem.state;
            }
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routeReuseStrategyLog("retrieved isBack: " + isBack + " key: " + key + " state: " + state);
            }
            return state;
        };
        NSRouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) {
            var shouldReuse = future.routeConfig === curr.routeConfig;
            if (shouldReuse && curr && curr[pageRouterActivatedSymbol]) {
                // When reusing route - copy the pageRouterActivated to the new snapshot
                // It's needed in shouldDetach to determine if the route should be detached.
                future[pageRouterActivatedSymbol] = curr[pageRouterActivatedSymbol];
            }
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routeReuseStrategyLog("shouldReuseRoute result: " + shouldReuse);
            }
            return shouldReuse;
        };
        NSRouteReuseStrategy.prototype.clearCache = function (outletKey) {
            var cache = this.cacheByOutlet[outletKey];
            if (cache) {
                cache.clear();
            }
        };
        NSRouteReuseStrategy.prototype.clearModalCache = function (outletKey) {
            var cache = this.cacheByOutlet[outletKey];
            if (cache) {
                cache.clearModalCache();
            }
        };
        return NSRouteReuseStrategy;
    }());
    NSRouteReuseStrategy.decorators = [
        { type: i0.Injectable }
    ];
    NSRouteReuseStrategy.ctorParameters = function () { return [
        { type: NSLocationStrategy }
    ]; };

    var PageRoute = /** @class */ (function () {
        function PageRoute(startRoute) {
            this.activatedRoute = new rxjs.BehaviorSubject(startRoute);
        }
        return PageRoute;
    }());
    var DestructibleInjector = /** @class */ (function () {
        function DestructibleInjector(destructableProviders, parent) {
            this.destructableProviders = destructableProviders;
            this.parent = parent;
            this.refs = new Set();
        }
        DestructibleInjector.prototype.get = function (token, notFoundValue, flags) {
            var ref = this.parent.get(token, notFoundValue, flags);
            if (this.destructableProviders.has(token)) {
                this.refs.add(ref);
            }
            return ref;
        };
        DestructibleInjector.prototype.destroy = function () {
            this.refs.forEach(function (ref) {
                if (ref.ngOnDestroy instanceof Function) {
                    ref.ngOnDestroy();
                }
            });
            this.refs.clear();
        };
        return DestructibleInjector;
    }());
    var routeToString = function (activatedRoute) {
        return activatedRoute.pathFromRoot.join('->');
    };
    var Éµ0$6 = routeToString;
    var PageRouterOutlet = /** @class */ (function () {
        function PageRouterOutlet(parentContexts, location, name, actionBarVisibility, isEmptyOutlet, locationStrategy, componentFactoryResolver, resolver, changeDetector, pageFactory, routeReuseStrategy, ngZone, elRef) {
            this.parentContexts = parentContexts;
            this.location = location;
            this.locationStrategy = locationStrategy;
            this.componentFactoryResolver = componentFactoryResolver;
            this.resolver = resolver;
            this.changeDetector = changeDetector;
            this.pageFactory = pageFactory;
            this.routeReuseStrategy = routeReuseStrategy;
            this.ngZone = ngZone;
            // tslint:disable-line:directive-class-suffix
            this.activated = null;
            this._activatedRoute = null;
            this.activateEvents = new i0.EventEmitter(); // tslint:disable-line:no-output-rename
            this.deactivateEvents = new i0.EventEmitter(); // tslint:disable-line:no-output-rename
            this.isEmptyOutlet = isEmptyOutlet;
            this.frame = elRef.nativeElement;
            this.setActionBarVisibility(actionBarVisibility);
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog("PageRouterOutlet.constructor frame: " + this.frame);
            }
            this.name = name || i1.PRIMARY_OUTLET;
            parentContexts.onChildOutletCreated(this.name, this);
            this.viewUtil = new ViewUtil(core.Device);
            this.detachedLoaderFactory = resolver.resolveComponentFactory(DetachedLoader);
        }
        Object.defineProperty(PageRouterOutlet.prototype, "locationInjector", {
            /** @deprecated from Angular since v4 */
            get: function () {
                return this.location.injector;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PageRouterOutlet.prototype, "locationFactoryResolver", {
            /** @deprecated from Angular since v4 */
            get: function () {
                return this.resolver;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PageRouterOutlet.prototype, "isActivated", {
            get: function () {
                return !!this.activated;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PageRouterOutlet.prototype, "component", {
            get: function () {
                if (!this.activated) {
                    if (exports.NativeScriptDebug.isLogEnabled()) {
                        exports.NativeScriptDebug.routerLog('Outlet is not activated');
                    }
                    return;
                }
                return this.activated.instance;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PageRouterOutlet.prototype, "activatedRoute", {
            get: function () {
                if (!this.activated) {
                    if (exports.NativeScriptDebug.isLogEnabled()) {
                        exports.NativeScriptDebug.routerLog('Outlet is not activated');
                    }
                    return;
                }
                return this._activatedRoute;
            },
            enumerable: false,
            configurable: true
        });
        PageRouterOutlet.prototype.setActionBarVisibility = function (actionBarVisibility) {
            switch (actionBarVisibility) {
                case 'always':
                case 'never':
                    this.frame.actionBarVisibility = actionBarVisibility;
                    return;
                default:
                    this.frame.actionBarVisibility = 'auto';
            }
        };
        PageRouterOutlet.prototype.ngOnDestroy = function () {
            var _this = this;
            // Clear accumulated modal view page cache when page-router-outlet
            // destroyed on modal view closing
            this.parentContexts.onChildOutletDestroyed(this.name);
            if (this.outlet) {
                this.outlet.outletKeys.forEach(function (key) {
                    _this.routeReuseStrategy.clearModalCache(key);
                });
                this.locationStrategy.clearOutlet(this.frame);
            }
            else {
                exports.NativeScriptDebug.routerLog('PageRouterOutlet.ngOnDestroy: no outlet available for page-router-outlet');
            }
            if (this.isActivated) {
                var c = this.activated.instance;
                this.activated.hostView.detach();
                destroyComponentRef(this.activated);
                this.deactivateEvents.emit(c);
                this.activated = null;
            }
        };
        PageRouterOutlet.prototype.deactivate = function () {
            if (!this.outlet || !this.outlet.isPageNavigationBack) {
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.routerLog('Currently not in page back navigation - component should be detached instead of deactivated.');
                }
                return;
            }
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog('PageRouterOutlet.deactivate() while going back - should destroy');
            }
            if (!this.isActivated) {
                return;
            }
            var c = this.activated.instance;
            destroyComponentRef(this.activated);
            this.activated = null;
            this._activatedRoute = null;
            this.deactivateEvents.emit(c);
        };
        /**
         * Called when the `RouteReuseStrategy` instructs to detach the subtree
         */
        PageRouterOutlet.prototype.detach = function () {
            if (!this.isActivated) {
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.routerLog('Outlet is not activated');
                }
                return;
            }
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog("PageRouterOutlet.detach() - " + routeToString(this._activatedRoute));
            }
            // Detach from ChangeDetection
            this.activated.hostView.detach();
            var component = this.activated;
            this.activated = null;
            this._activatedRoute = null;
            return component;
        };
        /**
         * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
         */
        PageRouterOutlet.prototype.attach = function (ref, activatedRoute) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog("PageRouterOutlet.attach() - " + routeToString(activatedRoute));
            }
            this.activated = ref;
            // reattach to ChangeDetection
            this.activated.hostView.markForCheck();
            this.activated.hostView.reattach();
            this._activatedRoute = activatedRoute;
            this.markActivatedRoute(activatedRoute);
            this.locationStrategy._finishBackPageNavigation(this.frame);
        };
        /**
         * Called by the Router to instantiate a new component during the commit phase of a navigation.
         * This method in turn is responsible for calling the `routerOnActivate` hook of its child.
         */
        PageRouterOutlet.prototype.activateWith = function (activatedRoute, resolver) {
            this.outlet = this.outlet || this.getOutlet(activatedRoute.snapshot);
            if (!this.outlet) {
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.routerError('No outlet found relative to activated route');
                }
                return;
            }
            this.outlet.isNSEmptyOutlet = this.isEmptyOutlet;
            this.locationStrategy.updateOutletFrame(this.outlet, this.frame, this.isEmptyOutlet);
            if (this.outlet && this.outlet.isPageNavigationBack) {
                if (exports.NativeScriptDebug.isLogEnabled()) {
                    exports.NativeScriptDebug.routerLog('Currently in page back navigation - component should be reattached instead of activated.');
                }
                this.locationStrategy._finishBackPageNavigation(this.frame);
            }
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog("PageRouterOutlet.activateWith() - " + routeToString(activatedRoute));
            }
            this._activatedRoute = activatedRoute;
            this.markActivatedRoute(activatedRoute);
            resolver = resolver || this.resolver;
            this.activateOnGoForward(activatedRoute, resolver);
            this.activateEvents.emit(this.activated.instance);
        };
        PageRouterOutlet.prototype.activateOnGoForward = function (activatedRoute, loadedResolver) {
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog('PageRouterOutlet.activate() forward navigation - ' + 'create detached loader in the loader container');
            }
            var factory = this.getComponentFactory(activatedRoute, loadedResolver);
            var page = this.pageFactory({
                isNavigation: true,
                componentType: factory.componentType,
            });
            var destructables = new Set([]);
            var injector = i0.Injector.create({
                providers: [
                    { provide: core.Page, useValue: page },
                    { provide: core.Frame, useValue: this.frame },
                    { provide: PageRoute, useValue: new PageRoute(activatedRoute) },
                    { provide: i1.ActivatedRoute, useValue: activatedRoute },
                    { provide: i1.ChildrenOutletContexts, useValue: this.parentContexts.getOrCreateContext(this.name).children },
                ],
                parent: this.location.injector,
            });
            var childInjector = new DestructibleInjector(destructables, injector);
            var loaderRef = this.location.createComponent(this.detachedLoaderFactory, this.location.length, childInjector, []);
            loaderRef.onDestroy(function () { return childInjector.destroy(); });
            this.changeDetector.markForCheck();
            this.activated = loaderRef.instance.loadWithFactory(factory);
            this.loadComponentInPage(page, this.activated, { activatedRoute: activatedRoute });
            this.activated[loaderRefSymbol] = loaderRef;
        };
        PageRouterOutlet.prototype.loadComponentInPage = function (page, componentRef, navigationContext) {
            var _this = this;
            // Component loaded. Find its root native view.
            var componentView = componentRef.location.nativeElement;
            // Remove it from original native parent.
            this.viewUtil.removeChild(componentView.parent, componentView);
            // Add it to the new page
            this.viewUtil.insertChild(page, componentView);
            var navigatedFromCallback = global.Zone.current.wrap(function (args) {
                if (args.isBackNavigation) {
                    _this.locationStrategy._beginBackPageNavigation(_this.frame);
                    _this.locationStrategy.back(null, _this.frame);
                }
            });
            // TODO: experiment with using NgZone instead of global above
            // const navigatedFromCallback = (args: NavigatedData) => {
            // 	if (args.isBackNavigation) {
            //     this.ngZone.run(() => {
            //       this.locationStrategy._beginBackPageNavigation(this.frame);
            //       this.locationStrategy.back(null, this.frame);
            //     });
            // 	}
            // };
            page.on(core.Page.navigatedFromEvent, navigatedFromCallback);
            componentRef.onDestroy(function () {
                if (page) {
                    page.off(core.Page.navigatedFromEvent, navigatedFromCallback);
                    page = null;
                }
            });
            var navOptions = this.locationStrategy._beginPageNavigation(this.frame);
            // Clear refCache if navigation with clearHistory
            if (navOptions.clearHistory) {
                var clearCallback = function () { return setTimeout(function () {
                    if (_this.outlet) {
                        _this.routeReuseStrategy.clearCache(_this.outlet.outletKeys[0]);
                    }
                }); };
                page.once(core.Page.navigatedToEvent, clearCallback);
            }
            this.frame.navigate({
                create: function () {
                    return page;
                },
                context: navigationContext,
                clearHistory: navOptions.clearHistory,
                animated: navOptions.animated,
                transition: navOptions.transition,
            });
        };
        // Find and mark the top activated route as an activated one.
        // In ns-location-strategy we are reusing components only if their corresponing routes
        // are marked as activated from this method.
        PageRouterOutlet.prototype.markActivatedRoute = function (activatedRoute) {
            var queue = [];
            queue.push(activatedRoute.snapshot);
            var currentRoute = queue.shift();
            while (currentRoute) {
                currentRoute.children.forEach(function (childRoute) {
                    queue.push(childRoute);
                });
                var topActivatedRoute = findTopActivatedRouteNodeForOutlet(currentRoute);
                var outletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute);
                var outlet = this.locationStrategy.findOutlet(outletKey, topActivatedRoute);
                if (outlet && outlet.frames.length) {
                    topActivatedRoute[pageRouterActivatedSymbol] = true;
                    if (exports.NativeScriptDebug.isLogEnabled()) {
                        exports.NativeScriptDebug.routerLog('Activated route marked as page: ' + routeToString(topActivatedRoute));
                    }
                }
                currentRoute = queue.shift();
            }
        };
        PageRouterOutlet.prototype.getComponentFactory = function (activatedRoute, loadedResolver) {
            var component = activatedRoute.routeConfig.component;
            return loadedResolver ? loadedResolver.resolveComponentFactory(component) : this.componentFactoryResolver.resolveComponentFactory(component);
        };
        PageRouterOutlet.prototype.getOutlet = function (activatedRouteSnapshot) {
            var topActivatedRoute = findTopActivatedRouteNodeForOutlet(activatedRouteSnapshot);
            var outletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute);
            var outlet = this.locationStrategy.findOutlet(outletKey, topActivatedRoute);
            // Named lazy loaded outlet.
            if (!outlet && this.isEmptyOutlet) {
                var parentOutletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute.parent);
                outlet = this.locationStrategy.findOutlet(parentOutletKey, topActivatedRoute.parent);
                if (outlet) {
                    outlet.outletKeys.push(outletKey);
                }
            }
            return outlet;
        };
        return PageRouterOutlet;
    }());
    PageRouterOutlet.decorators = [
        { type: i0.Directive, args: [{ selector: 'page-router-outlet' },] }
    ];
    PageRouterOutlet.ctorParameters = function () { return [
        { type: i1.ChildrenOutletContexts },
        { type: i0.ViewContainerRef },
        { type: String, decorators: [{ type: i0.Attribute, args: ['name',] }] },
        { type: String, decorators: [{ type: i0.Attribute, args: ['actionBarVisibility',] }] },
        { type: Boolean, decorators: [{ type: i0.Attribute, args: ['isEmptyOutlet',] }] },
        { type: NSLocationStrategy },
        { type: i0.ComponentFactoryResolver },
        { type: i0.ComponentFactoryResolver },
        { type: i0.ChangeDetectorRef },
        { type: undefined, decorators: [{ type: i0.Inject, args: [PAGE_FACTORY,] }] },
        { type: NSRouteReuseStrategy },
        { type: i0.NgZone },
        { type: i0.ElementRef }
    ]; };
    PageRouterOutlet.propDecorators = {
        activateEvents: [{ type: i0.Output, args: ['activate',] }],
        deactivateEvents: [{ type: i0.Output, args: ['deactivate',] }]
    };
    __decorate([
        core.profile
    ], PageRouterOutlet.prototype, "activateWith", null);
    __decorate([
        core.profile
    ], PageRouterOutlet.prototype, "loadComponentInPage", null);

    var NativescriptPlatformLocation = /** @class */ (function (_super) {
        __extends(NativescriptPlatformLocation, _super);
        function NativescriptPlatformLocation(locationStrategy) {
            var _this = _super.call(this) || this;
            _this.locationStrategy = locationStrategy;
            if (exports.NativeScriptDebug.isLogEnabled()) {
                exports.NativeScriptDebug.routerLog('NativescriptPlatformLocation.constructor()');
            }
            return _this;
        }
        NativescriptPlatformLocation.prototype.getState = function () {
            return undefined;
        };
        NativescriptPlatformLocation.prototype.getBaseHrefFromDOM = function () {
            return '/';
        };
        NativescriptPlatformLocation.prototype.onPopState = function (fn) {
            this.locationStrategy.onPopState(fn);
        };
        NativescriptPlatformLocation.prototype.onHashChange = function (_fn) { };
        Object.defineProperty(NativescriptPlatformLocation.prototype, "search", {
            get: function () {
                return '';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NativescriptPlatformLocation.prototype, "hash", {
            get: function () {
                return '';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NativescriptPlatformLocation.prototype, "pathname", {
            get: function () {
                return this.locationStrategy.path();
            },
            set: function (_newPath) {
                throw new Error('NativescriptPlatformLocation set pathname - not implemented');
            },
            enumerable: false,
            configurable: true
        });
        NativescriptPlatformLocation.prototype.pushState = function (state, title, url) {
            this.locationStrategy.pushState(state, title, url, null);
        };
        NativescriptPlatformLocation.prototype.replaceState = function (state, title, url) {
            this.locationStrategy.replaceState(state, title, url, null);
        };
        NativescriptPlatformLocation.prototype.forward = function () {
            throw new Error('NativescriptPlatformLocation.forward() - not implemented');
        };
        NativescriptPlatformLocation.prototype.back = function () {
            this.locationStrategy.back();
        };
        return NativescriptPlatformLocation;
    }(common.PlatformLocation));
    NativescriptPlatformLocation.decorators = [
        { type: i0.Injectable }
    ];
    NativescriptPlatformLocation.ctorParameters = function () { return [
        { type: NSLocationStrategy }
    ]; };

    var NSEmptyOutletComponent = /** @class */ (function () {
        function NSEmptyOutletComponent(page) {
            var _this = this;
            this.page = page;
            if (this.page) {
                this.page.actionBarHidden = true;
                this.page.on('loaded', function () {
                    if (_this.pageRouterOutlet && _this.page.frame) {
                        _this.pageRouterOutlet.setActionBarVisibility(_this.page.frame.actionBarVisibility);
                    }
                });
            }
        }
        return NSEmptyOutletComponent;
    }());
    NSEmptyOutletComponent.decorators = [
        { type: i0.Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'ns-empty-outlet',
                    template: "<page-router-outlet isEmptyOutlet='true'></page-router-outlet>"
                },] }
    ];
    NSEmptyOutletComponent.ctorParameters = function () { return [
        { type: core.Page }
    ]; };
    NSEmptyOutletComponent.propDecorators = {
        pageRouterOutlet: [{ type: i0.ViewChild, args: [PageRouterOutlet, { read: PageRouterOutlet, static: false },] }]
    };

    var NSModuleFactoryLoader = /** @class */ (function (_super) {
        __extends(NSModuleFactoryLoader, _super);
        function NSModuleFactoryLoader(compiler, config) {
            var _this = _super.call(this, compiler, config) || this;
            console.log("NSModuleFactoryLoader is deprecated! " + "You no longer need to provide it as a module loader.");
            return _this;
        }
        return NSModuleFactoryLoader;
    }(i0.SystemJsNgModuleLoader));
    NSModuleFactoryLoader.decorators = [
        { type: i0.Injectable }
    ];
    NSModuleFactoryLoader.ctorParameters = function () { return [
        { type: i0.Compiler },
        { type: i0.SystemJsNgModuleLoaderConfig, decorators: [{ type: i0.Optional }] }
    ]; };

    function provideLocationStrategy(locationStrategy, frameService) {
        return locationStrategy ? locationStrategy : new NSLocationStrategy(frameService);
    }
    var NativeScriptRouterModule = /** @class */ (function () {
        function NativeScriptRouterModule() {
        }
        NativeScriptRouterModule.forRoot = function (routes, config) {
            return {
                ngModule: NativeScriptRouterModule,
                providers: __spread(i1.RouterModule.forRoot(routes, config).providers, [
                    {
                        provide: NSLocationStrategy,
                        useFactory: provideLocationStrategy,
                        deps: [[NSLocationStrategy, new i0.Optional(), new i0.SkipSelf()], FrameService],
                    },
                    { provide: common.LocationStrategy, useExisting: NSLocationStrategy },
                    NativescriptPlatformLocation,
                    { provide: common.PlatformLocation, useExisting: NativescriptPlatformLocation },
                    RouterExtensions,
                    NSRouteReuseStrategy,
                    { provide: i1.RouteReuseStrategy, useExisting: NSRouteReuseStrategy },
                ]),
            };
        };
        NativeScriptRouterModule.forChild = function (routes) {
            return { ngModule: NativeScriptRouterModule, providers: i1.RouterModule.forChild(routes).providers };
        };
        return NativeScriptRouterModule;
    }());
    NativeScriptRouterModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [NSRouterLink, NSRouterLinkActive, PageRouterOutlet, NSEmptyOutletComponent],
                    entryComponents: [NSEmptyOutletComponent],
                    imports: [i1.RouterModule, NativeScriptCommonModule],
                    exports: [i1.RouterModule, NSRouterLink, NSRouterLinkActive, PageRouterOutlet, NSEmptyOutletComponent],
                    schemas: [i0.NO_ERRORS_SCHEMA],
                },] }
    ];

    // Initial imports and polyfills

    /**
     * Generated bundle index. Do not edit.
     */

    exports.APP_ROOT_VIEW = APP_ROOT_VIEW;
    exports.ActionBarComponent = ActionBarComponent;
    exports.ActionBarScope = ActionBarScope;
    exports.ActionItemDirective = ActionItemDirective;
    exports.AndroidFilterComponent = AndroidFilterComponent;
    exports.AppHostAsyncView = AppHostAsyncView;
    exports.AppHostView = AppHostView;
    exports.BaseValueAccessor = BaseValueAccessor;
    exports.COMMON_PROVIDERS = COMMON_PROVIDERS;
    exports.CheckedValueAccessor = CheckedValueAccessor;
    exports.CommentNode = CommentNode;
    exports.DateValueAccessor = DateValueAccessor;
    exports.DetachedLoader = DetachedLoader;
    exports.DeviceToken = DeviceToken;
    exports.EmulatedRenderer = EmulatedRenderer;
    exports.FileSystemResourceLoader = FileSystemResourceLoader;
    exports.FrameService = FrameService;
    exports.IosFilterComponent = IosFilterComponent;
    exports.ListViewComponent = ListViewComponent;
    exports.ModalDialogParams = ModalDialogParams;
    exports.ModalDialogService = ModalDialogService;
    exports.NSEmptyOutletComponent = NSEmptyOutletComponent;
    exports.NSFileSystem = NSFileSystem;
    exports.NSLocationStrategy = NSLocationStrategy;
    exports.NSModuleFactoryLoader = NSModuleFactoryLoader;
    exports.NSRouterLink = NSRouterLink;
    exports.NSRouterLinkActive = NSRouterLinkActive;
    exports.NS_DIRECTIVES = NS_DIRECTIVES;
    exports.NativeScriptAnimationsModule = NativeScriptAnimationsModule;
    exports.NativeScriptCommonModule = NativeScriptCommonModule;
    exports.NativeScriptDocument = NativeScriptDocument;
    exports.NativeScriptFormsModule = NativeScriptFormsModule;
    exports.NativeScriptHttpClientModule = NativeScriptHttpClientModule;
    exports.NativeScriptModule = NativeScriptModule;
    exports.NativeScriptPlatformRef = NativeScriptPlatformRef;
    exports.NativeScriptRenderer = NativeScriptRenderer;
    exports.NativeScriptRendererFactory = NativeScriptRendererFactory;
    exports.NativeScriptRouterModule = NativeScriptRouterModule;
    exports.NativeScriptSanitizer = NativeScriptSanitizer;
    exports.NavigationButtonDirective = NavigationButtonDirective;
    exports.NsHttpBackEnd = NsHttpBackEnd;
    exports.NumberValueAccessor = NumberValueAccessor;
    exports.Outlet = Outlet;
    exports.PAGE_FACTORY = PAGE_FACTORY;
    exports.PageRoute = PageRoute;
    exports.PageRouterOutlet = PageRouterOutlet;
    exports.RouterExtensions = RouterExtensions;
    exports.SelectedIndexValueAccessor = SelectedIndexValueAccessor;
    exports.TabViewDirective = TabViewDirective;
    exports.TabViewItemDirective = TabViewItemDirective;
    exports.TemplateKeyDirective = TemplateKeyDirective;
    exports.TemplatedItemsComponent = TemplatedItemsComponent;
    exports.TextValueAccessor = TextValueAccessor;
    exports.TimeValueAccessor = TimeValueAccessor;
    exports.defaultDeviceProvider = defaultDeviceProvider;
    exports.defaultFrameProvider = defaultFrameProvider;
    exports.defaultNavOptions = defaultNavOptions;
    exports.defaultPageFactory = defaultPageFactory;
    exports.defaultPageFactoryProvider = defaultPageFactoryProvider;
    exports.defaultPageProvider = defaultPageProvider;
    exports.errorHandlerFactory = errorHandlerFactory;
    exports.getDefaultDevice = getDefaultDevice;
    exports.getDefaultFrame = getDefaultFrame;
    exports.getDefaultPage = getDefaultPage;
    exports.getRootPage = getRootPage;
    exports.getSingleViewRecursive = getSingleViewRecursive;
    exports.getViewClass = getViewClass;
    exports.getViewMeta = getViewMeta;
    exports.isInvisibleNode = isInvisibleNode;
    exports.isKnownView = isKnownView;
    exports.isView = isView;
    exports.onAfterLivesync = onAfterLivesync;
    exports.onBeforeLivesync = onBeforeLivesync;
    exports.once = once;
    exports.platformNativeScriptDynamic = platformNativeScriptDynamic;
    exports.provideLocationStrategy = provideLocationStrategy;
    exports.registerElement = registerElement;
    exports.setRootPage = setRootPage;
    exports.throwIfAlreadyLoaded = throwIfAlreadyLoaded;
    exports.Éµa = InvisibleNode;
    exports.Éµb = NSFileSystem;
    exports.Éµc = ListViewComponent;
    exports.Éµd = TemplatedItemsComponent;
    exports.Éµe = TEMPLATED_ITEMS_COMPONENT;
    exports.Éµf = TemplateKeyDirective;
    exports.Éµg = TabViewDirective;
    exports.Éµh = TabViewItemDirective;
    exports.Éµi = ActionBarComponent;
    exports.Éµj = ActionBarScope;
    exports.Éµk = ActionItemDirective;
    exports.Éµl = NavigationButtonDirective;
    exports.Éµm = AndroidFilterComponent;
    exports.Éµn = IosFilterComponent;
    exports.Éµo = ModalDialogService;
    exports.Éµp = NSLocationStrategy;
    exports.Éµq = ViewUtil;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=nativescript-angular.umd.js.map
